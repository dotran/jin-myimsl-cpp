/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.22
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGPYTHON

#include "Python.h"

/*************************************************************** -*- c -*-
 * python/precommon.swg
 *
 * Rename all exported symbols from common.swg, to avoid symbol
 * clashes if multiple interpreters are included
 *
 ************************************************************************/

#define SWIG_TypeRegister    SWIG_Python_TypeRegister
#define SWIG_TypeCheck       SWIG_Python_TypeCheck
#define SWIG_TypeCast        SWIG_Python_TypeCast
#define SWIG_TypeDynamicCast SWIG_Python_TypeDynamicCast
#define SWIG_TypeName        SWIG_Python_TypeName
#define SWIG_TypePrettyName  SWIG_Python_TypePrettyName
#define SWIG_TypeQuery       SWIG_Python_TypeQuery
#define SWIG_TypeClientData  SWIG_Python_TypeClientData
#define SWIG_PackData        SWIG_Python_PackData 
#define SWIG_UnpackData      SWIG_Python_UnpackData 


/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/

#include <string.h>

#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#  if defined(_MSC_VER) || defined(__GNUC__)
#    if defined(STATIC_LINKED)
#      define SWIGEXPORT(a) a
#      define SWIGIMPORT(a) extern a
#    else
#      define SWIGEXPORT(a) __declspec(dllexport) a
#      define SWIGIMPORT(a) extern a
#    endif
#  else
#    if defined(__BORLANDC__)
#      define SWIGEXPORT(a) a _export
#      define SWIGIMPORT(a) a _export
#    else
#      define SWIGEXPORT(a) a
#      define SWIGIMPORT(a) a
#    endif
#  endif
#else
#  define SWIGEXPORT(a) a
#  define SWIGIMPORT(a) a
#endif

#ifdef SWIG_GLOBAL
#  define SWIGRUNTIME(a) SWIGEXPORT(a)
#else
#  define SWIGRUNTIME(a) static a
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

typedef struct swig_type_info {
  const char             *name;
  swig_converter_func     converter;
  const char             *str;
  void                   *clientdata;
  swig_dycast_func        dcast;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
} swig_type_info;

#ifdef SWIG_NOINCLUDE

SWIGIMPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
SWIGIMPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
SWIGIMPORT(void *)           SWIG_TypeCast(swig_type_info *, void *);
SWIGIMPORT(swig_type_info *) SWIG_TypeDynamicCast(swig_type_info *, void **);
SWIGIMPORT(const char *)     SWIG_TypeName(const swig_type_info *);
SWIGIMPORT(const char *)     SWIG_TypePrettyName(const swig_type_info *);
SWIGIMPORT(swig_type_info *) SWIG_TypeQuery(const char *);
SWIGIMPORT(void)             SWIG_TypeClientData(swig_type_info *, void *);
SWIGIMPORT(char *)           SWIG_PackData(char *, void *, int);
SWIGIMPORT(char *)           SWIG_UnpackData(char *, void *, int);

#else

static swig_type_info *swig_type_list = 0;
static swig_type_info **swig_type_list_handle = &swig_type_list;

/* Register a type mapping with the type-checking */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeRegister(swig_type_info *ti) {
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = *swig_type_list_handle;
  while (tc) {
    if (strcmp(tc->name, ti->name) == 0) {
      /* Already exists in the table.  Just add additional types to the list */
      if (tc->clientdata) ti->clientdata = tc->clientdata;
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = *swig_type_list_handle;
  *swig_type_list_handle = ti;

  /* Build linked lists */
  l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  if (next) next->prev = head;
  head->next = next;
  return ret;
}

/* Check the typename */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeCheck(char *c, swig_type_info *ty) {
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  do {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
        s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      s->prev = ty;
      return s;
    }
    s = s->next;
  } while (s && (s != ty->next));
  return 0;
}

/* Cast a pointer up an inheritance hierarchy */
SWIGRUNTIME(void *) 
SWIG_TypeCast(swig_type_info *ty, void *ptr) {
  if ((!ty) || (!ty->converter)) return ptr;
  return (*ty->converter)(ptr);
}

/* Dynamic pointer casting. Down an inheritance hierarchy */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/* Return the name associated with this type */
SWIGRUNTIME(const char *)
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/* Return the pretty name associated with this type,
   that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME(const char *)
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/* 
   Compare two type names skipping the space characters, therefore
   "char*" == "char *" and "Class<int>" == "Class<int >", etc.

   Return 0 when the two name types are equivalent, as in
   strncmp, but skipping ' '.
*/
static int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return *f1 - *f2;
  }
  return (l1 - f1) - (l2 - f2);
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
*/
static int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = SWIG_TypeNameComp(nb, ne, tb, te) == 0;
    if (*ne) ++ne;
  }
  return equiv;
}
  

/* Search for a swig_type_info structure */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeQuery(const char *name) {
  swig_type_info *ty = *swig_type_list_handle;
  while (ty) {
    if (ty->str && (SWIG_TypeEquiv(ty->str,name))) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

/* Set the clientdata field for a type */
SWIGRUNTIME(void)
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_type_info *tc, *equiv;
  if (ti->clientdata == clientdata) return;
  ti->clientdata = clientdata;
  equiv = ti->next;
  while (equiv) {
    if (!equiv->converter) {
      tc = *swig_type_list_handle;
      while (tc) {
        if ((strcmp(tc->name, equiv->name) == 0))
          SWIG_TypeClientData(tc,clientdata);
        tc = tc->prev;
      }
    }
    equiv = equiv->next;
  }
}

/* Pack binary data into a string */
SWIGRUNTIME(char *)
SWIG_PackData(char *c, void *ptr, int sz) {
  static char hex[17] = "0123456789abcdef";
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  register unsigned char uu;
  for (; u != eu; ++u) {
    uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* Unpack binary data from a string */
SWIGRUNTIME(char *)
SWIG_UnpackData(char *c, void *ptr, int sz) {
  register unsigned char uu = 0;
  register int d;
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    *u = uu;
  }
  return c;
}

#endif

#ifdef __cplusplus
}
#endif

/***********************************************************************
 * pyrun.swg
 *
 *     This file contains the runtime support for Python modules
 *     and includes code for managing global variables and pointer
 *     type checking.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 ************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

#define SWIG_PY_INT     1
#define SWIG_PY_FLOAT   2
#define SWIG_PY_STRING  3
#define SWIG_PY_POINTER 4
#define SWIG_PY_BINARY  5

/* Flags for pointer conversion */

#define SWIG_POINTER_EXCEPTION     0x1
#define SWIG_POINTER_DISOWN        0x2

/* Exception handling in wrappers */
#define SWIG_fail   goto fail

/* Constant information structure */
typedef struct swig_const_info {
    int type;
    char *name;
    long lvalue;
    double dvalue;
    void   *pvalue;
    swig_type_info **ptype;
} swig_const_info;

/* Common SWIG API */
#define SWIG_ConvertPtr(obj, pp, type, flags) \
  SWIG_Python_ConvertPtr(obj, pp, type, flags)
#define SWIG_NewPointerObj(p, type, flags) \
  SWIG_Python_NewPointerObj(p, type, flags)
#define SWIG_MustGetPtr(p, type, argnum, flags) \
  SWIG_Python_MustGetPtr(p, type, argnum, flags)
 
/* Python-specific SWIG API */
#define SWIG_newvarlink() \
  SWIG_Python_newvarlink()
#define SWIG_addvarlink(p, name, get_attr, set_attr) \
  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
#define SWIG_ConvertPacked(obj, ptr, sz, ty, flags) \
  SWIG_Python_ConvertPacked(obj, ptr, sz, ty, flags)
#define SWIG_NewPackedObj(ptr, sz, type) \
  SWIG_Python_NewPackedObj(ptr, sz, type)
#define SWIG_InstallConstants(d, constants) \
  SWIG_Python_InstallConstants(d, constants)

typedef double (*py_objasdbl_conv)(PyObject *obj);

#ifdef SWIG_NOINCLUDE

SWIGIMPORT(int)               SWIG_Python_ConvertPtr(PyObject *, void **, swig_type_info *, int);
SWIGIMPORT(PyObject *)        SWIG_Python_NewPointerObj(void *, swig_type_info *,int own);
SWIGIMPORT(void *)            SWIG_Python_MustGetPtr(PyObject *, swig_type_info *, int, int);
SWIGIMPORT(PyObject *)        SWIG_Python_newvarlink(void);
SWIGIMPORT(void)              SWIG_Python_addvarlink(PyObject *, char *, PyObject *(*)(void), int (*)(PyObject *));
SWIGIMPORT(int)               SWIG_Python_ConvertPacked(PyObject *, void *, int sz, swig_type_info *, int);
SWIGIMPORT(PyObject *)        SWIG_Python_NewPackedObj(void *, int sz, swig_type_info *);
SWIGIMPORT(void)              SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]);


#else


/* -----------------------------------------------------------------------------
 * global variable support code.
 * ----------------------------------------------------------------------------- */

typedef struct swig_globalvar {   
  char       *name;                  /* Name of global variable */
  PyObject *(*get_attr)(void);       /* Return the current value */
  int       (*set_attr)(PyObject *); /* Set the value */
  struct swig_globalvar *next;
} swig_globalvar;

typedef struct swig_varlinkobject {
  PyObject_HEAD
  swig_globalvar *vars;
} swig_varlinkobject;

static PyObject *
swig_varlink_repr(swig_varlinkobject *v) {
  v = v;
  return PyString_FromString("<Global variables>");
}

static int
swig_varlink_print(swig_varlinkobject *v, FILE *fp, int flags) {
  swig_globalvar  *var;
  flags = flags;
  fprintf(fp,"Global variables { ");
  for (var = v->vars; var; var=var->next) {
    fprintf(fp,"%s", var->name);
    if (var->next) fprintf(fp,", ");
  }
  fprintf(fp," }\n");
  return 0;
}

static PyObject *
swig_varlink_getattr(swig_varlinkobject *v, char *n) {
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      return (*var->get_attr)();
    }
    var = var->next;
  }
  PyErr_SetString(PyExc_NameError,"Unknown C global variable");
  return NULL;
}

static int
swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      return (*var->set_attr)(p);
    }
    var = var->next;
  }
  PyErr_SetString(PyExc_NameError,"Unknown C global variable");
  return 1;
}

statichere PyTypeObject varlinktype = {
  PyObject_HEAD_INIT(0)              
  0,                                  /* Number of items in variable part (ob_size) */
  (char *)"swigvarlink",              /* Type name (tp_name) */
  sizeof(swig_varlinkobject),         /* Basic size (tp_basicsize) */
  0,                                  /* Itemsize (tp_itemsize) */
  0,                                  /* Deallocator (tp_dealloc) */ 
  (printfunc) swig_varlink_print,     /* Print (tp_print) */
  (getattrfunc) swig_varlink_getattr, /* get attr (tp_getattr) */
  (setattrfunc) swig_varlink_setattr, /* Set attr (tp_setattr) */
  0,                                  /* tp_compare */
  (reprfunc) swig_varlink_repr,       /* tp_repr */
  0,                                  /* tp_as_number */
  0,                                  /* tp_as_sequence */
  0,                                  /* tp_as_mapping */
  0,                                  /* tp_hash */
  0,                                  /* tp_call */
  0,                                  /* tp_str */
  0,                                  /* tp_getattro */
  0,                                  /* tp_setattro */
  0,                                  /* tp_as_buffer */
  0,                                  /* tp_flags */
  0,                                  /* tp_doc */
  0,                                  /* tp_traverse */
  0,                                  /* tp_clear */
  0,                                  /* tp_richcompare */
  0,                                  /* tp_weaklistoffset */
#if PY_VERSION_HEX >= 0x02020000
  0,                                  /* tp_iter */
  0,                                  /* tp_iternext */
  0,                                  /* tp_methods */
  0,                                  /* tp_members */
  0,                                  /* tp_getset */
  0,                                  /* tp_base */
  0,                                  /* tp_dict */
  0,                                  /* tp_descr_get */
  0,                                  /* tp_descr_set */
  0,                                  /* tp_dictoffset */
  0,                                  /* tp_init */
  0,                                  /* tp_alloc */
  0,                                  /* tp_new */
  0,                                  /* tp_free */
  0,                                  /* tp_is_gc */
  0,                                  /* tp_bases */
  0,                                  /* tp_mro */
  0,                                  /* tp_cache */
  0,                                  /* tp_subclasses */
  0,                                  /* tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030200
  0,                                  /* tp_del */
#endif
#ifdef COUNT_ALLOCS
  /* these must be last */
  0,                                  /* tp_alloc */
  0,                                  /* tp_free */
  0,                                  /* tp_maxalloc */
  0,                                  /*  tp_next */
#endif
};

/* Create a variable linking object for use later */
SWIGRUNTIME(PyObject *)
SWIG_Python_newvarlink(void) {
  swig_varlinkobject *result = 0;
  result = PyMem_NEW(swig_varlinkobject,1);
  varlinktype.ob_type = &PyType_Type;    /* Patch varlinktype into a PyType */
  result->ob_type = &varlinktype;
  result->vars = 0;
  result->ob_refcnt = 0;
  Py_XINCREF((PyObject *) result);
  return ((PyObject*) result);
}

SWIGRUNTIME(void)
SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
  swig_varlinkobject *v;
  swig_globalvar *gv;
  v= (swig_varlinkobject *) p;
  gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
  gv->name = (char *) malloc(strlen(name)+1);
  strcpy(gv->name,name);
  gv->get_attr = get_attr;
  gv->set_attr = set_attr;
  gv->next = v->vars;
  v->vars = gv;
}

/* Convert a pointer value */
SWIGRUNTIME(int)
SWIG_Python_ConvertPtr(PyObject *obj, void **ptr, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  char  *c = 0;
  static PyObject *SWIG_this = 0;
  int    newref = 0;
  PyObject  *pyobj = 0;

  if (!obj) return 0;
  if (obj == Py_None) {
    *ptr = 0;
    return 0;
  }
#ifdef SWIG_COBJECT_TYPES
  if (!(PyCObject_Check(obj))) {
    if (!SWIG_this)
      SWIG_this = PyString_FromString("this");
    pyobj = obj;
    obj = PyObject_GetAttr(obj,SWIG_this);
    newref = 1;
    if (!obj) goto type_error;
    if (!PyCObject_Check(obj)) {
      Py_DECREF(obj);
      goto type_error;
    }
  }  
  *ptr = PyCObject_AsVoidPtr(obj);
  c = (char *) PyCObject_GetDesc(obj);
  if (newref) Py_DECREF(obj);
  goto cobject;
#else
  if (!(PyString_Check(obj))) {
    if (!SWIG_this)
      SWIG_this = PyString_FromString("this");
    pyobj = obj;
    obj = PyObject_GetAttr(obj,SWIG_this);
    newref = 1;
    if (!obj) goto type_error;
    if (!PyString_Check(obj)) {
      Py_DECREF(obj);
      goto type_error;
    }
  } 
  c = PyString_AS_STRING(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') {
    *ptr = (void *) 0;
    if (strcmp(c,"NULL") == 0) {
      if (newref) { Py_DECREF(obj); }
      return 0;
    } else {
      if (newref) { Py_DECREF(obj); }
      goto type_error;
    }
  }
  c++;
  c = SWIG_UnpackData(c,ptr,sizeof(void *));
  if (newref) { Py_DECREF(obj); }
#endif

#ifdef SWIG_COBJECT_TYPES
cobject:
#endif

  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
    *ptr = SWIG_TypeCast(tc,(void*) *ptr);
  }

  if ((pyobj) && (flags & SWIG_POINTER_DISOWN)) {
    PyObject_SetAttrString(pyobj,(char*)"thisown",Py_False);
  }
  return 0;

type_error:
  PyErr_Clear();
  if (flags & SWIG_POINTER_EXCEPTION) {
    if (ty && c) {
      PyErr_Format(PyExc_TypeError, 
		   "Type error. Got %s, expected %s",
		   c, ty->name);
    } else {
      PyErr_SetString(PyExc_TypeError,"Expected a pointer");
    }
  }
  return -1;
}

/* Convert a pointer value, signal an exception on a type mismatch */
SWIGRUNTIME(void *)
SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int argnum, int flags) {
  void *result;
  SWIG_Python_ConvertPtr(obj, &result, ty, flags | SWIG_POINTER_EXCEPTION);
  return result;
}

/* Convert a packed value value */
SWIGRUNTIME(int)
SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, int sz, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  char  *c = 0;

  if ((!obj) || (!PyString_Check(obj))) goto type_error;
  c = PyString_AS_STRING(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c,ptr,sz);
  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
  }
  return 0;

type_error:

  if (flags) {
    if (ty && c) {
      PyErr_Format(PyExc_TypeError, 
		   "Type error. Got %s, expected %s",
		   c, ty->name);
    } else {
      PyErr_SetString(PyExc_TypeError,"Expected a pointer");
    }
  }
  return -1;
}

/* Create a new pointer object */
SWIGRUNTIME(PyObject *)
SWIG_Python_NewPointerObj(void *ptr, swig_type_info *type, int own) {
  PyObject *robj;
  if (!ptr) {
    Py_INCREF(Py_None);
    return Py_None;
  }
#ifdef SWIG_COBJECT_TYPES
  robj = PyCObject_FromVoidPtrAndDesc((void *) ptr, (char *) type->name, NULL);
#else
  {
    char result[1024];
    char *r = result;
    *(r++) = '_';
    r = SWIG_PackData(r,&ptr,sizeof(void *));
    strcpy(r,type->name);
    robj = PyString_FromString(result);
  }
#endif
  if (!robj || (robj == Py_None)) return robj;
  if (type->clientdata) {
    PyObject *inst;
    PyObject *args = Py_BuildValue((char*)"(O)", robj);
    Py_DECREF(robj);
    inst = PyObject_CallObject((PyObject *) type->clientdata, args);
    Py_DECREF(args);
    if (inst) {
      if (own) {
        PyObject_SetAttrString(inst,(char*)"thisown",Py_True);
      }
      robj = inst;
    }
  }
  return robj;
}

SWIGRUNTIME(PyObject *)
SWIG_Python_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  strcpy(r,type->name);
  return PyString_FromString(result);
}

/* Install Constants */
SWIGRUNTIME(void)
SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
  int i;
  PyObject *obj;
  for (i = 0; constants[i].type; i++) {
    switch(constants[i].type) {
    case SWIG_PY_INT:
      obj = PyInt_FromLong(constants[i].lvalue);
      break;
    case SWIG_PY_FLOAT:
      obj = PyFloat_FromDouble(constants[i].dvalue);
      break;
    case SWIG_PY_STRING:
      if (constants[i].pvalue) {
	obj = PyString_FromString((char *) constants[i].pvalue);
      } else {
	Py_INCREF(Py_None);
	obj = Py_None;
      }
      break;
    case SWIG_PY_POINTER:
      obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
      break;
    case SWIG_PY_BINARY:
      obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
      break;
    default:
      obj = 0;
      break;
    }
    if (obj) {
      PyDict_SetItemString(d,constants[i].name,obj);
      Py_DECREF(obj);
    }
  }
}

#endif

/* Contract support */

#define SWIG_contract_assert(expr, msg) if (!(expr)) { PyErr_SetString(PyExc_RuntimeError, (char *) msg ); goto fail; } else

#ifdef __cplusplus
}
#endif


/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_PLcGrid swig_types[0] 
#define  SWIGTYPE_p_PLcGrid2 swig_types[1] 
#define  SWIGTYPE_p_char swig_types[2] 
#define  SWIGTYPE_p_p_char swig_types[3] 
#define  SWIGTYPE_defined_func swig_types[4] 
#define  SWIGTYPE_pltr_func swig_types[5] 
#define  SWIGTYPE_p_PLUNICODE swig_types[6] 
#define  SWIGTYPE_p_PLFLT swig_types[7] 
#define  SWIGTYPE_p_PLINT swig_types[8] 
#define  SWIGTYPE_p_p_PLFLT swig_types[9] 
#define  SWIGTYPE_p_int swig_types[10] 
#define  SWIGTYPE_fill_func swig_types[11] 
#define  SWIGTYPE_p_PLGraphicsIn swig_types[12] 
static swig_type_info *swig_types[14];

/* -------- TYPES TABLE (END) -------- */


/*-----------------------------------------------
              @(target):= _plplotc.so
  ------------------------------------------------*/
#define SWIG_init    init_plplotc

#define SWIG_name    "_plplotc"

/* Auxiliar swig  macros that appear in the header */

#define SWIG_OLDOBJ  1
#define SWIG_NEWOBJ  SWIG_OLDOBJ + 1
#define SWIG_PYSTR   SWIG_NEWOBJ + 1

#ifdef __cplusplus
#define SWIGSTATICINLINE(a) static inline a
#define SWIGSTATIC(a) static a
#define swig_new_array(size,Type) (new Type[(size)])
#define swig_delete(cptr) delete cptr
#define swig_delete_array(cptr) delete[] cptr
#define swig_const_cast(a,Type) const_cast<Type >(a)
#define swig_static_cast(a,Type) static_cast<Type >(a)
#define swig_reinterpret_cast(a,Type) reinterpret_cast<Type >(a)
#define swig_new_copy(ptr,Type) (new Type(*ptr))
#define swig_numeric_cast(a,Type) static_cast<Type >(a)

#else /* C case */

#define SWIGSTATICINLINE(a) static a
#define SWIGSTATIC(a) static a
#define swig_new_array(size,Type) ((Type*) malloc((size)*sizeof(Type)))
#define swig_delete(cptr) free((char*)cptr)
#define swig_delete_array(cptr) free((char*)cptr)
#define swig_const_cast(a,Type) (Type)(a)
#define swig_static_cast(a,Type) (Type)(a)
#define swig_reinterpret_cast(a,Type) (Type)(a)
#define swig_numeric_cast(a,Type) (Type)(a)
#define swig_new_copy(ptr,Type)  ((Type*)memcpy(malloc(sizeof(Type)),ptr,sizeof(Type)))

#endif /* __cplusplus */


/*@/usr/share/swig1.3/python/pymacros.swg,63,SWIG_define@*/
#define SWIG_From_signed_SS_char PyInt_FromLong
/*@@*/
/*@/usr/share/swig1.3/python/pymacros.swg,63,SWIG_define@*/
#define SWIG_From_unsigned_SS_char PyInt_FromLong
/*@@*/
/*@/usr/share/swig1.3/python/pymacros.swg,63,SWIG_define@*/
#define SWIG_From_short PyInt_FromLong
/*@@*/
/*@/usr/share/swig1.3/python/pymacros.swg,63,SWIG_define@*/
#define SWIG_From_unsigned_SS_short PyInt_FromLong
/*@@*/
/*@/usr/share/swig1.3/python/pymacros.swg,63,SWIG_define@*/
#define SWIG_From_int PyInt_FromLong
/*@@*/
/*@/usr/share/swig1.3/python/pymacros.swg,63,SWIG_define@*/
#define SWIG_From_long PyInt_FromLong
/*@@*/
/*@/usr/share/swig1.3/python/pymacros.swg,63,SWIG_define@*/
#define SWIG_From_float PyFloat_FromDouble
/*@@*/
/*@/usr/share/swig1.3/python/pymacros.swg,63,SWIG_define@*/
#define SWIG_From_double PyFloat_FromDouble
/*@@*/


/* Change this to the recommended
#include <Numeric/arrayobject.h> 
 once we no longer support python1.5 */
#include <arrayobject.h>        
#include "plplot.h"      
#include "plplotP.h"

#ifdef PL_DOUBLE
#define  PyArray_PLFLT PyArray_DOUBLE
#else
#define  PyArray_PLFLT PyArray_FLOAT
#endif

#define  PyArray_PLINT PyArray_LONG
/* python-1.5 compatibility mode? */
#define PySequence_Fast_GET_ITEM PySequence_GetItem
#define PySequence_Size PySequence_Length


  static PLINT Alen = 0;
  static PLINT Xlen = 0, Ylen = 0;
  

SWIGSTATICINLINE(int)
  SWIG_AsVal_double(PyObject *obj, double *val)
{
  if (PyFloat_Check(obj)) {
    if (val) *val = PyFloat_AS_DOUBLE(obj);
    return 1;
  }  
  if (PyInt_Check(obj)) {
    if (val) *val = PyInt_AS_LONG(obj);
    return 1;
  }
  if (PyLong_Check(obj)) {
    double v = PyLong_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return 1;
    } else {
      if (!val) PyErr_Clear();
      return 0;
    }
  }
  if (val) {
    PyErr_SetString(PyExc_TypeError, "a double is expected");
  }
  return 0;
}


SWIGSTATICINLINE(double)
SWIG_As_double(PyObject* obj)
{
  double v;
  if (!SWIG_AsVal_double(obj, &v)) {
    /*
      this is needed to make valgrind/purify happier.  the other
      solution is throw an exception, but since this code should work
      with plain C ....
     */
    memset((void*)&v, 0, sizeof(double));
  }
  return v;
}

  
SWIGSTATICINLINE(int)
SWIG_Check_double(PyObject* obj)
{
  return SWIG_AsVal_double(obj, (double*)0);
}


  static PyObject* t_output_helper(PyObject* target, PyObject* o) {
    PyObject*   o2;
    PyObject*   o3;
    
    if (!target) {                   
        target = o;
    } else if (target == Py_None) {  
        Py_DECREF(Py_None);
        target = o;
    } else {                         
        if (!PyTuple_Check(target)) {
	   o2 = target;
	   target = PyTuple_New(1);
	   PyTuple_SetItem(target, 0, o2);
	}
        o3 = PyTuple_New(1);            
        PyTuple_SetItem(o3, 0, o);      

        o2 = target;
        target = PySequence_Concat(o2, o3); 
        Py_DECREF(o2);                      
        Py_DECREF(o3);
    }
    return target;
}



typedef PLINT (*defined_func)(PLFLT, PLFLT);
typedef void (*fill_func)(PLINT, PLFLT*, PLFLT*);
typedef void (*pltr_func)(PLFLT, PLFLT, PLFLT *, PLFLT*, PLPointer);
typedef PLFLT (*f2eval_func)(PLINT, PLINT, PLPointer);
  

SWIGSTATICINLINE(int)
  SWIG_AsVal_long(PyObject * obj, long* val)
{
  if (PyInt_Check(obj)) {
    if (val) *val = PyInt_AS_LONG(obj);
    return 1;
  }
  if (PyLong_Check(obj)) {
    long v = PyLong_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return 1;
    } else {
      if (!val) PyErr_Clear();
      return 0;
    }
  }
  if (val) {
    PyErr_SetString(PyExc_TypeError, "a long is expected");
  }
  return 0;
 }


SWIGSTATICINLINE(long)
SWIG_As_long(PyObject* obj)
{
  long v;
  if (!SWIG_AsVal_long(obj, &v)) {
    /*
      this is needed to make valgrind/purify happier.  the other
      solution is throw an exception, but since this code should work
      with plain C ....
     */
    memset((void*)&v, 0, sizeof(long));
  }
  return v;
}

  
SWIGSTATICINLINE(int)
SWIG_Check_long(PyObject* obj)
{
  return SWIG_AsVal_long(obj, (long*)0);
}


/* returns SWIG_OLDOBJ if the input is a raw char*, SWIG_PYSTR if is a PyString */
SWIGSTATIC(int)
SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize)
{
  static swig_type_info* pchar_info = 0;
  char* vptr = 0;
  if (!pchar_info) pchar_info = SWIG_TypeQuery("char *");
  if (SWIG_ConvertPtr(obj, (void**)&vptr, pchar_info, 0) != -1) {
    if (cptr) *cptr = vptr;
    if (psize) *psize = vptr ? (strlen(vptr) + 1) : 0;
    return SWIG_OLDOBJ;
  } else {
    if (PyString_Check(obj)) {
      if (cptr) {
	*cptr = PyString_AS_STRING(obj);
	if (psize) {
	  *psize = PyString_GET_SIZE(obj) + 1;
	}
      }
      return SWIG_PYSTR;
    }
  }
  if (cptr) {
    PyErr_SetString(PyExc_TypeError, "a string is expected");
  }
  return 0;
}


SWIGSTATICINLINE(int)
SWIG_AsCharPtr(PyObject *obj, char **val)
{
  char* cptr = 0;
  if (SWIG_AsCharPtrAndSize(obj, &cptr, (size_t*)(0))) {
    if (val) *val = cptr;
    return 1;
  }
  if (val) {
    PyErr_SetString(PyExc_TypeError, "a char* is expected");
  }
  return 0;
}



SWIGSTATICINLINE(PyObject* )
  SWIG_From_unsigned_SS_long(unsigned long value)
{
  return (value > LONG_MAX) ?
    PyLong_FromUnsignedLong(value) 
    : PyInt_FromLong(swig_numeric_cast(value,long)); 
}


#if UINT_MAX < LONG_MAX
/*@/usr/share/swig1.3/python/pymacros.swg,63,SWIG_define@*/
#define SWIG_From_unsigned_SS_int SWIG_From_long
/*@@*/
#else
/*@/usr/share/swig1.3/python/pymacros.swg,63,SWIG_define@*/
#define SWIG_From_unsigned_SS_int SWIG_From_unsigned_SS_long
/*@@*/
#endif



SWIGSTATIC(int)
SWIG_AsCharArray(PyObject *obj, char *val, size_t size)
{ 
  char* cptr; size_t csize;  
  if (SWIG_AsCharPtrAndSize(obj, &cptr, &csize)) {
    /* in C you can do:        

         char x[5] = "hello"; 

        ie, assing the array using an extra '0' char.
    */
    if ((csize == size + 1) && !(cptr[csize-1])) --csize;
    if (csize <= size) {
      if (val) {
	if (csize) memcpy(val, cptr, csize);
	if (csize < size) memset(val + csize, 0, size - csize);
      }
      return 1;
    }
  }
  if (val) {
    PyErr_Format(PyExc_TypeError, 
		 "a char array of maximum size %ld is expected", 
		 size);
  }
  return 0;
}


#include <limits.h>


SWIGSTATICINLINE(int)
  SWIG_CheckLongInRange(long value, long min_value, long max_value,
			const char *errmsg)
{
  if (value < min_value) {
    if (errmsg) {
      PyErr_Format(PyExc_OverflowError, 
		   "value %ld is less than '%s' minimum %ld", 
		   value, errmsg, min_value);
    }
    return 0;    
  } else if (value > max_value) {
    if (errmsg) {
      PyErr_Format(PyExc_OverflowError,
		   "value %ld is greater than '%s' maximum %ld", 
		   value, errmsg, max_value);
    }
    return 0;
  }
  return 1;
}


SWIGSTATICINLINE(int)
  SWIG_AsVal_char(PyObject *obj, char *val)
{
  const char* errmsg = val ? "char" : 0;
  long v;
  if (SWIG_AsVal_long(obj, &v)) {
    if (SWIG_CheckLongInRange(v, CHAR_MIN,CHAR_MAX, errmsg)) {
      if (val) *val = v;
      return 1;
    } else {
      return 0;
    }    
  } else {
    PyErr_Clear();
    return SWIG_AsCharArray(obj, val, 1);
  }
 }


SWIGSTATICINLINE(char)
SWIG_As_char(PyObject* obj)
{
  char v;
  if (!SWIG_AsVal_char(obj, &v)) {
    /*
      this is needed to make valgrind/purify happier.  the other
      solution is throw an exception, but since this code should work
      with plain C ....
     */
    memset((void*)&v, 0, sizeof(char));
  }
  return v;
}

  
SWIGSTATICINLINE(int)
SWIG_Check_char(PyObject* obj)
{
  return SWIG_AsVal_char(obj, (char*)0);
}


SWIGSTATICINLINE(int)
  SWIG_CheckUnsignedLongInRange(unsigned long value,
				unsigned long max_value,
				const char *errmsg) 
{
  if (value > max_value) {
    if (errmsg) {
      PyErr_Format(PyExc_OverflowError,
		   "value %ld is greater than '%s' minimum %ld",
		   value, errmsg, max_value);
    }
    return 0;
  }
  return 1;
 }


SWIGSTATICINLINE(int)
  SWIG_AsVal_unsigned_SS_long(PyObject * obj, unsigned long *val) 
{
  if (PyInt_Check(obj)) {
    long v = PyInt_AS_LONG(obj);
    if (v >= 0) {
      if (val) *val = v;
      return 1;
    }   
  }
  if (PyLong_Check(obj)) {
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return 1;
    } else {
      if (!val) PyErr_Clear();
      return 0;
    }
  } 
  if (val) {
    PyErr_SetString(PyExc_TypeError, "an unsigned long is expected");
  }
  return 0;
}


#if UINT_MAX != ULONG_MAX
SWIGSTATICINLINE(int)
  SWIG_AsVal_unsigned_SS_int(PyObject *obj, unsigned int *val)
{ 
  const char* errmsg = val ? "unsigned int" : 0;
  unsigned long v;
  if (SWIG_AsVal_unsigned_SS_long(obj, &v)) {
    if (SWIG_CheckUnsignedLongInRange(v, INT_MAX, errmsg)) {
      if (val) *val = swig_numeric_cast(v, unsigned int);
      return 1;
    }
  } else {
    PyErr_Clear();
  }
  if (val) {
    PyErr_SetString(PyExc_TypeError, "an unsigned int is expected");
  }
  return 0;    
}
#else
SWIGSTATICINLINE(unsigned int)
  SWIG_AsVal_unsigned_SS_int(PyObject *obj, unsigned int *val)
{
  return SWIG_AsVal_unsigned_SS_long(obj,(unsigned long *)val);
}
#endif


SWIGSTATICINLINE(unsigned int)
SWIG_As_unsigned_SS_int(PyObject* obj)
{
  unsigned int v;
  if (!SWIG_AsVal_unsigned_SS_int(obj, &v)) {
    /*
      this is needed to make valgrind/purify happier.  the other
      solution is throw an exception, but since this code should work
      with plain C ....
     */
    memset((void*)&v, 0, sizeof(unsigned int));
  }
  return v;
}

  
SWIGSTATICINLINE(int)
SWIG_Check_unsigned_SS_int(PyObject* obj)
{
  return SWIG_AsVal_unsigned_SS_int(obj, (unsigned int*)0);
}

#ifdef __cplusplus
extern "C" {
#endif

#define myArray_ContiguousFromObject PyArray_ContiguousFromObject
  
static PyObject *_wrap_pltr0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT arg1 ;
    PLFLT arg2 ;
    PLFLT *arg3 = (PLFLT *) 0 ;
    PLFLT *arg4 = (PLFLT *) 0 ;
    PLPointer arg5 = (PLPointer) 0 ;
    PLFLT temp3 ;
    int res3 = 0 ;
    PLFLT temp4 ;
    int res4 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    arg3 = &temp3; res3 = SWIG_NEWOBJ;
    arg4 = &temp4; res4 = SWIG_NEWOBJ;
    {
        arg5 = NULL;
    }
    if(!PyArg_ParseTuple(args,(char *)"OO:pltr0",&obj0,&obj1)) goto fail;
    arg1 = (PLFLT)SWIG_As_double(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLFLT)SWIG_As_double(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    pltr0(arg1,arg2,arg3,arg4,arg5);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    resultobj = t_output_helper(resultobj, ((res3 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg3)) : SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_PLFLT, 0)));
    resultobj = t_output_helper(resultobj, ((res4 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg4)) : SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_PLFLT, 0)));
    return resultobj;
    fail:
    return NULL;
}



  PyArrayObject *pltr_xg, *pltr_yg;
  static PLcGrid tmpGrid1;
  static PLcGrid2 tmpGrid2;

  PLcGrid* marshal_PLcGrid1(PyObject* input) {
    /* fprintf(stderr, "marshal PLcGrid1\n"); */
    if(!PySequence_Check(input) || PySequence_Size(input) != 2) {
      PyErr_SetString(PyExc_ValueError, "Expected a sequence of two arrays.");
      return NULL;
    }
    pltr_xg = (PyArrayObject*)myArray_ContiguousFromObject(PySequence_Fast_GET_ITEM(input, 0),
							   PyArray_PLFLT, 1, 1);
    pltr_yg = (PyArrayObject*)myArray_ContiguousFromObject(PySequence_Fast_GET_ITEM(input, 1), 
							   PyArray_PLFLT, 1, 1);
    if(pltr_xg == 0 || pltr_yg == 0) {
      PyErr_SetString(PyExc_ValueError, "Expected a sequence to two 1D arrays.");
      return NULL;
    }
    tmpGrid1.nx = pltr_xg->dimensions[0];
    tmpGrid1.ny = pltr_yg->dimensions[0];
    if(Xlen != tmpGrid1.nx || Ylen != tmpGrid1.ny) {
      PyErr_SetString(PyExc_ValueError, "pltr arguments must have X and Y dimensions of first arg.");
      return NULL;
    }
    tmpGrid1.xg = (PLFLT*)pltr_xg->data;
    tmpGrid1.yg = (PLFLT*)pltr_yg->data;
    return &tmpGrid1;
  }

  void cleanup_PLcGrid1(void) {
    /* fprintf(stderr, "cleanup PLcGrid1\n"); */
    Py_DECREF(pltr_xg);
    Py_DECREF(pltr_yg);
  }

  PLcGrid2* marshal_PLcGrid2(PyObject* input) {
    int i, size;
    /* fprintf(stderr, "marshal PLcGrid2\n"); */
    if(!PySequence_Check(input) || PySequence_Size(input) != 2) {
      PyErr_SetString(PyExc_ValueError, "Expected a sequence of two arrays.");
      return NULL;
    }
    pltr_xg = (PyArrayObject*)myArray_ContiguousFromObject(PySequence_Fast_GET_ITEM(input, 0),
							   PyArray_PLFLT, 2, 2);
    pltr_yg = (PyArrayObject*)myArray_ContiguousFromObject(PySequence_Fast_GET_ITEM(input, 1), 
							   PyArray_PLFLT, 2, 2);
    if(pltr_xg == 0 || pltr_yg == 0) {
      PyErr_SetString(PyExc_ValueError, "Expected a sequence of two 2D arrays.");
      return NULL;
    }
    if(pltr_xg->dimensions[0] != pltr_yg->dimensions[0] ||
       pltr_xg->dimensions[1] != pltr_yg->dimensions[1]) {
      PyErr_SetString(PyExc_ValueError, "Arrays must be same size.");
      return NULL;
    }
    tmpGrid2.nx = pltr_xg->dimensions[0];
    tmpGrid2.ny = pltr_xg->dimensions[1];
    if(Xlen != tmpGrid2.nx || Ylen != tmpGrid2.ny) {
      PyErr_SetString(PyExc_ValueError, "pltr arguments must have X and Y dimensions of first arg.");
      return NULL;
    }
    size = sizeof(PLFLT)*tmpGrid2.ny;
    tmpGrid2.xg = (PLFLT**)malloc(sizeof(PLFLT*)*tmpGrid2.nx);
    for(i=0; i<tmpGrid2.nx; i++)
      tmpGrid2.xg[i] = (PLFLT*)(pltr_xg->data + i*size);
    tmpGrid2.yg = (PLFLT**)malloc(sizeof(PLFLT*)*tmpGrid2.nx);
    for(i=0; i<tmpGrid2.nx; i++)
      tmpGrid2.yg[i] = (PLFLT*)(pltr_yg->data + i*size);
    return &tmpGrid2;
  }

  void cleanup_PLcGrid2(void) {
    /* fprintf(stderr, "cleanup PLcGrid2\n"); */
    free(tmpGrid2.xg);
    free(tmpGrid2.yg);
    Py_DECREF(pltr_xg);
    Py_DECREF(pltr_yg);
  }
  
static PyObject *_wrap_pltr1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT arg1 ;
    PLFLT arg2 ;
    PLFLT *arg3 = (PLFLT *) 0 ;
    PLFLT *arg4 = (PLFLT *) 0 ;
    PLcGrid *arg5 = (PLcGrid *) 0 ;
    PLFLT temp3 ;
    int res3 = 0 ;
    PLFLT temp4 ;
    int res4 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    arg3 = &temp3; res3 = SWIG_NEWOBJ;
    arg4 = &temp4; res4 = SWIG_NEWOBJ;
    if(!PyArg_ParseTuple(args,(char *)"OOO:pltr1",&obj0,&obj1,&obj2)) goto fail;
    arg1 = (PLFLT)SWIG_As_double(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLFLT)SWIG_As_double(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    {
        arg5 = marshal_PLcGrid1(obj2);
        if(!arg5)
        return NULL;
    }
    pltr1(arg1,arg2,arg3,arg4,arg5);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    resultobj = t_output_helper(resultobj, ((res3 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg3)) : SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_PLFLT, 0)));
    resultobj = t_output_helper(resultobj, ((res4 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg4)) : SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_PLFLT, 0)));
    {
        cleanup_PLcGrid1();
    }
    return resultobj;
    fail:
    {
        cleanup_PLcGrid1();
    }
    return NULL;
}


static PyObject *_wrap_pltr2(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT arg1 ;
    PLFLT arg2 ;
    PLFLT *arg3 = (PLFLT *) 0 ;
    PLFLT *arg4 = (PLFLT *) 0 ;
    PLcGrid2 *arg5 = (PLcGrid2 *) 0 ;
    PLFLT temp3 ;
    int res3 = 0 ;
    PLFLT temp4 ;
    int res4 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    arg3 = &temp3; res3 = SWIG_NEWOBJ;
    arg4 = &temp4; res4 = SWIG_NEWOBJ;
    if(!PyArg_ParseTuple(args,(char *)"OOO:pltr2",&obj0,&obj1,&obj2)) goto fail;
    arg1 = (PLFLT)SWIG_As_double(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLFLT)SWIG_As_double(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    {
        arg5 = marshal_PLcGrid2(obj2);
        if(!arg5)
        return NULL;
    }
    pltr2(arg1,arg2,arg3,arg4,arg5);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    resultobj = t_output_helper(resultobj, ((res3 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg3)) : SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_PLFLT, 0)));
    resultobj = t_output_helper(resultobj, ((res4 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg4)) : SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_PLFLT, 0)));
    {
        cleanup_PLcGrid2();
    }
    return resultobj;
    fail:
    {
        cleanup_PLcGrid2();
    }
    return NULL;
}




  /* helper code for handling the callback */
#if 0
 static PyInterpreterState *save_interp = NULL;
#endif
 enum callback_type { CB_0, CB_1, CB_2, CB_Python } pltr_type;
 PyObject* python_pltr = NULL;
 PyObject* python_f2eval = NULL;

#if 0
#define MY_BLOCK_THREADS { \
	PyThreadState *prev_state, *new_state; \
	/* need to have started a thread at some stage */ \
	/* for the following to work */ \
	PyEval_AcquireLock(); \
	new_state = PyThreadState_New(save_interp); \
	prev_state = PyThreadState_Swap(new_state);
#define MY_UNBLOCK_THREADS \
	new_state = PyThreadState_Swap(prev_state); \
	PyThreadState_Clear(new_state); \
	PyEval_ReleaseLock(); \
	PyThreadState_Delete(new_state); \
}
#else
#define MY_BLOCK_THREADS
#define MY_UNBLOCK_THREADS
#endif

/* This is the callback that gets handed to the C code. It, in turn, calls the Python callback */

  void do_pltr_callback(PLFLT x, PLFLT y, PLFLT *tx, PLFLT *ty, PLPointer data)
    {
      PyObject *pdata, *arglist, *result;
      PyArrayObject *tmp;

      /* the data argument is acutally a pointer to a python object */
      pdata = (PyObject*)data;
      if(data == NULL) {
	pdata = Py_None;
      }
      if(python_pltr) { /* if not something is terribly wrong */
	/* hold a reference to the data object */
	Py_XINCREF(pdata);
	/* grab the Global Interpreter Lock to be sure threads don't mess us up */
	MY_BLOCK_THREADS
	/* build the argument list */
#ifdef PL_DOUBLE
	arglist = Py_BuildValue("(ddO)", x, y, pdata);
#else
	arglist = Py_BuildValue("(ffO)", x, y, pdata);
#endif
	if(arglist == NULL) {
	  fprintf(stderr, "Py_BuildValue failed to make argument list.\n");
	  *tx = *ty = 0;
	  return;
	}
	/* call the python function */
	result = PyEval_CallObject(python_pltr, arglist);
	/* release the argument list */
	Py_XDECREF(arglist);
	/* check and unpack the result */
	if(result == NULL) {
	  fprintf(stderr, "call to python pltr function with 3 arguments failed\n");
	  PyErr_SetString(PyExc_RuntimeError, "pltr callback must take 3 argments.");
	  *tx = *ty = 0;
	} else {
	  tmp = (PyArrayObject *)myArray_ContiguousFromObject(result, PyArray_PLFLT, 1, 1);
	  if(tmp == 0 || tmp->dimensions[0] != 2) {
	    fprintf(stderr, "pltr callback must return a 2 element array or sequence\n");
	    PyErr_SetString(PyExc_RuntimeError, "pltr callback must return a 2-sequence.");
	    *tx = *ty = 0;
	  } else {
	    PLFLT* t = (PLFLT*)tmp->data;
	    *tx = t[0];
	    *ty = t[1];
	    Py_XDECREF(tmp);
	  }
	}
	/* release the result */
	Py_XDECREF(result);
	/* release the global interpreter lock */
	MY_UNBLOCK_THREADS
      }	
    }

  PLFLT do_f2eval_callback(PLINT x, PLINT y, PLPointer data)
    {
      PyObject *pdata, *arglist, *result;
      PLFLT fresult = 0.0;

      /* the data argument is acutally a pointer to a python object */
      pdata = (PyObject*)data;
      if(python_f2eval) { /* if not something is terribly wrong */
	/* hold a reference to the data object */
	Py_XINCREF(pdata);
	/* grab the Global Interpreter Lock to be sure threads don't mess us up */
	MY_BLOCK_THREADS
	/* build the argument list */
	arglist = Py_BuildValue("(iiO)", x, y, pdata);
	/* call the python function */
	result = PyEval_CallObject(python_pltr, arglist);
	/* release the argument list */
	Py_DECREF(arglist);
	/* check and unpack the result */
	if(!PyFloat_Check(result)) {
	  fprintf(stderr, "f2eval callback must return a float\n");
	  PyErr_SetString(PyExc_RuntimeError, "f2eval callback must return a float.");
	} else {
	  /* should I test the type here? */
	  fresult = (PLFLT)PyFloat_AsDouble(result);
	}
	/* release the result */
	Py_XDECREF(result);
	/* release the global interpreter lock */
	MY_UNBLOCK_THREADS
      }	
      return fresult;
    }

/* marshal the pltr function pointer argument */
  pltr_func marshal_pltr(PyObject* input) {
    pltr_func result = do_pltr_callback;
    PyObject* rep = PyObject_Repr(input);
    if(rep) {
      char* str = PyString_AsString(rep);
      if(strcmp(str, "<built-in function pltr0>") == 0) {
	result = pltr0;
	pltr_type = CB_0;
        python_pltr = NULL;
      } else if(strcmp(str, "<built-in function pltr1>") == 0) {
	result = pltr1;
	pltr_type = CB_1;
        python_pltr = NULL;
      } else if(strcmp(str, "<built-in function pltr2>") == 0) {
	result = pltr2;
	pltr_type = CB_2;
        python_pltr = NULL;
      } else {
	python_pltr = input;
	pltr_type = CB_Python;
	Py_XINCREF(input);
      }
      Py_DECREF(rep);
    } else {
      python_pltr = input;
      pltr_type = CB_Python;
      Py_XINCREF(input);
    }
    return result;
  }

  void cleanup_pltr(void) {
    Py_XDECREF(python_pltr);
    python_pltr = 0;
  }

  PLPointer marshal_PLPointer(PyObject* input) {
    PLPointer result = NULL;
    switch(pltr_type) {
    case CB_0:
      break;
    case CB_1:
      if(input != Py_None)
	result = marshal_PLcGrid1(input);
      break;
    case CB_2:
      if(input != Py_None)
	result = marshal_PLcGrid2(input);
      break;
    case CB_Python:
      Py_XINCREF(input);
      result = (PLPointer*)input;
      break;
    default:
      fprintf(stderr, "pltr_type is invalid\n");
    }
    return result;
  }

  void cleanup_PLPointer(void) {
    switch(pltr_type) {
    case CB_0:
      break;
    case CB_1:
      cleanup_PLcGrid1();
      break;
    case CB_2:
      cleanup_PLcGrid2();
      break;
    case CB_Python:
      Py_XDECREF(python_pltr);
      break;
    default:
      fprintf(stderr, "pltr_type is invalid\n");
    }
    python_pltr = 0;
    pltr_type = CB_0;
  }
      
      
  
#define _doc_plsxwin "Set inferior X window." 
static PyObject *_wrap_plsxwin(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:plsxwin",&obj0)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    plsxwin(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_pl_setcontlabelformat "Set the format of the contour labels." 
static PyObject *_wrap_pl_setcontlabelformat(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PLINT arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:pl_setcontlabelformat",&obj0,&obj1)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLINT)SWIG_As_long(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    pl_setcontlabelformat(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_pl_setcontlabelparam "Set offset and spacing of contour labels." 
static PyObject *_wrap_pl_setcontlabelparam(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT arg1 ;
    PLFLT arg2 ;
    PLFLT arg3 ;
    PLINT arg4 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOO:pl_setcontlabelparam",&obj0,&obj1,&obj2,&obj3)) goto fail;
    arg1 = (PLFLT)SWIG_As_double(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLFLT)SWIG_As_double(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    arg3 = (PLFLT)SWIG_As_double(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    arg4 = (PLINT)SWIG_As_long(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    pl_setcontlabelparam(arg1,arg2,arg3,arg4);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_pladv "Advance to subpage \"page\", or to the next one if \"page\" = 0." 
static PyObject *_wrap_pladv(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:pladv",&obj0)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    pladv(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plaxes "This functions similarly to plbox() except that the origin of the axes is placed at the user-specified point (x0, y0)." 
static PyObject *_wrap_plaxes(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT arg1 ;
    PLFLT arg2 ;
    char *arg3 ;
    PLFLT arg4 ;
    PLINT arg5 ;
    char *arg6 ;
    PLFLT arg7 ;
    PLINT arg8 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj5 = 0 ;
    PyObject * obj6 = 0 ;
    PyObject * obj7 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOOOOOO:plaxes",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) goto fail;
    arg1 = (PLFLT)SWIG_As_double(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLFLT)SWIG_As_double(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    if (!SWIG_AsCharPtr(obj2, (char**)&arg3)) SWIG_fail;
    arg4 = (PLFLT)SWIG_As_double(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    arg5 = (PLINT)SWIG_As_long(obj4); 
    if (PyErr_Occurred()) SWIG_fail;
    if (!SWIG_AsCharPtr(obj5, (char**)&arg6)) SWIG_fail;
    arg7 = (PLFLT)SWIG_As_double(obj6); 
    if (PyErr_Occurred()) SWIG_fail;
    arg8 = (PLINT)SWIG_As_long(obj7); 
    if (PyErr_Occurred()) SWIG_fail;
    plaxes(arg1,arg2,(char const *)arg3,arg4,arg5,(char const *)arg6,arg7,arg8);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plbin "Plot a histogram using x to store data values and y to store frequencies." 
static PyObject *_wrap_plbin(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PLFLT *arg2 = (PLFLT *) 0 ;
    PLFLT *arg3 = (PLFLT *) 0 ;
    PLINT arg4 ;
    PyArrayObject *tmp1 ;
    PyArrayObject *tmp2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:plbin",&obj0,&obj1,&obj2)) goto fail;
    {
        tmp1 = (PyArrayObject *)myArray_ContiguousFromObject(obj0, PyArray_PLFLT, 1, 1);
        if(tmp1 == NULL) return NULL;
        arg1 = Alen = tmp1->dimensions[0];
        arg2 = (PLFLT*)tmp1->data;
    }
    {
        tmp2 = (PyArrayObject *)myArray_ContiguousFromObject(obj1, PyArray_PLFLT, 1, 1);
        if(tmp2 == NULL) return NULL;
        if(tmp2->dimensions[0] != Alen) {
            PyErr_SetString(PyExc_ValueError, "Vectors must be same length.");
            return NULL;
        }
        arg3 = (PLFLT*)tmp2->data;
    }
    arg4 = (PLINT)SWIG_As_long(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    plbin(arg1,arg2,arg3,arg4);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    return resultobj;
    fail:
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    return NULL;
}


#define _doc_plbop "Start new page.  Should only be used with pleop()." 
static PyObject *_wrap_plbop(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    
    if(!PyArg_ParseTuple(args,(char *)":plbop")) goto fail;
    plbop();
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plbox "Draw a box around the current viewport." 
static PyObject *_wrap_plbox(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    PLFLT arg2 ;
    PLINT arg3 ;
    char *arg4 ;
    PLFLT arg5 ;
    PLINT arg6 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj5 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOOOO:plbox",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) goto fail;
    if (!SWIG_AsCharPtr(obj0, (char**)&arg1)) SWIG_fail;
    arg2 = (PLFLT)SWIG_As_double(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    arg3 = (PLINT)SWIG_As_long(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    if (!SWIG_AsCharPtr(obj3, (char**)&arg4)) SWIG_fail;
    arg5 = (PLFLT)SWIG_As_double(obj4); 
    if (PyErr_Occurred()) SWIG_fail;
    arg6 = (PLINT)SWIG_As_long(obj5); 
    if (PyErr_Occurred()) SWIG_fail;
    plbox((char const *)arg1,arg2,arg3,(char const *)arg4,arg5,arg6);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plbox3 "This is the 3-d analogue of plbox()." 
static PyObject *_wrap_plbox3(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    char *arg2 ;
    PLFLT arg3 ;
    PLINT arg4 ;
    char *arg5 ;
    char *arg6 ;
    PLFLT arg7 ;
    PLINT arg8 ;
    char *arg9 ;
    char *arg10 ;
    PLFLT arg11 ;
    PLINT arg12 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj5 = 0 ;
    PyObject * obj6 = 0 ;
    PyObject * obj7 = 0 ;
    PyObject * obj8 = 0 ;
    PyObject * obj9 = 0 ;
    PyObject * obj10 = 0 ;
    PyObject * obj11 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOOOOOOOOOO:plbox3",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10,&obj11)) goto fail;
    if (!SWIG_AsCharPtr(obj0, (char**)&arg1)) SWIG_fail;
    if (!SWIG_AsCharPtr(obj1, (char**)&arg2)) SWIG_fail;
    arg3 = (PLFLT)SWIG_As_double(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    arg4 = (PLINT)SWIG_As_long(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    if (!SWIG_AsCharPtr(obj4, (char**)&arg5)) SWIG_fail;
    if (!SWIG_AsCharPtr(obj5, (char**)&arg6)) SWIG_fail;
    arg7 = (PLFLT)SWIG_As_double(obj6); 
    if (PyErr_Occurred()) SWIG_fail;
    arg8 = (PLINT)SWIG_As_long(obj7); 
    if (PyErr_Occurred()) SWIG_fail;
    if (!SWIG_AsCharPtr(obj8, (char**)&arg9)) SWIG_fail;
    if (!SWIG_AsCharPtr(obj9, (char**)&arg10)) SWIG_fail;
    arg11 = (PLFLT)SWIG_As_double(obj10); 
    if (PyErr_Occurred()) SWIG_fail;
    arg12 = (PLINT)SWIG_As_long(obj11); 
    if (PyErr_Occurred()) SWIG_fail;
    plbox3((char const *)arg1,(char const *)arg2,arg3,arg4,(char const *)arg5,(char const *)arg6,arg7,arg8,(char const *)arg9,(char const *)arg10,arg11,arg12);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plcalc_world "Calculate world coordinates and subpage from relative device coordinates." 
static PyObject *_wrap_plcalc_world(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT arg1 ;
    PLFLT arg2 ;
    PLFLT *arg3 = (PLFLT *) 0 ;
    PLFLT *arg4 = (PLFLT *) 0 ;
    PLINT *arg5 = (PLINT *) 0 ;
    PLFLT temp3 ;
    int res3 = 0 ;
    PLFLT temp4 ;
    int res4 = 0 ;
    PLINT temp5 ;
    int res5 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    arg3 = &temp3; res3 = SWIG_NEWOBJ;
    arg4 = &temp4; res4 = SWIG_NEWOBJ;
    arg5 = &temp5; res5 = SWIG_NEWOBJ;
    if(!PyArg_ParseTuple(args,(char *)"OO:plcalc_world",&obj0,&obj1)) goto fail;
    arg1 = (PLFLT)SWIG_As_double(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLFLT)SWIG_As_double(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    plcalc_world(arg1,arg2,arg3,arg4,arg5);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    resultobj = t_output_helper(resultobj, ((res3 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg3)) : SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_PLFLT, 0)));
    resultobj = t_output_helper(resultobj, ((res4 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg4)) : SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_PLFLT, 0)));
    resultobj = t_output_helper(resultobj, ((res5 == SWIG_NEWOBJ) ?
    SWIG_From_long((*arg5)) : SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_PLINT, 0)));
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plclear "Clear current subpage." 
static PyObject *_wrap_plclear(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    
    if(!PyArg_ParseTuple(args,(char *)":plclear")) goto fail;
    plclear();
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plcol0 "Set color, map 0.  Argument is integer between 0 and 15." 
static PyObject *_wrap_plcol0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:plcol0",&obj0)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    plcol0(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plcol1 "Set color, map 1.  Argument is a float between 0. and 1." 
static PyObject *_wrap_plcol1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT arg1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:plcol1",&obj0)) goto fail;
    arg1 = (PLFLT)SWIG_As_double(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    plcol1(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plcont "Draw a contour plot." 
static PyObject *_wrap_plcont(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT **arg1 = (PLFLT **) 0 ;
    PLINT arg2 ;
    PLINT arg3 ;
    PLINT arg4 ;
    PLINT arg5 ;
    PLINT arg6 ;
    PLINT arg7 ;
    PLFLT *arg8 = (PLFLT *) 0 ;
    PLINT arg9 ;
    pltr_func arg10 = (pltr_func) 0 ;
    PLPointer arg11 = (PLPointer) 0 ;
    PyArrayObject *tmp1 ;
    PyArrayObject *tmp6 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj5 = 0 ;
    PyObject * obj6 = 0 ;
    PyObject * obj7 = 0 ;
    
    {
        python_pltr = 0;
        arg10 = NULL;
    }
    {
        arg11 = NULL;
    }
    if(!PyArg_ParseTuple(args,(char *)"OOOOOO|OO:plcont",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) goto fail;
    {
        int i, size;
        tmp1 = (PyArrayObject *)myArray_ContiguousFromObject(obj0, PyArray_PLFLT, 2, 2);
        if(tmp1 == NULL) return NULL;
        Xlen = arg2 = tmp1->dimensions[0];
        Ylen = arg3 = tmp1->dimensions[1];
        size = sizeof(PLFLT)*arg3;
        arg1 = (PLFLT**)malloc(sizeof(PLFLT*)*arg2);
        for(i=0; i<arg2; i++)
        arg1[i] = (PLFLT*)(tmp1->data + i*size);
    }
    arg4 = (PLINT)SWIG_As_long(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    arg5 = (PLINT)SWIG_As_long(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    arg6 = (PLINT)SWIG_As_long(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    arg7 = (PLINT)SWIG_As_long(obj4); 
    if (PyErr_Occurred()) SWIG_fail;
    {
        tmp6 = (PyArrayObject *)myArray_ContiguousFromObject(obj5, PyArray_PLFLT, 1, 1);
        if(tmp6 == NULL) return NULL;
        arg9 = tmp6->dimensions[0];
        arg8 = (PLFLT*)tmp6->data;
    }
    if (obj6) {
        {
            /* it must be a callable */
            if(!PyCallable_Check((PyObject*)obj6)) {
                PyErr_SetString(PyExc_ValueError, "pltr argument must be callable");
                return NULL;
            }
            arg10 = marshal_pltr(obj6);
        }
    }
    if (obj7) {
        {
            if(obj7 == Py_None)
            arg11 = NULL;
            else {
                arg11 = marshal_PLPointer(obj7);
            }
        }
    }
    plcont(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        Py_DECREF(tmp1);
        free(arg1);
    }
    {
        Py_DECREF(tmp6); 
    }
    {
        cleanup_pltr();
    }
    {
        cleanup_PLPointer();
    }
    return resultobj;
    fail:
    {
        Py_DECREF(tmp1);
        free(arg1);
    }
    {
        Py_DECREF(tmp6); 
    }
    {
        cleanup_pltr();
    }
    {
        cleanup_PLPointer();
    }
    return NULL;
}


#define _doc_plcpstrm "Copy state parameters from the reference stream to the current stream." 
static PyObject *_wrap_plcpstrm(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PLINT arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:plcpstrm",&obj0,&obj1)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLINT)SWIG_As_long(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    plcpstrm(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plend "End a plotting session for all open streams." 
static PyObject *_wrap_plend(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    
    if(!PyArg_ParseTuple(args,(char *)":plend")) goto fail;
    plend();
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plend1 "End a plotting session for the current stream only." 
static PyObject *_wrap_plend1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    
    if(!PyArg_ParseTuple(args,(char *)":plend1")) goto fail;
    plend1();
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plenv "Simple interface for defining viewport and window." 
static PyObject *_wrap_plenv(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT arg1 ;
    PLFLT arg2 ;
    PLFLT arg3 ;
    PLFLT arg4 ;
    PLINT arg5 ;
    PLINT arg6 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj5 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOOOO:plenv",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) goto fail;
    arg1 = (PLFLT)SWIG_As_double(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLFLT)SWIG_As_double(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    arg3 = (PLFLT)SWIG_As_double(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    arg4 = (PLFLT)SWIG_As_double(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    arg5 = (PLINT)SWIG_As_long(obj4); 
    if (PyErr_Occurred()) SWIG_fail;
    arg6 = (PLINT)SWIG_As_long(obj5); 
    if (PyErr_Occurred()) SWIG_fail;
    plenv(arg1,arg2,arg3,arg4,arg5,arg6);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_pleop "End current page.  Should only be used with plbop()." 
static PyObject *_wrap_pleop(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    
    if(!PyArg_ParseTuple(args,(char *)":pleop")) goto fail;
    pleop();
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plerrx "Plot horizontal error bars (xmin(i),y(i)) to (xmax(i),y(i))." 
static PyObject *_wrap_plerrx(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PLFLT *arg2 = (PLFLT *) 0 ;
    PLFLT *arg3 = (PLFLT *) 0 ;
    PLFLT *arg4 = (PLFLT *) 0 ;
    PyArrayObject *tmp1 ;
    PyArrayObject *tmp2 ;
    PyArrayObject *tmp3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:plerrx",&obj0,&obj1,&obj2)) goto fail;
    {
        tmp1 = (PyArrayObject *)myArray_ContiguousFromObject(obj0, PyArray_PLFLT, 1, 1);
        if(tmp1 == NULL) return NULL;
        arg1 = Alen = tmp1->dimensions[0];
        arg2 = (PLFLT*)tmp1->data;
    }
    {
        tmp2 = (PyArrayObject *)myArray_ContiguousFromObject(obj1, PyArray_PLFLT, 1, 1);
        if(tmp2 == NULL) return NULL;
        if(tmp2->dimensions[0] != Alen) {
            PyErr_SetString(PyExc_ValueError, "Vectors must be same length.");
            return NULL;
        }
        arg3 = (PLFLT*)tmp2->data;
    }
    {
        tmp3 = (PyArrayObject *)myArray_ContiguousFromObject(obj2, PyArray_PLFLT, 1, 1);
        if(tmp3 == NULL) return NULL;
        if(tmp3->dimensions[0] != Alen) {
            PyErr_SetString(PyExc_ValueError, "Vectors must be same length.");
            return NULL;
        }
        arg4 = (PLFLT*)tmp3->data;
    }
    plerrx(arg1,arg2,arg3,arg4);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3);
    }
    return resultobj;
    fail:
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3);
    }
    return NULL;
}


#define _doc_plerry "Plot vertical error bars (x,ymin(i)) to (x(i),ymax(i))." 
static PyObject *_wrap_plerry(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PLFLT *arg2 = (PLFLT *) 0 ;
    PLFLT *arg3 = (PLFLT *) 0 ;
    PLFLT *arg4 = (PLFLT *) 0 ;
    PyArrayObject *tmp1 ;
    PyArrayObject *tmp2 ;
    PyArrayObject *tmp3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:plerry",&obj0,&obj1,&obj2)) goto fail;
    {
        tmp1 = (PyArrayObject *)myArray_ContiguousFromObject(obj0, PyArray_PLFLT, 1, 1);
        if(tmp1 == NULL) return NULL;
        arg1 = Alen = tmp1->dimensions[0];
        arg2 = (PLFLT*)tmp1->data;
    }
    {
        tmp2 = (PyArrayObject *)myArray_ContiguousFromObject(obj1, PyArray_PLFLT, 1, 1);
        if(tmp2 == NULL) return NULL;
        if(tmp2->dimensions[0] != Alen) {
            PyErr_SetString(PyExc_ValueError, "Vectors must be same length.");
            return NULL;
        }
        arg3 = (PLFLT*)tmp2->data;
    }
    {
        tmp3 = (PyArrayObject *)myArray_ContiguousFromObject(obj2, PyArray_PLFLT, 1, 1);
        if(tmp3 == NULL) return NULL;
        if(tmp3->dimensions[0] != Alen) {
            PyErr_SetString(PyExc_ValueError, "Vectors must be same length.");
            return NULL;
        }
        arg4 = (PLFLT*)tmp3->data;
    }
    plerry(arg1,arg2,arg3,arg4);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3);
    }
    return resultobj;
    fail:
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3);
    }
    return NULL;
}


#define _doc_plfamadv "Advance to the next family file on the next new page." 
static PyObject *_wrap_plfamadv(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    
    if(!PyArg_ParseTuple(args,(char *)":plfamadv")) goto fail;
    plfamadv();
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plfill "Pattern fills the polygon bounded by the input points." 
static PyObject *_wrap_plfill(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PLFLT *arg2 = (PLFLT *) 0 ;
    PLFLT *arg3 = (PLFLT *) 0 ;
    PyArrayObject *tmp1 ;
    PyArrayObject *tmp2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:plfill",&obj0,&obj1)) goto fail;
    {
        tmp1 = (PyArrayObject *)myArray_ContiguousFromObject(obj0, PyArray_PLFLT, 1, 1);
        if(tmp1 == NULL) return NULL;
        arg1 = Alen = tmp1->dimensions[0];
        arg2 = (PLFLT*)tmp1->data;
    }
    {
        tmp2 = (PyArrayObject *)myArray_ContiguousFromObject(obj1, PyArray_PLFLT, 1, 1);
        if(tmp2 == NULL) return NULL;
        if(tmp2->dimensions[0] != Alen) {
            PyErr_SetString(PyExc_ValueError, "Vectors must be same length.");
            return NULL;
        }
        arg3 = (PLFLT*)tmp2->data;
    }
    plfill(arg1,arg2,arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    return resultobj;
    fail:
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    return NULL;
}


#define _doc_plfill3 "Pattern fills the 3d polygon bounded by the input points." 
static PyObject *_wrap_plfill3(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PLFLT *arg2 = (PLFLT *) 0 ;
    PLFLT *arg3 = (PLFLT *) 0 ;
    PLFLT *arg4 = (PLFLT *) 0 ;
    PyArrayObject *tmp1 ;
    PyArrayObject *tmp2 ;
    PyArrayObject *tmp3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:plfill3",&obj0,&obj1,&obj2)) goto fail;
    {
        tmp1 = (PyArrayObject *)myArray_ContiguousFromObject(obj0, PyArray_PLFLT, 1, 1);
        if(tmp1 == NULL) return NULL;
        arg1 = Alen = tmp1->dimensions[0];
        arg2 = (PLFLT*)tmp1->data;
    }
    {
        tmp2 = (PyArrayObject *)myArray_ContiguousFromObject(obj1, PyArray_PLFLT, 1, 1);
        if(tmp2 == NULL) return NULL;
        if(tmp2->dimensions[0] != Alen) {
            PyErr_SetString(PyExc_ValueError, "Vectors must be same length.");
            return NULL;
        }
        arg3 = (PLFLT*)tmp2->data;
    }
    {
        tmp3 = (PyArrayObject *)myArray_ContiguousFromObject(obj2, PyArray_PLFLT, 1, 1);
        if(tmp3 == NULL) return NULL;
        if(tmp3->dimensions[0] != Alen) {
            PyErr_SetString(PyExc_ValueError, "Vectors must be same length.");
            return NULL;
        }
        arg4 = (PLFLT*)tmp3->data;
    }
    plfill3(arg1,arg2,arg3,arg4);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3);
    }
    return resultobj;
    fail:
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3);
    }
    return NULL;
}


#define _doc_plflush "Flush the output stream.  Use sparingly, if at all." 
static PyObject *_wrap_plflush(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    
    if(!PyArg_ParseTuple(args,(char *)":plflush")) goto fail;
    plflush();
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plfont "Set the global font flag to 'ifont'." 
static PyObject *_wrap_plfont(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:plfont",&obj0)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    plfont(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plfontld "Load specified font set." 
static PyObject *_wrap_plfontld(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:plfontld",&obj0)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    plfontld(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plgchr "Get character default height and current (scaled) height." 
static PyObject *_wrap_plgchr(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT *arg1 = (PLFLT *) 0 ;
    PLFLT *arg2 = (PLFLT *) 0 ;
    PLFLT temp1 ;
    int res1 = 0 ;
    PLFLT temp2 ;
    int res2 = 0 ;
    
    arg1 = &temp1; res1 = SWIG_NEWOBJ;
    arg2 = &temp2; res2 = SWIG_NEWOBJ;
    if(!PyArg_ParseTuple(args,(char *)":plgchr")) goto fail;
    plgchr(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    resultobj = t_output_helper(resultobj, ((res1 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg1)) : SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_PLFLT, 0)));
    resultobj = t_output_helper(resultobj, ((res2 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg2)) : SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_PLFLT, 0)));
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plgcol0 "Get 8 bit RGB values for given color from color map 0." 
static PyObject *_wrap_plgcol0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PLINT *arg2 = (PLINT *) 0 ;
    PLINT *arg3 = (PLINT *) 0 ;
    PLINT *arg4 = (PLINT *) 0 ;
    PLINT temp2 ;
    int res2 = 0 ;
    PLINT temp3 ;
    int res3 = 0 ;
    PLINT temp4 ;
    int res4 = 0 ;
    PyObject * obj0 = 0 ;
    
    arg2 = &temp2; res2 = SWIG_NEWOBJ;
    arg3 = &temp3; res3 = SWIG_NEWOBJ;
    arg4 = &temp4; res4 = SWIG_NEWOBJ;
    if(!PyArg_ParseTuple(args,(char *)"O:plgcol0",&obj0)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    plgcol0(arg1,arg2,arg3,arg4);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    resultobj = t_output_helper(resultobj, ((res2 == SWIG_NEWOBJ) ?
    SWIG_From_long((*arg2)) : SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_PLINT, 0)));
    resultobj = t_output_helper(resultobj, ((res3 == SWIG_NEWOBJ) ?
    SWIG_From_long((*arg3)) : SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_PLINT, 0)));
    resultobj = t_output_helper(resultobj, ((res4 == SWIG_NEWOBJ) ?
    SWIG_From_long((*arg4)) : SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_PLINT, 0)));
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plgcolbg "Get 8-bit RGB background color." 
static PyObject *_wrap_plgcolbg(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT *arg1 = (PLINT *) 0 ;
    PLINT *arg2 = (PLINT *) 0 ;
    PLINT *arg3 = (PLINT *) 0 ;
    PLINT temp1 ;
    int res1 = 0 ;
    PLINT temp2 ;
    int res2 = 0 ;
    PLINT temp3 ;
    int res3 = 0 ;
    
    arg1 = &temp1; res1 = SWIG_NEWOBJ;
    arg2 = &temp2; res2 = SWIG_NEWOBJ;
    arg3 = &temp3; res3 = SWIG_NEWOBJ;
    if(!PyArg_ParseTuple(args,(char *)":plgcolbg")) goto fail;
    plgcolbg(arg1,arg2,arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    resultobj = t_output_helper(resultobj, ((res1 == SWIG_NEWOBJ) ?
    SWIG_From_long((*arg1)) : SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_PLINT, 0)));
    resultobj = t_output_helper(resultobj, ((res2 == SWIG_NEWOBJ) ?
    SWIG_From_long((*arg2)) : SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_PLINT, 0)));
    resultobj = t_output_helper(resultobj, ((res3 == SWIG_NEWOBJ) ?
    SWIG_From_long((*arg3)) : SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_PLINT, 0)));
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plgcompression "Get the current compression setting." 
static PyObject *_wrap_plgcompression(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT *arg1 = (PLINT *) 0 ;
    PLINT temp1 ;
    int res1 = 0 ;
    
    arg1 = &temp1; res1 = SWIG_NEWOBJ;
    if(!PyArg_ParseTuple(args,(char *)":plgcompression")) goto fail;
    plgcompression(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    resultobj = t_output_helper(resultobj, ((res1 == SWIG_NEWOBJ) ?
    SWIG_From_long((*arg1)) : SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_PLINT, 0)));
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plgdev "Get the current device (keyword) name." 
static PyObject *_wrap_plgdev(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    char buff1[1000] ;
    
    {
        arg1 = buff1;
    }
    if(!PyArg_ParseTuple(args,(char *)":plgdev")) goto fail;
    plgdev(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        PyObject *o = PyString_FromString(arg1);
        resultobj = t_output_helper(resultobj,o);
    }
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plgdidev "Retrieve current window into device space." 
static PyObject *_wrap_plgdidev(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT *arg1 = (PLFLT *) 0 ;
    PLFLT *arg2 = (PLFLT *) 0 ;
    PLFLT *arg3 = (PLFLT *) 0 ;
    PLFLT *arg4 = (PLFLT *) 0 ;
    PLFLT temp1 ;
    int res1 = 0 ;
    PLFLT temp2 ;
    int res2 = 0 ;
    PLFLT temp3 ;
    int res3 = 0 ;
    PLFLT temp4 ;
    int res4 = 0 ;
    
    arg1 = &temp1; res1 = SWIG_NEWOBJ;
    arg2 = &temp2; res2 = SWIG_NEWOBJ;
    arg3 = &temp3; res3 = SWIG_NEWOBJ;
    arg4 = &temp4; res4 = SWIG_NEWOBJ;
    if(!PyArg_ParseTuple(args,(char *)":plgdidev")) goto fail;
    plgdidev(arg1,arg2,arg3,arg4);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    resultobj = t_output_helper(resultobj, ((res1 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg1)) : SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_PLFLT, 0)));
    resultobj = t_output_helper(resultobj, ((res2 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg2)) : SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_PLFLT, 0)));
    resultobj = t_output_helper(resultobj, ((res3 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg3)) : SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_PLFLT, 0)));
    resultobj = t_output_helper(resultobj, ((res4 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg4)) : SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_PLFLT, 0)));
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plgdiori "Get plot orientation." 
static PyObject *_wrap_plgdiori(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT *arg1 = (PLFLT *) 0 ;
    PLFLT temp1 ;
    int res1 = 0 ;
    
    arg1 = &temp1; res1 = SWIG_NEWOBJ;
    if(!PyArg_ParseTuple(args,(char *)":plgdiori")) goto fail;
    plgdiori(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    resultobj = t_output_helper(resultobj, ((res1 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg1)) : SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_PLFLT, 0)));
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plgdiplt "Retrieve current window into plot space." 
static PyObject *_wrap_plgdiplt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT *arg1 = (PLFLT *) 0 ;
    PLFLT *arg2 = (PLFLT *) 0 ;
    PLFLT *arg3 = (PLFLT *) 0 ;
    PLFLT *arg4 = (PLFLT *) 0 ;
    PLFLT temp1 ;
    int res1 = 0 ;
    PLFLT temp2 ;
    int res2 = 0 ;
    PLFLT temp3 ;
    int res3 = 0 ;
    PLFLT temp4 ;
    int res4 = 0 ;
    
    arg1 = &temp1; res1 = SWIG_NEWOBJ;
    arg2 = &temp2; res2 = SWIG_NEWOBJ;
    arg3 = &temp3; res3 = SWIG_NEWOBJ;
    arg4 = &temp4; res4 = SWIG_NEWOBJ;
    if(!PyArg_ParseTuple(args,(char *)":plgdiplt")) goto fail;
    plgdiplt(arg1,arg2,arg3,arg4);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    resultobj = t_output_helper(resultobj, ((res1 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg1)) : SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_PLFLT, 0)));
    resultobj = t_output_helper(resultobj, ((res2 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg2)) : SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_PLFLT, 0)));
    resultobj = t_output_helper(resultobj, ((res3 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg3)) : SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_PLFLT, 0)));
    resultobj = t_output_helper(resultobj, ((res4 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg4)) : SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_PLFLT, 0)));
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plgfam "Get family file parameters." 
static PyObject *_wrap_plgfam(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT *arg1 = (PLINT *) 0 ;
    PLINT *arg2 = (PLINT *) 0 ;
    PLINT *arg3 = (PLINT *) 0 ;
    PLINT temp1 ;
    int res1 = 0 ;
    PLINT temp2 ;
    int res2 = 0 ;
    PLINT temp3 ;
    int res3 = 0 ;
    
    arg1 = &temp1; res1 = SWIG_NEWOBJ;
    arg2 = &temp2; res2 = SWIG_NEWOBJ;
    arg3 = &temp3; res3 = SWIG_NEWOBJ;
    if(!PyArg_ParseTuple(args,(char *)":plgfam")) goto fail;
    plgfam(arg1,arg2,arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    resultobj = t_output_helper(resultobj, ((res1 == SWIG_NEWOBJ) ?
    SWIG_From_long((*arg1)) : SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_PLINT, 0)));
    resultobj = t_output_helper(resultobj, ((res2 == SWIG_NEWOBJ) ?
    SWIG_From_long((*arg2)) : SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_PLINT, 0)));
    resultobj = t_output_helper(resultobj, ((res3 == SWIG_NEWOBJ) ?
    SWIG_From_long((*arg3)) : SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_PLINT, 0)));
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plgfci "Get FCI (font characterization integer)." 
static PyObject *_wrap_plgfci(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLUNICODE *arg1 = (PLUNICODE *) 0 ;
    PLUNICODE temp1 ;
    int res1 = 0 ;
    
    arg1 = &temp1; res1 = SWIG_NEWOBJ;
    if(!PyArg_ParseTuple(args,(char *)":plgfci")) goto fail;
    plgfci(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    resultobj = t_output_helper(resultobj, ((res1 == SWIG_NEWOBJ) ?
    SWIG_From_unsigned_SS_int((*arg1)) : SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_PLUNICODE, 0)));
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plgfnam "Get the (current) output file name." 
static PyObject *_wrap_plgfnam(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    char buff1[1000] ;
    
    {
        arg1 = buff1;
    }
    if(!PyArg_ParseTuple(args,(char *)":plgfnam")) goto fail;
    plgfnam(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        PyObject *o = PyString_FromString(arg1);
        resultobj = t_output_helper(resultobj,o);
    }
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plglevel "Get the (current) run level." 
static PyObject *_wrap_plglevel(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT *arg1 = (PLINT *) 0 ;
    PLINT temp1 ;
    int res1 = 0 ;
    
    arg1 = &temp1; res1 = SWIG_NEWOBJ;
    if(!PyArg_ParseTuple(args,(char *)":plglevel")) goto fail;
    plglevel(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    resultobj = t_output_helper(resultobj, ((res1 == SWIG_NEWOBJ) ?
    SWIG_From_long((*arg1)) : SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_PLINT, 0)));
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plgpage "Get output device parameters." 
static PyObject *_wrap_plgpage(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT *arg1 = (PLFLT *) 0 ;
    PLFLT *arg2 = (PLFLT *) 0 ;
    PLINT *arg3 = (PLINT *) 0 ;
    PLINT *arg4 = (PLINT *) 0 ;
    PLINT *arg5 = (PLINT *) 0 ;
    PLINT *arg6 = (PLINT *) 0 ;
    PLFLT temp1 ;
    int res1 = 0 ;
    PLFLT temp2 ;
    int res2 = 0 ;
    PLINT temp3 ;
    int res3 = 0 ;
    PLINT temp4 ;
    int res4 = 0 ;
    PLINT temp5 ;
    int res5 = 0 ;
    PLINT temp6 ;
    int res6 = 0 ;
    
    arg1 = &temp1; res1 = SWIG_NEWOBJ;
    arg2 = &temp2; res2 = SWIG_NEWOBJ;
    arg3 = &temp3; res3 = SWIG_NEWOBJ;
    arg4 = &temp4; res4 = SWIG_NEWOBJ;
    arg5 = &temp5; res5 = SWIG_NEWOBJ;
    arg6 = &temp6; res6 = SWIG_NEWOBJ;
    if(!PyArg_ParseTuple(args,(char *)":plgpage")) goto fail;
    plgpage(arg1,arg2,arg3,arg4,arg5,arg6);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    resultobj = t_output_helper(resultobj, ((res1 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg1)) : SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_PLFLT, 0)));
    resultobj = t_output_helper(resultobj, ((res2 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg2)) : SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_PLFLT, 0)));
    resultobj = t_output_helper(resultobj, ((res3 == SWIG_NEWOBJ) ?
    SWIG_From_long((*arg3)) : SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_PLINT, 0)));
    resultobj = t_output_helper(resultobj, ((res4 == SWIG_NEWOBJ) ?
    SWIG_From_long((*arg4)) : SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_PLINT, 0)));
    resultobj = t_output_helper(resultobj, ((res5 == SWIG_NEWOBJ) ?
    SWIG_From_long((*arg5)) : SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_PLINT, 0)));
    resultobj = t_output_helper(resultobj, ((res6 == SWIG_NEWOBJ) ?
    SWIG_From_long((*arg6)) : SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_PLINT, 0)));
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plgra "Switch to graphics screen." 
static PyObject *_wrap_plgra(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    
    if(!PyArg_ParseTuple(args,(char *)":plgra")) goto fail;
    plgra();
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plgspa "Get subpage boundaries in absolute coordinates." 
static PyObject *_wrap_plgspa(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT *arg1 = (PLFLT *) 0 ;
    PLFLT *arg2 = (PLFLT *) 0 ;
    PLFLT *arg3 = (PLFLT *) 0 ;
    PLFLT *arg4 = (PLFLT *) 0 ;
    PLFLT temp1 ;
    int res1 = 0 ;
    PLFLT temp2 ;
    int res2 = 0 ;
    PLFLT temp3 ;
    int res3 = 0 ;
    PLFLT temp4 ;
    int res4 = 0 ;
    
    arg1 = &temp1; res1 = SWIG_NEWOBJ;
    arg2 = &temp2; res2 = SWIG_NEWOBJ;
    arg3 = &temp3; res3 = SWIG_NEWOBJ;
    arg4 = &temp4; res4 = SWIG_NEWOBJ;
    if(!PyArg_ParseTuple(args,(char *)":plgspa")) goto fail;
    plgspa(arg1,arg2,arg3,arg4);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    resultobj = t_output_helper(resultobj, ((res1 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg1)) : SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_PLFLT, 0)));
    resultobj = t_output_helper(resultobj, ((res2 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg2)) : SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_PLFLT, 0)));
    resultobj = t_output_helper(resultobj, ((res3 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg3)) : SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_PLFLT, 0)));
    resultobj = t_output_helper(resultobj, ((res4 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg4)) : SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_PLFLT, 0)));
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plgstrm "Get current stream number." 
static PyObject *_wrap_plgstrm(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT *arg1 = (PLINT *) 0 ;
    PLINT temp1 ;
    int res1 = 0 ;
    
    arg1 = &temp1; res1 = SWIG_NEWOBJ;
    if(!PyArg_ParseTuple(args,(char *)":plgstrm")) goto fail;
    plgstrm(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    resultobj = t_output_helper(resultobj, ((res1 == SWIG_NEWOBJ) ?
    SWIG_From_long((*arg1)) : SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_PLINT, 0)));
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plgver "Get current library version number." 
static PyObject *_wrap_plgver(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    char buff1[1000] ;
    
    {
        arg1 = buff1;
    }
    if(!PyArg_ParseTuple(args,(char *)":plgver")) goto fail;
    plgver(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        PyObject *o = PyString_FromString(arg1);
        resultobj = t_output_helper(resultobj,o);
    }
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plgvpd "Get viewport boundaries in normalized device coordinates." 
static PyObject *_wrap_plgvpd(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT *arg1 = (PLFLT *) 0 ;
    PLFLT *arg2 = (PLFLT *) 0 ;
    PLFLT *arg3 = (PLFLT *) 0 ;
    PLFLT *arg4 = (PLFLT *) 0 ;
    PLFLT temp1 ;
    int res1 = 0 ;
    PLFLT temp2 ;
    int res2 = 0 ;
    PLFLT temp3 ;
    int res3 = 0 ;
    PLFLT temp4 ;
    int res4 = 0 ;
    
    arg1 = &temp1; res1 = SWIG_NEWOBJ;
    arg2 = &temp2; res2 = SWIG_NEWOBJ;
    arg3 = &temp3; res3 = SWIG_NEWOBJ;
    arg4 = &temp4; res4 = SWIG_NEWOBJ;
    if(!PyArg_ParseTuple(args,(char *)":plgvpd")) goto fail;
    plgvpd(arg1,arg2,arg3,arg4);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    resultobj = t_output_helper(resultobj, ((res1 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg1)) : SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_PLFLT, 0)));
    resultobj = t_output_helper(resultobj, ((res2 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg2)) : SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_PLFLT, 0)));
    resultobj = t_output_helper(resultobj, ((res3 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg3)) : SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_PLFLT, 0)));
    resultobj = t_output_helper(resultobj, ((res4 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg4)) : SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_PLFLT, 0)));
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plgvpw "Get viewport boundaries in world coordinates." 
static PyObject *_wrap_plgvpw(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT *arg1 = (PLFLT *) 0 ;
    PLFLT *arg2 = (PLFLT *) 0 ;
    PLFLT *arg3 = (PLFLT *) 0 ;
    PLFLT *arg4 = (PLFLT *) 0 ;
    PLFLT temp1 ;
    int res1 = 0 ;
    PLFLT temp2 ;
    int res2 = 0 ;
    PLFLT temp3 ;
    int res3 = 0 ;
    PLFLT temp4 ;
    int res4 = 0 ;
    
    arg1 = &temp1; res1 = SWIG_NEWOBJ;
    arg2 = &temp2; res2 = SWIG_NEWOBJ;
    arg3 = &temp3; res3 = SWIG_NEWOBJ;
    arg4 = &temp4; res4 = SWIG_NEWOBJ;
    if(!PyArg_ParseTuple(args,(char *)":plgvpw")) goto fail;
    plgvpw(arg1,arg2,arg3,arg4);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    resultobj = t_output_helper(resultobj, ((res1 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg1)) : SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_PLFLT, 0)));
    resultobj = t_output_helper(resultobj, ((res2 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg2)) : SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_PLFLT, 0)));
    resultobj = t_output_helper(resultobj, ((res3 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg3)) : SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_PLFLT, 0)));
    resultobj = t_output_helper(resultobj, ((res4 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg4)) : SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_PLFLT, 0)));
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plgxax "Get x axis labeling parameters." 
static PyObject *_wrap_plgxax(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT *arg1 = (PLINT *) 0 ;
    PLINT *arg2 = (PLINT *) 0 ;
    PLINT temp1 ;
    int res1 = 0 ;
    PLINT temp2 ;
    int res2 = 0 ;
    
    arg1 = &temp1; res1 = SWIG_NEWOBJ;
    arg2 = &temp2; res2 = SWIG_NEWOBJ;
    if(!PyArg_ParseTuple(args,(char *)":plgxax")) goto fail;
    plgxax(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    resultobj = t_output_helper(resultobj, ((res1 == SWIG_NEWOBJ) ?
    SWIG_From_long((*arg1)) : SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_PLINT, 0)));
    resultobj = t_output_helper(resultobj, ((res2 == SWIG_NEWOBJ) ?
    SWIG_From_long((*arg2)) : SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_PLINT, 0)));
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plgyax "Get y axis labeling parameters." 
static PyObject *_wrap_plgyax(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT *arg1 = (PLINT *) 0 ;
    PLINT *arg2 = (PLINT *) 0 ;
    PLINT temp1 ;
    int res1 = 0 ;
    PLINT temp2 ;
    int res2 = 0 ;
    
    arg1 = &temp1; res1 = SWIG_NEWOBJ;
    arg2 = &temp2; res2 = SWIG_NEWOBJ;
    if(!PyArg_ParseTuple(args,(char *)":plgyax")) goto fail;
    plgyax(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    resultobj = t_output_helper(resultobj, ((res1 == SWIG_NEWOBJ) ?
    SWIG_From_long((*arg1)) : SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_PLINT, 0)));
    resultobj = t_output_helper(resultobj, ((res2 == SWIG_NEWOBJ) ?
    SWIG_From_long((*arg2)) : SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_PLINT, 0)));
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plgzax "Get z axis labeling parameters." 
static PyObject *_wrap_plgzax(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT *arg1 = (PLINT *) 0 ;
    PLINT *arg2 = (PLINT *) 0 ;
    PLINT temp1 ;
    int res1 = 0 ;
    PLINT temp2 ;
    int res2 = 0 ;
    
    arg1 = &temp1; res1 = SWIG_NEWOBJ;
    arg2 = &temp2; res2 = SWIG_NEWOBJ;
    if(!PyArg_ParseTuple(args,(char *)":plgzax")) goto fail;
    plgzax(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    resultobj = t_output_helper(resultobj, ((res1 == SWIG_NEWOBJ) ?
    SWIG_From_long((*arg1)) : SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_PLINT, 0)));
    resultobj = t_output_helper(resultobj, ((res2 == SWIG_NEWOBJ) ?
    SWIG_From_long((*arg2)) : SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_PLINT, 0)));
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plhist "Draw histogram." 
static PyObject *_wrap_plhist(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PLFLT *arg2 = (PLFLT *) 0 ;
    PLFLT arg3 ;
    PLFLT arg4 ;
    PLINT arg5 ;
    PLINT arg6 ;
    PyArrayObject *tmp1 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOOO:plhist",&obj0,&obj1,&obj2,&obj3,&obj4)) goto fail;
    {
        tmp1 = (PyArrayObject *)myArray_ContiguousFromObject(obj0, PyArray_PLFLT, 1, 1);
        if(tmp1 == NULL) return NULL;
        arg1 = Alen = tmp1->dimensions[0];
        arg2 = (PLFLT*)tmp1->data;
    }
    arg3 = (PLFLT)SWIG_As_double(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    arg4 = (PLFLT)SWIG_As_double(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    arg5 = (PLINT)SWIG_As_long(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    arg6 = (PLINT)SWIG_As_long(obj4); 
    if (PyErr_Occurred()) SWIG_fail;
    plhist(arg1,arg2,arg3,arg4,arg5,arg6);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        Py_DECREF(tmp1);
    }
    return resultobj;
    fail:
    {
        Py_DECREF(tmp1);
    }
    return NULL;
}


#define _doc_plhls "Set current color (map 0) by hue, lightness, and saturation." 
static PyObject *_wrap_plhls(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT arg1 ;
    PLFLT arg2 ;
    PLFLT arg3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:plhls",&obj0,&obj1,&obj2)) goto fail;
    arg1 = (PLFLT)SWIG_As_double(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLFLT)SWIG_As_double(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    arg3 = (PLFLT)SWIG_As_double(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    plhls(arg1,arg2,arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plhlsrgb "Transform from HLS to RGB form of colours" 
static PyObject *_wrap_plhlsrgb(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT arg1 ;
    PLFLT arg2 ;
    PLFLT arg3 ;
    PLFLT *arg4 = (PLFLT *) 0 ;
    PLFLT *arg5 = (PLFLT *) 0 ;
    PLFLT *arg6 = (PLFLT *) 0 ;
    PLFLT temp4 ;
    int res4 = 0 ;
    PLFLT temp5 ;
    int res5 = 0 ;
    PLFLT temp6 ;
    int res6 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    arg4 = &temp4; res4 = SWIG_NEWOBJ;
    arg5 = &temp5; res5 = SWIG_NEWOBJ;
    arg6 = &temp6; res6 = SWIG_NEWOBJ;
    if(!PyArg_ParseTuple(args,(char *)"OOO:plhlsrgb",&obj0,&obj1,&obj2)) goto fail;
    arg1 = (PLFLT)SWIG_As_double(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLFLT)SWIG_As_double(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    arg3 = (PLFLT)SWIG_As_double(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    plhlsrgb(arg1,arg2,arg3,arg4,arg5,arg6);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    resultobj = t_output_helper(resultobj, ((res4 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg4)) : SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_PLFLT, 0)));
    resultobj = t_output_helper(resultobj, ((res5 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg5)) : SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_PLFLT, 0)));
    resultobj = t_output_helper(resultobj, ((res6 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg6)) : SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_PLFLT, 0)));
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plinit "Initialize PLplot, using preset or default options." 
static PyObject *_wrap_plinit(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    
    if(!PyArg_ParseTuple(args,(char *)":plinit")) goto fail;
    plinit();
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_pljoin "Draw a line segment from (x1, y1) to (x2, y2)." 
static PyObject *_wrap_pljoin(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT arg1 ;
    PLFLT arg2 ;
    PLFLT arg3 ;
    PLFLT arg4 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOO:pljoin",&obj0,&obj1,&obj2,&obj3)) goto fail;
    arg1 = (PLFLT)SWIG_As_double(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLFLT)SWIG_As_double(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    arg3 = (PLFLT)SWIG_As_double(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    arg4 = (PLFLT)SWIG_As_double(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    pljoin(arg1,arg2,arg3,arg4);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_pllab "Label graphs." 
static PyObject *_wrap_pllab(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    char *arg2 ;
    char *arg3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:pllab",&obj0,&obj1,&obj2)) goto fail;
    if (!SWIG_AsCharPtr(obj0, (char**)&arg1)) SWIG_fail;
    if (!SWIG_AsCharPtr(obj1, (char**)&arg2)) SWIG_fail;
    if (!SWIG_AsCharPtr(obj2, (char**)&arg3)) SWIG_fail;
    pllab((char const *)arg1,(char const *)arg2,(char const *)arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_pllightsource "Set position of the light source." 
static PyObject *_wrap_pllightsource(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT arg1 ;
    PLFLT arg2 ;
    PLFLT arg3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:pllightsource",&obj0,&obj1,&obj2)) goto fail;
    arg1 = (PLFLT)SWIG_As_double(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLFLT)SWIG_As_double(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    arg3 = (PLFLT)SWIG_As_double(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    pllightsource(arg1,arg2,arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plline "Draw line segments connecting a series of points." 
static PyObject *_wrap_plline(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PLFLT *arg2 = (PLFLT *) 0 ;
    PLFLT *arg3 = (PLFLT *) 0 ;
    PyArrayObject *tmp1 ;
    PyArrayObject *tmp2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:plline",&obj0,&obj1)) goto fail;
    {
        tmp1 = (PyArrayObject *)myArray_ContiguousFromObject(obj0, PyArray_PLFLT, 1, 1);
        if(tmp1 == NULL) return NULL;
        arg1 = Alen = tmp1->dimensions[0];
        arg2 = (PLFLT*)tmp1->data;
    }
    {
        tmp2 = (PyArrayObject *)myArray_ContiguousFromObject(obj1, PyArray_PLFLT, 1, 1);
        if(tmp2 == NULL) return NULL;
        if(tmp2->dimensions[0] != Alen) {
            PyErr_SetString(PyExc_ValueError, "Vectors must be same length.");
            return NULL;
        }
        arg3 = (PLFLT*)tmp2->data;
    }
    plline(arg1,arg2,arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    return resultobj;
    fail:
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    return NULL;
}


#define _doc_plline3 "Draw a line in 3 space." 
static PyObject *_wrap_plline3(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PLFLT *arg2 = (PLFLT *) 0 ;
    PLFLT *arg3 = (PLFLT *) 0 ;
    PLFLT *arg4 = (PLFLT *) 0 ;
    PyArrayObject *tmp1 ;
    PyArrayObject *tmp2 ;
    PyArrayObject *tmp3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:plline3",&obj0,&obj1,&obj2)) goto fail;
    {
        tmp1 = (PyArrayObject *)myArray_ContiguousFromObject(obj0, PyArray_PLFLT, 1, 1);
        if(tmp1 == NULL) return NULL;
        arg1 = Alen = tmp1->dimensions[0];
        arg2 = (PLFLT*)tmp1->data;
    }
    {
        tmp2 = (PyArrayObject *)myArray_ContiguousFromObject(obj1, PyArray_PLFLT, 1, 1);
        if(tmp2 == NULL) return NULL;
        if(tmp2->dimensions[0] != Alen) {
            PyErr_SetString(PyExc_ValueError, "Vectors must be same length.");
            return NULL;
        }
        arg3 = (PLFLT*)tmp2->data;
    }
    {
        tmp3 = (PyArrayObject *)myArray_ContiguousFromObject(obj2, PyArray_PLFLT, 1, 1);
        if(tmp3 == NULL) return NULL;
        if(tmp3->dimensions[0] != Alen) {
            PyErr_SetString(PyExc_ValueError, "Vectors must be same length.");
            return NULL;
        }
        arg4 = (PLFLT*)tmp3->data;
    }
    plline3(arg1,arg2,arg3,arg4);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3);
    }
    return resultobj;
    fail:
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3);
    }
    return NULL;
}


#define _doc_pllsty "Set line style." 
static PyObject *_wrap_pllsty(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:pllsty",&obj0)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    pllsty(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plmesh "Plot a 3-d mesh representation of z[x][y]." 
static PyObject *_wrap_plmesh(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT *arg1 = (PLFLT *) 0 ;
    PLFLT *arg2 = (PLFLT *) 0 ;
    PLFLT **arg3 = (PLFLT **) 0 ;
    PLINT arg4 ;
    PLINT arg5 ;
    PLINT arg6 ;
    PyArrayObject *tmp1 ;
    PyArrayObject *tmp2 ;
    PyArrayObject *tmp3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOO:plmesh",&obj0,&obj1,&obj2,&obj3)) goto fail;
    {
        tmp1 = (PyArrayObject *)myArray_ContiguousFromObject(obj0, PyArray_PLFLT, 1, 1);
        if(tmp1 == NULL) return NULL;
        Xlen = tmp1->dimensions[0];
        arg1 = (PLFLT*)tmp1->data;
    }
    {
        tmp2 = (PyArrayObject *)myArray_ContiguousFromObject(obj1, PyArray_PLFLT, 1, 1);
        if(tmp2 == NULL) return NULL;
        Ylen = tmp2->dimensions[0];
        arg2 = (PLFLT*)tmp2->data;
    }
    {
        int i, size;
        tmp3 = (PyArrayObject *)myArray_ContiguousFromObject(obj2, PyArray_PLFLT, 2, 2);
        if(tmp3 == NULL) return NULL;
        if(Xlen != tmp3->dimensions[0] || Ylen != tmp3->dimensions[1]) {
            PyErr_SetString(PyExc_ValueError, "Vectors must match matrix.");
            return NULL;
        }
        arg4 = tmp3->dimensions[0];
        arg5 = tmp3->dimensions[1];
        size = sizeof(PLFLT)*arg5;
        arg3 = (PLFLT**)malloc(sizeof(PLFLT*)*arg4);
        for(i=0; i<arg4; i++)
        arg3[i] = (PLFLT*)(tmp3->data + i*size);
    }
    arg6 = (PLINT)SWIG_As_long(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    plmesh(arg1,arg2,arg3,arg4,arg5,arg6);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3);
        free(arg3);
    }
    return resultobj;
    fail:
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3);
        free(arg3);
    }
    return NULL;
}


#define _doc_plmeshc "Plot a 3-d contoured mesh representation of the function z[x][y]." 
static PyObject *_wrap_plmeshc(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT *arg1 = (PLFLT *) 0 ;
    PLFLT *arg2 = (PLFLT *) 0 ;
    PLFLT **arg3 = (PLFLT **) 0 ;
    PLINT arg4 ;
    PLINT arg5 ;
    PLINT arg6 ;
    PLFLT *arg7 = (PLFLT *) 0 ;
    PLINT arg8 ;
    PyArrayObject *tmp1 ;
    PyArrayObject *tmp2 ;
    PyArrayObject *tmp3 ;
    PyArrayObject *tmp5 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOOO:plmeshc",&obj0,&obj1,&obj2,&obj3,&obj4)) goto fail;
    {
        tmp1 = (PyArrayObject *)myArray_ContiguousFromObject(obj0, PyArray_PLFLT, 1, 1);
        if(tmp1 == NULL) return NULL;
        Xlen = tmp1->dimensions[0];
        arg1 = (PLFLT*)tmp1->data;
    }
    {
        tmp2 = (PyArrayObject *)myArray_ContiguousFromObject(obj1, PyArray_PLFLT, 1, 1);
        if(tmp2 == NULL) return NULL;
        Ylen = tmp2->dimensions[0];
        arg2 = (PLFLT*)tmp2->data;
    }
    {
        int i, size;
        tmp3 = (PyArrayObject *)myArray_ContiguousFromObject(obj2, PyArray_PLFLT, 2, 2);
        if(tmp3 == NULL) return NULL;
        if(Xlen != tmp3->dimensions[0] || Ylen != tmp3->dimensions[1]) {
            PyErr_SetString(PyExc_ValueError, "Vectors must match matrix.");
            return NULL;
        }
        arg4 = tmp3->dimensions[0];
        arg5 = tmp3->dimensions[1];
        size = sizeof(PLFLT)*arg5;
        arg3 = (PLFLT**)malloc(sizeof(PLFLT*)*arg4);
        for(i=0; i<arg4; i++)
        arg3[i] = (PLFLT*)(tmp3->data + i*size);
    }
    arg6 = (PLINT)SWIG_As_long(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    {
        tmp5 = (PyArrayObject *)myArray_ContiguousFromObject(obj4, PyArray_PLFLT, 1, 1);
        if(tmp5 == NULL) return NULL;
        arg8 = tmp5->dimensions[0];
        arg7 = (PLFLT*)tmp5->data;
    }
    plmeshc(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3);
        free(arg3);
    }
    {
        Py_DECREF(tmp5); 
    }
    return resultobj;
    fail:
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3);
        free(arg3);
    }
    {
        Py_DECREF(tmp5); 
    }
    return NULL;
}


#define _doc_plmkstrm "Create a new stream and makes it the default." 
static PyObject *_wrap_plmkstrm(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT *arg1 = (PLINT *) 0 ;
    PLINT temp1 ;
    int res1 = 0 ;
    
    arg1 = &temp1; res1 = SWIG_NEWOBJ;
    if(!PyArg_ParseTuple(args,(char *)":plmkstrm")) goto fail;
    plmkstrm(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    resultobj = t_output_helper(resultobj, ((res1 == SWIG_NEWOBJ) ?
    SWIG_From_long((*arg1)) : SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_PLINT, 0)));
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plmtex "Print \"text\" at specified position relative to viewport." 
static PyObject *_wrap_plmtex(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    PLFLT arg2 ;
    PLFLT arg3 ;
    PLFLT arg4 ;
    char *arg5 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOOO:plmtex",&obj0,&obj1,&obj2,&obj3,&obj4)) goto fail;
    if (!SWIG_AsCharPtr(obj0, (char**)&arg1)) SWIG_fail;
    arg2 = (PLFLT)SWIG_As_double(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    arg3 = (PLFLT)SWIG_As_double(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    arg4 = (PLFLT)SWIG_As_double(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    if (!SWIG_AsCharPtr(obj4, (char**)&arg5)) SWIG_fail;
    plmtex((char const *)arg1,arg2,arg3,arg4,(char const *)arg5);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plot3d "Plot a 3-d representation of the function z[x][y]." 
static PyObject *_wrap_plot3d(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT *arg1 = (PLFLT *) 0 ;
    PLFLT *arg2 = (PLFLT *) 0 ;
    PLFLT **arg3 = (PLFLT **) 0 ;
    PLINT arg4 ;
    PLINT arg5 ;
    PLINT arg6 ;
    PLINT arg7 ;
    PyArrayObject *tmp1 ;
    PyArrayObject *tmp2 ;
    PyArrayObject *tmp3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOOO:plot3d",&obj0,&obj1,&obj2,&obj3,&obj4)) goto fail;
    {
        tmp1 = (PyArrayObject *)myArray_ContiguousFromObject(obj0, PyArray_PLFLT, 1, 1);
        if(tmp1 == NULL) return NULL;
        Xlen = tmp1->dimensions[0];
        arg1 = (PLFLT*)tmp1->data;
    }
    {
        tmp2 = (PyArrayObject *)myArray_ContiguousFromObject(obj1, PyArray_PLFLT, 1, 1);
        if(tmp2 == NULL) return NULL;
        Ylen = tmp2->dimensions[0];
        arg2 = (PLFLT*)tmp2->data;
    }
    {
        int i, size;
        tmp3 = (PyArrayObject *)myArray_ContiguousFromObject(obj2, PyArray_PLFLT, 2, 2);
        if(tmp3 == NULL) return NULL;
        if(Xlen != tmp3->dimensions[0] || Ylen != tmp3->dimensions[1]) {
            PyErr_SetString(PyExc_ValueError, "Vectors must match matrix.");
            return NULL;
        }
        arg4 = tmp3->dimensions[0];
        arg5 = tmp3->dimensions[1];
        size = sizeof(PLFLT)*arg5;
        arg3 = (PLFLT**)malloc(sizeof(PLFLT*)*arg4);
        for(i=0; i<arg4; i++)
        arg3[i] = (PLFLT*)(tmp3->data + i*size);
    }
    arg6 = (PLINT)SWIG_As_long(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    arg7 = (PLINT)SWIG_As_long(obj4); 
    if (PyErr_Occurred()) SWIG_fail;
    plot3d(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3);
        free(arg3);
    }
    return resultobj;
    fail:
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3);
        free(arg3);
    }
    return NULL;
}


#define _doc_plot3dc "Plot a 3-d contoured representation of the function z[x][y]." 
static PyObject *_wrap_plot3dc(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT *arg1 = (PLFLT *) 0 ;
    PLFLT *arg2 = (PLFLT *) 0 ;
    PLFLT **arg3 = (PLFLT **) 0 ;
    PLINT arg4 ;
    PLINT arg5 ;
    PLINT arg6 ;
    PLFLT *arg7 = (PLFLT *) 0 ;
    PLINT arg8 ;
    PyArrayObject *tmp1 ;
    PyArrayObject *tmp2 ;
    PyArrayObject *tmp3 ;
    PyArrayObject *tmp5 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOOO:plot3dc",&obj0,&obj1,&obj2,&obj3,&obj4)) goto fail;
    {
        tmp1 = (PyArrayObject *)myArray_ContiguousFromObject(obj0, PyArray_PLFLT, 1, 1);
        if(tmp1 == NULL) return NULL;
        Xlen = tmp1->dimensions[0];
        arg1 = (PLFLT*)tmp1->data;
    }
    {
        tmp2 = (PyArrayObject *)myArray_ContiguousFromObject(obj1, PyArray_PLFLT, 1, 1);
        if(tmp2 == NULL) return NULL;
        Ylen = tmp2->dimensions[0];
        arg2 = (PLFLT*)tmp2->data;
    }
    {
        int i, size;
        tmp3 = (PyArrayObject *)myArray_ContiguousFromObject(obj2, PyArray_PLFLT, 2, 2);
        if(tmp3 == NULL) return NULL;
        if(Xlen != tmp3->dimensions[0] || Ylen != tmp3->dimensions[1]) {
            PyErr_SetString(PyExc_ValueError, "Vectors must match matrix.");
            return NULL;
        }
        arg4 = tmp3->dimensions[0];
        arg5 = tmp3->dimensions[1];
        size = sizeof(PLFLT)*arg5;
        arg3 = (PLFLT**)malloc(sizeof(PLFLT*)*arg4);
        for(i=0; i<arg4; i++)
        arg3[i] = (PLFLT*)(tmp3->data + i*size);
    }
    arg6 = (PLINT)SWIG_As_long(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    {
        tmp5 = (PyArrayObject *)myArray_ContiguousFromObject(obj4, PyArray_PLFLT, 1, 1);
        if(tmp5 == NULL) return NULL;
        arg8 = tmp5->dimensions[0];
        arg7 = (PLFLT*)tmp5->data;
    }
    plot3dc(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3);
        free(arg3);
    }
    {
        Py_DECREF(tmp5); 
    }
    return resultobj;
    fail:
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3);
        free(arg3);
    }
    {
        Py_DECREF(tmp5); 
    }
    return NULL;
}


#define _doc_plot3dcl "Plot a 3-d contoured representation of the function z[x][y] with limits on the y index." 
static PyObject *_wrap_plot3dcl(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT *arg1 = (PLFLT *) 0 ;
    PLFLT *arg2 = (PLFLT *) 0 ;
    PLFLT **arg3 = (PLFLT **) 0 ;
    PLINT arg4 ;
    PLINT arg5 ;
    PLINT arg6 ;
    PLFLT *arg7 = (PLFLT *) 0 ;
    PLINT arg8 ;
    PLINT arg9 ;
    PLINT arg10 ;
    PLINT *arg11 = (PLINT *) 0 ;
    PLINT *arg12 = (PLINT *) 0 ;
    PyArrayObject *tmp1 ;
    PyArrayObject *tmp2 ;
    PyArrayObject *tmp3 ;
    PyArrayObject *tmp5 ;
    PyArrayObject *tmp7 ;
    PyArrayObject *tmp8 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj5 = 0 ;
    PyObject * obj6 = 0 ;
    PyObject * obj7 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOOOOOO:plot3dcl",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) goto fail;
    {
        tmp1 = (PyArrayObject *)myArray_ContiguousFromObject(obj0, PyArray_PLFLT, 1, 1);
        if(tmp1 == NULL) return NULL;
        Xlen = tmp1->dimensions[0];
        arg1 = (PLFLT*)tmp1->data;
    }
    {
        tmp2 = (PyArrayObject *)myArray_ContiguousFromObject(obj1, PyArray_PLFLT, 1, 1);
        if(tmp2 == NULL) return NULL;
        Ylen = tmp2->dimensions[0];
        arg2 = (PLFLT*)tmp2->data;
    }
    {
        int i, size;
        tmp3 = (PyArrayObject *)myArray_ContiguousFromObject(obj2, PyArray_PLFLT, 2, 2);
        if(tmp3 == NULL) return NULL;
        if(Xlen != tmp3->dimensions[0] || Ylen != tmp3->dimensions[1]) {
            PyErr_SetString(PyExc_ValueError, "Vectors must match matrix.");
            return NULL;
        }
        arg4 = tmp3->dimensions[0];
        arg5 = tmp3->dimensions[1];
        size = sizeof(PLFLT)*arg5;
        arg3 = (PLFLT**)malloc(sizeof(PLFLT*)*arg4);
        for(i=0; i<arg4; i++)
        arg3[i] = (PLFLT*)(tmp3->data + i*size);
    }
    arg6 = (PLINT)SWIG_As_long(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    {
        tmp5 = (PyArrayObject *)myArray_ContiguousFromObject(obj4, PyArray_PLFLT, 1, 1);
        if(tmp5 == NULL) return NULL;
        arg8 = tmp5->dimensions[0];
        arg7 = (PLFLT*)tmp5->data;
    }
    arg9 = (PLINT)SWIG_As_long(obj5); 
    if (PyErr_Occurred()) SWIG_fail;
    {
        tmp7 = (PyArrayObject *)PyArray_ContiguousFromObject(obj6, PyArray_PLINT, 1, 1);
        if(tmp7 == NULL) return NULL;
        arg10 = Alen = tmp7->dimensions[0];
        arg11 = (PLINT*)tmp7->data;
    }
    {
        tmp8 = (PyArrayObject *)PyArray_ContiguousFromObject(obj7, PyArray_PLINT, 1, 1);
        if(tmp8 == NULL) return NULL;
        if(tmp8->dimensions[0] != Alen) {
            PyErr_SetString(PyExc_ValueError, "Vectors must be same length.");
            return NULL;
        }
        arg12 = (PLINT*)tmp8->data;
    }
    plot3dcl(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3);
        free(arg3);
    }
    {
        Py_DECREF(tmp5); 
    }
    {
        Py_DECREF(tmp7);
    }
    {
        Py_DECREF(tmp8);
    }
    return resultobj;
    fail:
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3);
        free(arg3);
    }
    {
        Py_DECREF(tmp5); 
    }
    {
        Py_DECREF(tmp7);
    }
    {
        Py_DECREF(tmp8);
    }
    return NULL;
}


#define _doc_plsurf3d "Plot a 3-d contoured surface representation of the function z[x][y]." 
static PyObject *_wrap_plsurf3d(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT *arg1 = (PLFLT *) 0 ;
    PLFLT *arg2 = (PLFLT *) 0 ;
    PLFLT **arg3 = (PLFLT **) 0 ;
    PLINT arg4 ;
    PLINT arg5 ;
    PLINT arg6 ;
    PLFLT *arg7 = (PLFLT *) 0 ;
    PLINT arg8 ;
    PyArrayObject *tmp1 ;
    PyArrayObject *tmp2 ;
    PyArrayObject *tmp3 ;
    PyArrayObject *tmp5 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOOO:plsurf3d",&obj0,&obj1,&obj2,&obj3,&obj4)) goto fail;
    {
        tmp1 = (PyArrayObject *)myArray_ContiguousFromObject(obj0, PyArray_PLFLT, 1, 1);
        if(tmp1 == NULL) return NULL;
        Xlen = tmp1->dimensions[0];
        arg1 = (PLFLT*)tmp1->data;
    }
    {
        tmp2 = (PyArrayObject *)myArray_ContiguousFromObject(obj1, PyArray_PLFLT, 1, 1);
        if(tmp2 == NULL) return NULL;
        Ylen = tmp2->dimensions[0];
        arg2 = (PLFLT*)tmp2->data;
    }
    {
        int i, size;
        tmp3 = (PyArrayObject *)myArray_ContiguousFromObject(obj2, PyArray_PLFLT, 2, 2);
        if(tmp3 == NULL) return NULL;
        if(Xlen != tmp3->dimensions[0] || Ylen != tmp3->dimensions[1]) {
            PyErr_SetString(PyExc_ValueError, "Vectors must match matrix.");
            return NULL;
        }
        arg4 = tmp3->dimensions[0];
        arg5 = tmp3->dimensions[1];
        size = sizeof(PLFLT)*arg5;
        arg3 = (PLFLT**)malloc(sizeof(PLFLT*)*arg4);
        for(i=0; i<arg4; i++)
        arg3[i] = (PLFLT*)(tmp3->data + i*size);
    }
    arg6 = (PLINT)SWIG_As_long(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    {
        tmp5 = (PyArrayObject *)myArray_ContiguousFromObject(obj4, PyArray_PLFLT, 1, 1);
        if(tmp5 == NULL) return NULL;
        arg8 = tmp5->dimensions[0];
        arg7 = (PLFLT*)tmp5->data;
    }
    plsurf3d(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3);
        free(arg3);
    }
    {
        Py_DECREF(tmp5); 
    }
    return resultobj;
    fail:
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3);
        free(arg3);
    }
    {
        Py_DECREF(tmp5); 
    }
    return NULL;
}


#define _doc_plsurf3dl "Plot a 3-d contoured surface representation of the function z[x][y] with limits on the y index." 
static PyObject *_wrap_plsurf3dl(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT *arg1 = (PLFLT *) 0 ;
    PLFLT *arg2 = (PLFLT *) 0 ;
    PLFLT **arg3 = (PLFLT **) 0 ;
    PLINT arg4 ;
    PLINT arg5 ;
    PLINT arg6 ;
    PLFLT *arg7 = (PLFLT *) 0 ;
    PLINT arg8 ;
    PLINT arg9 ;
    PLINT arg10 ;
    PLINT *arg11 = (PLINT *) 0 ;
    PLINT *arg12 = (PLINT *) 0 ;
    PyArrayObject *tmp1 ;
    PyArrayObject *tmp2 ;
    PyArrayObject *tmp3 ;
    PyArrayObject *tmp5 ;
    PyArrayObject *tmp7 ;
    PyArrayObject *tmp8 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj5 = 0 ;
    PyObject * obj6 = 0 ;
    PyObject * obj7 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOOOOOO:plsurf3dl",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) goto fail;
    {
        tmp1 = (PyArrayObject *)myArray_ContiguousFromObject(obj0, PyArray_PLFLT, 1, 1);
        if(tmp1 == NULL) return NULL;
        Xlen = tmp1->dimensions[0];
        arg1 = (PLFLT*)tmp1->data;
    }
    {
        tmp2 = (PyArrayObject *)myArray_ContiguousFromObject(obj1, PyArray_PLFLT, 1, 1);
        if(tmp2 == NULL) return NULL;
        Ylen = tmp2->dimensions[0];
        arg2 = (PLFLT*)tmp2->data;
    }
    {
        int i, size;
        tmp3 = (PyArrayObject *)myArray_ContiguousFromObject(obj2, PyArray_PLFLT, 2, 2);
        if(tmp3 == NULL) return NULL;
        if(Xlen != tmp3->dimensions[0] || Ylen != tmp3->dimensions[1]) {
            PyErr_SetString(PyExc_ValueError, "Vectors must match matrix.");
            return NULL;
        }
        arg4 = tmp3->dimensions[0];
        arg5 = tmp3->dimensions[1];
        size = sizeof(PLFLT)*arg5;
        arg3 = (PLFLT**)malloc(sizeof(PLFLT*)*arg4);
        for(i=0; i<arg4; i++)
        arg3[i] = (PLFLT*)(tmp3->data + i*size);
    }
    arg6 = (PLINT)SWIG_As_long(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    {
        tmp5 = (PyArrayObject *)myArray_ContiguousFromObject(obj4, PyArray_PLFLT, 1, 1);
        if(tmp5 == NULL) return NULL;
        arg8 = tmp5->dimensions[0];
        arg7 = (PLFLT*)tmp5->data;
    }
    arg9 = (PLINT)SWIG_As_long(obj5); 
    if (PyErr_Occurred()) SWIG_fail;
    {
        tmp7 = (PyArrayObject *)PyArray_ContiguousFromObject(obj6, PyArray_PLINT, 1, 1);
        if(tmp7 == NULL) return NULL;
        arg10 = Alen = tmp7->dimensions[0];
        arg11 = (PLINT*)tmp7->data;
    }
    {
        tmp8 = (PyArrayObject *)PyArray_ContiguousFromObject(obj7, PyArray_PLINT, 1, 1);
        if(tmp8 == NULL) return NULL;
        if(tmp8->dimensions[0] != Alen) {
            PyErr_SetString(PyExc_ValueError, "Vectors must be same length.");
            return NULL;
        }
        arg12 = (PLINT*)tmp8->data;
    }
    plsurf3dl(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3);
        free(arg3);
    }
    {
        Py_DECREF(tmp5); 
    }
    {
        Py_DECREF(tmp7);
    }
    {
        Py_DECREF(tmp8);
    }
    return resultobj;
    fail:
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3);
        free(arg3);
    }
    {
        Py_DECREF(tmp5); 
    }
    {
        Py_DECREF(tmp7);
    }
    {
        Py_DECREF(tmp8);
    }
    return NULL;
}


#define _doc_plparseopts "Process options list using current options info." 
static PyObject *_wrap_plparseopts(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int *arg1 = (int *) 0 ;
    char **arg2 = (char **) 0 ;
    PLINT arg3 ;
    PLINT result;
    int tmp1 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:plparseopts",&obj0,&obj1)) goto fail;
    {
        int i;
        if (!PyList_Check(obj0)) {
            PyErr_SetString(PyExc_ValueError, "Expecting a list");
            return NULL;
        }
        tmp1 = PyList_Size(obj0);
        arg1 = &tmp1;
        arg2 = (char **) malloc((tmp1+1)*sizeof(char *));
        for (i = 0; i < tmp1; i++) {
            PyObject *s = PyList_GetItem(obj0,i);
            if (!PyString_Check(s)) {
                free(arg2);
                PyErr_SetString(PyExc_ValueError, "List items must be strings");
                return NULL;
            }
            arg2[i] = PyString_AsString(s);
        }
        arg2[i] = 0;
    }
    arg3 = (PLINT)SWIG_As_long(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    result = (PLINT)plparseopts(arg1,arg2,arg3);
    
    resultobj = SWIG_From_long((long)result);
    {
        if (arg2) free(arg2);
    }
    return resultobj;
    fail:
    {
        if (arg2) free(arg2);
    }
    return NULL;
}


#define _doc_plpat "Set fill pattern directly." 
static PyObject *_wrap_plpat(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PLINT *arg2 = (PLINT *) 0 ;
    PLINT *arg3 = (PLINT *) 0 ;
    PyArrayObject *tmp1 ;
    PyArrayObject *tmp2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:plpat",&obj0,&obj1)) goto fail;
    {
        tmp1 = (PyArrayObject *)PyArray_ContiguousFromObject(obj0, PyArray_PLINT, 1, 1);
        if(tmp1 == NULL) return NULL;
        arg1 = Alen = tmp1->dimensions[0];
        arg2 = (PLINT*)tmp1->data;
    }
    {
        tmp2 = (PyArrayObject *)PyArray_ContiguousFromObject(obj1, PyArray_PLINT, 1, 1);
        if(tmp2 == NULL) return NULL;
        if(tmp2->dimensions[0] != Alen) {
            PyErr_SetString(PyExc_ValueError, "Vectors must be same length.");
            return NULL;
        }
        arg3 = (PLINT*)tmp2->data;
    }
    plpat(arg1,arg2,arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    return resultobj;
    fail:
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    return NULL;
}


#define _doc_plpoin "Plot array y against x for n points using ASCII code \"code\"." 
static PyObject *_wrap_plpoin(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PLFLT *arg2 = (PLFLT *) 0 ;
    PLFLT *arg3 = (PLFLT *) 0 ;
    PLINT arg4 ;
    PyArrayObject *tmp1 ;
    PyArrayObject *tmp2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:plpoin",&obj0,&obj1,&obj2)) goto fail;
    {
        tmp1 = (PyArrayObject *)myArray_ContiguousFromObject(obj0, PyArray_PLFLT, 1, 1);
        if(tmp1 == NULL) return NULL;
        arg1 = Alen = tmp1->dimensions[0];
        arg2 = (PLFLT*)tmp1->data;
    }
    {
        tmp2 = (PyArrayObject *)myArray_ContiguousFromObject(obj1, PyArray_PLFLT, 1, 1);
        if(tmp2 == NULL) return NULL;
        if(tmp2->dimensions[0] != Alen) {
            PyErr_SetString(PyExc_ValueError, "Vectors must be same length.");
            return NULL;
        }
        arg3 = (PLFLT*)tmp2->data;
    }
    arg4 = (PLINT)SWIG_As_long(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    plpoin(arg1,arg2,arg3,arg4);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    return resultobj;
    fail:
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    return NULL;
}


#define _doc_plpoin3 "Draw a series of points in 3 space." 
static PyObject *_wrap_plpoin3(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PLFLT *arg2 = (PLFLT *) 0 ;
    PLFLT *arg3 = (PLFLT *) 0 ;
    PLFLT *arg4 = (PLFLT *) 0 ;
    PLINT arg5 ;
    PyArrayObject *tmp1 ;
    PyArrayObject *tmp2 ;
    PyArrayObject *tmp3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOO:plpoin3",&obj0,&obj1,&obj2,&obj3)) goto fail;
    {
        tmp1 = (PyArrayObject *)myArray_ContiguousFromObject(obj0, PyArray_PLFLT, 1, 1);
        if(tmp1 == NULL) return NULL;
        arg1 = Alen = tmp1->dimensions[0];
        arg2 = (PLFLT*)tmp1->data;
    }
    {
        tmp2 = (PyArrayObject *)myArray_ContiguousFromObject(obj1, PyArray_PLFLT, 1, 1);
        if(tmp2 == NULL) return NULL;
        if(tmp2->dimensions[0] != Alen) {
            PyErr_SetString(PyExc_ValueError, "Vectors must be same length.");
            return NULL;
        }
        arg3 = (PLFLT*)tmp2->data;
    }
    {
        tmp3 = (PyArrayObject *)myArray_ContiguousFromObject(obj2, PyArray_PLFLT, 1, 1);
        if(tmp3 == NULL) return NULL;
        if(tmp3->dimensions[0] != Alen) {
            PyErr_SetString(PyExc_ValueError, "Vectors must be same length.");
            return NULL;
        }
        arg4 = (PLFLT*)tmp3->data;
    }
    arg5 = (PLINT)SWIG_As_long(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    plpoin3(arg1,arg2,arg3,arg4,arg5);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3);
    }
    return resultobj;
    fail:
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3);
    }
    return NULL;
}


#define _doc_plpoly3 "Draw a polygon in 3 space. " 
static PyObject *_wrap_plpoly3(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PLFLT *arg2 = (PLFLT *) 0 ;
    PLFLT *arg3 = (PLFLT *) 0 ;
    PLFLT *arg4 = (PLFLT *) 0 ;
    PLINT *arg5 = (PLINT *) 0 ;
    PLINT arg6 ;
    PyArrayObject *tmp1 ;
    PyArrayObject *tmp2 ;
    PyArrayObject *tmp3 ;
    PyArrayObject *tmp4 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOOO:plpoly3",&obj0,&obj1,&obj2,&obj3,&obj4)) goto fail;
    {
        tmp1 = (PyArrayObject *)myArray_ContiguousFromObject(obj0, PyArray_PLFLT, 1, 1);
        if(tmp1 == NULL) return NULL;
        arg1 = Alen = tmp1->dimensions[0];
        arg2 = (PLFLT*)tmp1->data;
    }
    {
        tmp2 = (PyArrayObject *)myArray_ContiguousFromObject(obj1, PyArray_PLFLT, 1, 1);
        if(tmp2 == NULL) return NULL;
        if(tmp2->dimensions[0] != Alen) {
            PyErr_SetString(PyExc_ValueError, "Vectors must be same length.");
            return NULL;
        }
        arg3 = (PLFLT*)tmp2->data;
    }
    {
        tmp3 = (PyArrayObject *)myArray_ContiguousFromObject(obj2, PyArray_PLFLT, 1, 1);
        if(tmp3 == NULL) return NULL;
        if(tmp3->dimensions[0] != Alen) {
            PyErr_SetString(PyExc_ValueError, "Vectors must be same length.");
            return NULL;
        }
        arg4 = (PLFLT*)tmp3->data;
    }
    {
        tmp4 = (PyArrayObject *)PyArray_ContiguousFromObject(obj3, PyArray_PLINT, 1, 1);
        if(tmp4 == NULL) return NULL;
        if(tmp4->dimensions[0] < Alen-1) {
            PyErr_SetString(PyExc_ValueError, "Vector must be at least length of others minus 1.");
            return NULL;
        }
        arg5 = (PLINT*)tmp4->data;
    }
    arg6 = (PLINT)SWIG_As_long(obj4); 
    if (PyErr_Occurred()) SWIG_fail;
    plpoly3(arg1,arg2,arg3,arg4,arg5,arg6);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3);
    }
    {
        Py_DECREF(tmp4);
    }
    return resultobj;
    fail:
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3);
    }
    {
        Py_DECREF(tmp4);
    }
    return NULL;
}


#define _doc_plprec "Set the floating point precision (in number of places) in numeric labels." 
static PyObject *_wrap_plprec(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PLINT arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:plprec",&obj0,&obj1)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLINT)SWIG_As_long(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    plprec(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plpsty "Set fill pattern, using one of the predefined patterns." 
static PyObject *_wrap_plpsty(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:plpsty",&obj0)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    plpsty(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plptex "Print \"text\" at world cooordinate (x,y)." 
static PyObject *_wrap_plptex(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT arg1 ;
    PLFLT arg2 ;
    PLFLT arg3 ;
    PLFLT arg4 ;
    PLFLT arg5 ;
    char *arg6 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj5 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOOOO:plptex",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) goto fail;
    arg1 = (PLFLT)SWIG_As_double(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLFLT)SWIG_As_double(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    arg3 = (PLFLT)SWIG_As_double(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    arg4 = (PLFLT)SWIG_As_double(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    arg5 = (PLFLT)SWIG_As_double(obj4); 
    if (PyErr_Occurred()) SWIG_fail;
    if (!SWIG_AsCharPtr(obj5, (char**)&arg6)) SWIG_fail;
    plptex(arg1,arg2,arg3,arg4,arg5,(char const *)arg6);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plreplot "Replay contents of plot buffer to current device/file." 
static PyObject *_wrap_plreplot(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    
    if(!PyArg_ParseTuple(args,(char *)":plreplot")) goto fail;
    plreplot();
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plrgbhls "Transform from RGB to HLS form of colours" 
static PyObject *_wrap_plrgbhls(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT arg1 ;
    PLFLT arg2 ;
    PLFLT arg3 ;
    PLFLT *arg4 = (PLFLT *) 0 ;
    PLFLT *arg5 = (PLFLT *) 0 ;
    PLFLT *arg6 = (PLFLT *) 0 ;
    PLFLT temp4 ;
    int res4 = 0 ;
    PLFLT temp5 ;
    int res5 = 0 ;
    PLFLT temp6 ;
    int res6 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    arg4 = &temp4; res4 = SWIG_NEWOBJ;
    arg5 = &temp5; res5 = SWIG_NEWOBJ;
    arg6 = &temp6; res6 = SWIG_NEWOBJ;
    if(!PyArg_ParseTuple(args,(char *)"OOO:plrgbhls",&obj0,&obj1,&obj2)) goto fail;
    arg1 = (PLFLT)SWIG_As_double(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLFLT)SWIG_As_double(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    arg3 = (PLFLT)SWIG_As_double(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    plrgbhls(arg1,arg2,arg3,arg4,arg5,arg6);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    resultobj = t_output_helper(resultobj, ((res4 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg4)) : SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_PLFLT, 0)));
    resultobj = t_output_helper(resultobj, ((res5 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg5)) : SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_PLFLT, 0)));
    resultobj = t_output_helper(resultobj, ((res6 == SWIG_NEWOBJ) ?
    SWIG_From_double((*arg6)) : SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_PLFLT, 0)));
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plschr "Set character height." 
static PyObject *_wrap_plschr(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT arg1 ;
    PLFLT arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:plschr",&obj0,&obj1)) goto fail;
    arg1 = (PLFLT)SWIG_As_double(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLFLT)SWIG_As_double(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    plschr(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plscmap0 "Set color map 0 colors by 8 bit RGB values." 
static PyObject *_wrap_plscmap0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT *arg1 = (PLINT *) 0 ;
    PLINT *arg2 = (PLINT *) 0 ;
    PLINT *arg3 = (PLINT *) 0 ;
    PLINT arg4 ;
    PyArrayObject *tmp1 ;
    PyArrayObject *tmp2 ;
    PyArrayObject *tmp3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:plscmap0",&obj0,&obj1,&obj2)) goto fail;
    {
        tmp1 = (PyArrayObject *)PyArray_ContiguousFromObject(obj0, PyArray_PLINT, 1, 1);
        if(tmp1 == NULL) return NULL;
        Alen = tmp1->dimensions[0];
        arg1 = (PLINT*)tmp1->data;
    }
    {
        tmp2 = (PyArrayObject *)PyArray_ContiguousFromObject(obj1, PyArray_PLINT, 1, 1);
        if(tmp2 == NULL) return NULL;
        if(tmp2->dimensions[0] != Alen) {
            PyErr_SetString(PyExc_ValueError, "Vectors must be same length.");
            return NULL;
        }
        arg2 = (PLINT*)tmp2->data;
    }
    {
        tmp3 = (PyArrayObject *)PyArray_ContiguousFromObject(obj2, PyArray_PLINT, 1, 1);
        if(tmp3 == NULL) return NULL;
        if(tmp3->dimensions[0] != Alen) {
            PyErr_SetString(PyExc_ValueError, "Vectors must be same length.");
            return NULL;
        }
        arg4 = tmp3->dimensions[0];
        arg3 = (PLINT*)tmp3->data;
    }
    plscmap0(arg1,arg2,arg3,arg4);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3); 
    }
    return resultobj;
    fail:
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3); 
    }
    return NULL;
}


#define _doc_plscmap0n "Set number of colors in cmap 0." 
static PyObject *_wrap_plscmap0n(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:plscmap0n",&obj0)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    plscmap0n(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plscmap1 "Set color map 1 colors by 8 bit RGB values." 
static PyObject *_wrap_plscmap1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT *arg1 = (PLINT *) 0 ;
    PLINT *arg2 = (PLINT *) 0 ;
    PLINT *arg3 = (PLINT *) 0 ;
    PLINT arg4 ;
    PyArrayObject *tmp1 ;
    PyArrayObject *tmp2 ;
    PyArrayObject *tmp3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:plscmap1",&obj0,&obj1,&obj2)) goto fail;
    {
        tmp1 = (PyArrayObject *)PyArray_ContiguousFromObject(obj0, PyArray_PLINT, 1, 1);
        if(tmp1 == NULL) return NULL;
        Alen = tmp1->dimensions[0];
        arg1 = (PLINT*)tmp1->data;
    }
    {
        tmp2 = (PyArrayObject *)PyArray_ContiguousFromObject(obj1, PyArray_PLINT, 1, 1);
        if(tmp2 == NULL) return NULL;
        if(tmp2->dimensions[0] != Alen) {
            PyErr_SetString(PyExc_ValueError, "Vectors must be same length.");
            return NULL;
        }
        arg2 = (PLINT*)tmp2->data;
    }
    {
        tmp3 = (PyArrayObject *)PyArray_ContiguousFromObject(obj2, PyArray_PLINT, 1, 1);
        if(tmp3 == NULL) return NULL;
        if(tmp3->dimensions[0] != Alen) {
            PyErr_SetString(PyExc_ValueError, "Vectors must be same length.");
            return NULL;
        }
        arg4 = tmp3->dimensions[0];
        arg3 = (PLINT*)tmp3->data;
    }
    plscmap1(arg1,arg2,arg3,arg4);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3); 
    }
    return resultobj;
    fail:
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3); 
    }
    return NULL;
}


#define _doc_plscmap1l "Set color map 1 colors using a piece-wise linear relationship between intensity [0,1] (cmap 1 index) and position in HLS or RGB color space." 
static PyObject *_wrap_plscmap1l(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PLINT arg2 ;
    PLFLT *arg3 = (PLFLT *) 0 ;
    PLFLT *arg4 = (PLFLT *) 0 ;
    PLFLT *arg5 = (PLFLT *) 0 ;
    PLFLT *arg6 = (PLFLT *) 0 ;
    PLINT *arg7 = (PLINT *) 0 ;
    PyArrayObject *tmp2 ;
    PyArrayObject *tmp3 ;
    PyArrayObject *tmp4 ;
    PyArrayObject *tmp5 ;
    PyArrayObject *tmp6 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj5 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOOOO:plscmap1l",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    {
        tmp2 = (PyArrayObject *)myArray_ContiguousFromObject(obj1, PyArray_PLFLT, 1, 1);
        if(tmp2 == NULL) return NULL;
        arg2 = Alen = tmp2->dimensions[0];
        arg3 = (PLFLT*)tmp2->data;
    }
    {
        tmp3 = (PyArrayObject *)myArray_ContiguousFromObject(obj2, PyArray_PLFLT, 1, 1);
        if(tmp3 == NULL) return NULL;
        if(tmp3->dimensions[0] != Alen) {
            PyErr_SetString(PyExc_ValueError, "Vectors must be same length.");
            return NULL;
        }
        arg4 = (PLFLT*)tmp3->data;
    }
    {
        tmp4 = (PyArrayObject *)myArray_ContiguousFromObject(obj3, PyArray_PLFLT, 1, 1);
        if(tmp4 == NULL) return NULL;
        if(tmp4->dimensions[0] != Alen) {
            PyErr_SetString(PyExc_ValueError, "Vectors must be same length.");
            return NULL;
        }
        arg5 = (PLFLT*)tmp4->data;
    }
    {
        tmp5 = (PyArrayObject *)myArray_ContiguousFromObject(obj4, PyArray_PLFLT, 1, 1);
        if(tmp5 == NULL) return NULL;
        if(tmp5->dimensions[0] != Alen) {
            PyErr_SetString(PyExc_ValueError, "Vectors must be same length.");
            return NULL;
        }
        arg6 = (PLFLT*)tmp5->data;
    }
    {
        tmp6 = (PyArrayObject *)PyArray_ContiguousFromObject(obj5, PyArray_PLINT, 1, 1);
        if(tmp6 == NULL) return NULL;
        if(tmp6->dimensions[0] < Alen-1) {
            PyErr_SetString(PyExc_ValueError, "Vector must be at least length of others minus 1.");
            return NULL;
        }
        arg7 = (PLINT*)tmp6->data;
    }
    plscmap1l(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3);
    }
    {
        Py_DECREF(tmp4);
    }
    {
        Py_DECREF(tmp5);
    }
    {
        Py_DECREF(tmp6);
    }
    return resultobj;
    fail:
    {
        Py_DECREF(tmp2);
    }
    {
        Py_DECREF(tmp3);
    }
    {
        Py_DECREF(tmp4);
    }
    {
        Py_DECREF(tmp5);
    }
    {
        Py_DECREF(tmp6);
    }
    return NULL;
}


#define _doc_plscmap1n "Set number of colors in cmap 1." 
static PyObject *_wrap_plscmap1n(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:plscmap1n",&obj0)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    plscmap1n(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plscol0 "Set 8-bit RGB value in cmap 0." 
static PyObject *_wrap_plscol0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PLINT arg2 ;
    PLINT arg3 ;
    PLINT arg4 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOO:plscol0",&obj0,&obj1,&obj2,&obj3)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLINT)SWIG_As_long(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    arg3 = (PLINT)SWIG_As_long(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    arg4 = (PLINT)SWIG_As_long(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    plscol0(arg1,arg2,arg3,arg4);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plscolbg "Set the background color using 8-bit RGB value." 
static PyObject *_wrap_plscolbg(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PLINT arg2 ;
    PLINT arg3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:plscolbg",&obj0,&obj1,&obj2)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLINT)SWIG_As_long(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    arg3 = (PLINT)SWIG_As_long(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    plscolbg(arg1,arg2,arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plscolor "Globally turn color output on/off." 
static PyObject *_wrap_plscolor(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:plscolor",&obj0)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    plscolor(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plscompression "Set the compression level." 
static PyObject *_wrap_plscompression(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:plscompression",&obj0)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    plscompression(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plsdev "Set the device (keyword) name." 
static PyObject *_wrap_plsdev(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:plsdev",&obj0)) goto fail;
    if (!SWIG_AsCharPtr(obj0, (char**)&arg1)) SWIG_fail;
    plsdev((char const *)arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plsdidev "Set window into device space using margin, aspect ratio, and justification." 
static PyObject *_wrap_plsdidev(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT arg1 ;
    PLFLT arg2 ;
    PLFLT arg3 ;
    PLFLT arg4 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOO:plsdidev",&obj0,&obj1,&obj2,&obj3)) goto fail;
    arg1 = (PLFLT)SWIG_As_double(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLFLT)SWIG_As_double(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    arg3 = (PLFLT)SWIG_As_double(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    arg4 = (PLFLT)SWIG_As_double(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    plsdidev(arg1,arg2,arg3,arg4);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plsdimap "Set up transformation from metafile coordinates." 
static PyObject *_wrap_plsdimap(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PLINT arg2 ;
    PLINT arg3 ;
    PLINT arg4 ;
    PLFLT arg5 ;
    PLFLT arg6 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj5 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOOOO:plsdimap",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLINT)SWIG_As_long(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    arg3 = (PLINT)SWIG_As_long(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    arg4 = (PLINT)SWIG_As_long(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    arg5 = (PLFLT)SWIG_As_double(obj4); 
    if (PyErr_Occurred()) SWIG_fail;
    arg6 = (PLFLT)SWIG_As_double(obj5); 
    if (PyErr_Occurred()) SWIG_fail;
    plsdimap(arg1,arg2,arg3,arg4,arg5,arg6);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plsdiori "Set plot orientation, specifying rotation in units of pi/2." 
static PyObject *_wrap_plsdiori(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT arg1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:plsdiori",&obj0)) goto fail;
    arg1 = (PLFLT)SWIG_As_double(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    plsdiori(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plsdiplt "Set window into plot space." 
static PyObject *_wrap_plsdiplt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT arg1 ;
    PLFLT arg2 ;
    PLFLT arg3 ;
    PLFLT arg4 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOO:plsdiplt",&obj0,&obj1,&obj2,&obj3)) goto fail;
    arg1 = (PLFLT)SWIG_As_double(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLFLT)SWIG_As_double(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    arg3 = (PLFLT)SWIG_As_double(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    arg4 = (PLFLT)SWIG_As_double(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    plsdiplt(arg1,arg2,arg3,arg4);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plsdiplz "Set window into plot space incrementally (zoom)." 
static PyObject *_wrap_plsdiplz(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT arg1 ;
    PLFLT arg2 ;
    PLFLT arg3 ;
    PLFLT arg4 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOO:plsdiplz",&obj0,&obj1,&obj2,&obj3)) goto fail;
    arg1 = (PLFLT)SWIG_As_double(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLFLT)SWIG_As_double(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    arg3 = (PLFLT)SWIG_As_double(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    arg4 = (PLFLT)SWIG_As_double(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    plsdiplz(arg1,arg2,arg3,arg4);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plsesc "Set the escape character for text strings." 
static PyObject *_wrap_plsesc(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char arg1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:plsesc",&obj0)) goto fail;
    arg1 = (char)SWIG_As_char(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    plsesc(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plsetopt "Process input strings, treating them as an option and argument pair. The first is for the external API, the second the work routine declared here for backward compatibilty." 
static PyObject *_wrap_plsetopt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    char *arg2 ;
    PLINT result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:plsetopt",&obj0,&obj1)) goto fail;
    if (!SWIG_AsCharPtr(obj0, (char**)&arg1)) SWIG_fail;
    if (!SWIG_AsCharPtr(obj1, (char**)&arg2)) SWIG_fail;
    result = (PLINT)plsetopt(arg1,arg2);
    
    resultobj = SWIG_From_long((long)result);
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plsfam "Set family file parameters." 
static PyObject *_wrap_plsfam(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PLINT arg2 ;
    PLINT arg3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:plsfam",&obj0,&obj1,&obj2)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLINT)SWIG_As_long(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    arg3 = (PLINT)SWIG_As_long(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    plsfam(arg1,arg2,arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plsfci "Set FCI (font characterization integer)." 
static PyObject *_wrap_plsfci(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLUNICODE arg1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:plsfci",&obj0)) goto fail;
    arg1 = (PLUNICODE)SWIG_As_unsigned_SS_int(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    plsfci(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plsfnam "Set the output file name." 
static PyObject *_wrap_plsfnam(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:plsfnam",&obj0)) goto fail;
    if (!SWIG_AsCharPtr(obj0, (char**)&arg1)) SWIG_fail;
    plsfnam((char const *)arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plshades "Shade regions with continuous range of colours." 
static PyObject *_wrap_plshades(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT **arg1 = (PLFLT **) 0 ;
    PLINT arg2 ;
    PLINT arg3 ;
    defined_func arg4 = (defined_func) 0 ;
    PLFLT arg5 ;
    PLFLT arg6 ;
    PLFLT arg7 ;
    PLFLT arg8 ;
    PLFLT *arg9 = (PLFLT *) 0 ;
    PLINT arg10 ;
    PLINT arg11 ;
    PLINT arg12 ;
    PLINT arg13 ;
    fill_func arg14 = (fill_func) 0 ;
    PLINT arg15 ;
    pltr_func arg16 = (pltr_func) 0 ;
    PLPointer arg17 = (PLPointer) 0 ;
    PyArrayObject *tmp1 ;
    PyArrayObject *tmp7 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj5 = 0 ;
    PyObject * obj6 = 0 ;
    PyObject * obj7 = 0 ;
    PyObject * obj8 = 0 ;
    PyObject * obj9 = 0 ;
    PyObject * obj10 = 0 ;
    PyObject * obj11 = 0 ;
    
    {
        python_pltr = 0;
        arg16 = NULL;
    }
    {
        arg17 = NULL;
    }
    {
        arg4 = NULL;
    }
    {
        arg14 = plfill;
    }
    if(!PyArg_ParseTuple(args,(char *)"OOOOOOOOOO|OO:plshades",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10,&obj11)) goto fail;
    {
        int i, size;
        tmp1 = (PyArrayObject *)myArray_ContiguousFromObject(obj0, PyArray_PLFLT, 2, 2);
        if(tmp1 == NULL) return NULL;
        Xlen = arg2 = tmp1->dimensions[0];
        Ylen = arg3 = tmp1->dimensions[1];
        size = sizeof(PLFLT)*arg3;
        arg1 = (PLFLT**)malloc(sizeof(PLFLT*)*arg2);
        for(i=0; i<arg2; i++)
        arg1[i] = (PLFLT*)(tmp1->data + i*size);
    }
    arg5 = (PLFLT)SWIG_As_double(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    arg6 = (PLFLT)SWIG_As_double(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    arg7 = (PLFLT)SWIG_As_double(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    arg8 = (PLFLT)SWIG_As_double(obj4); 
    if (PyErr_Occurred()) SWIG_fail;
    {
        tmp7 = (PyArrayObject *)myArray_ContiguousFromObject(obj5, PyArray_PLFLT, 1, 1);
        if(tmp7 == NULL) return NULL;
        arg10 = tmp7->dimensions[0];
        arg9 = (PLFLT*)tmp7->data;
    }
    arg11 = (PLINT)SWIG_As_long(obj6); 
    if (PyErr_Occurred()) SWIG_fail;
    arg12 = (PLINT)SWIG_As_long(obj7); 
    if (PyErr_Occurred()) SWIG_fail;
    arg13 = (PLINT)SWIG_As_long(obj8); 
    if (PyErr_Occurred()) SWIG_fail;
    arg15 = (PLINT)SWIG_As_long(obj9); 
    if (PyErr_Occurred()) SWIG_fail;
    if (obj10) {
        {
            /* it must be a callable */
            if(!PyCallable_Check((PyObject*)obj10)) {
                PyErr_SetString(PyExc_ValueError, "pltr argument must be callable");
                return NULL;
            }
            arg16 = marshal_pltr(obj10);
        }
    }
    if (obj11) {
        {
            if(obj11 == Py_None)
            arg17 = NULL;
            else {
                arg17 = marshal_PLPointer(obj11);
            }
        }
    }
    plshades(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15,arg16,arg17);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        Py_DECREF(tmp1);
        free(arg1);
    }
    {
        Py_DECREF(tmp7); 
    }
    {
        cleanup_pltr();
    }
    {
        cleanup_PLPointer();
    }
    return resultobj;
    fail:
    {
        Py_DECREF(tmp1);
        free(arg1);
    }
    {
        Py_DECREF(tmp7); 
    }
    {
        cleanup_pltr();
    }
    {
        cleanup_PLPointer();
    }
    return NULL;
}


#define _doc_plshade "Shade region with discrete colour, pattern fill." 
static PyObject *_wrap_plshade(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT **arg1 = (PLFLT **) 0 ;
    PLINT arg2 ;
    PLINT arg3 ;
    defined_func arg4 = (defined_func) 0 ;
    PLFLT arg5 ;
    PLFLT arg6 ;
    PLFLT arg7 ;
    PLFLT arg8 ;
    PLFLT arg9 ;
    PLFLT arg10 ;
    PLINT arg11 ;
    PLFLT arg12 ;
    PLINT arg13 ;
    PLINT arg14 ;
    PLINT arg15 ;
    PLINT arg16 ;
    PLINT arg17 ;
    fill_func arg18 = (fill_func) 0 ;
    PLINT arg19 ;
    pltr_func arg20 = (pltr_func) 0 ;
    PLPointer arg21 = (PLPointer) 0 ;
    PyArrayObject *tmp1 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj5 = 0 ;
    PyObject * obj6 = 0 ;
    PyObject * obj7 = 0 ;
    PyObject * obj8 = 0 ;
    PyObject * obj9 = 0 ;
    PyObject * obj10 = 0 ;
    PyObject * obj11 = 0 ;
    PyObject * obj12 = 0 ;
    PyObject * obj13 = 0 ;
    PyObject * obj14 = 0 ;
    PyObject * obj15 = 0 ;
    PyObject * obj16 = 0 ;
    
    {
        python_pltr = 0;
        arg20 = NULL;
    }
    {
        arg21 = NULL;
    }
    {
        arg4 = NULL;
    }
    {
        arg18 = plfill;
    }
    if(!PyArg_ParseTuple(args,(char *)"OOOOOOOOOOOOOOO|OO:plshade",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10,&obj11,&obj12,&obj13,&obj14,&obj15,&obj16)) goto fail;
    {
        int i, size;
        tmp1 = (PyArrayObject *)myArray_ContiguousFromObject(obj0, PyArray_PLFLT, 2, 2);
        if(tmp1 == NULL) return NULL;
        Xlen = arg2 = tmp1->dimensions[0];
        Ylen = arg3 = tmp1->dimensions[1];
        size = sizeof(PLFLT)*arg3;
        arg1 = (PLFLT**)malloc(sizeof(PLFLT*)*arg2);
        for(i=0; i<arg2; i++)
        arg1[i] = (PLFLT*)(tmp1->data + i*size);
    }
    arg5 = (PLFLT)SWIG_As_double(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    arg6 = (PLFLT)SWIG_As_double(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    arg7 = (PLFLT)SWIG_As_double(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    arg8 = (PLFLT)SWIG_As_double(obj4); 
    if (PyErr_Occurred()) SWIG_fail;
    arg9 = (PLFLT)SWIG_As_double(obj5); 
    if (PyErr_Occurred()) SWIG_fail;
    arg10 = (PLFLT)SWIG_As_double(obj6); 
    if (PyErr_Occurred()) SWIG_fail;
    arg11 = (PLINT)SWIG_As_long(obj7); 
    if (PyErr_Occurred()) SWIG_fail;
    arg12 = (PLFLT)SWIG_As_double(obj8); 
    if (PyErr_Occurred()) SWIG_fail;
    arg13 = (PLINT)SWIG_As_long(obj9); 
    if (PyErr_Occurred()) SWIG_fail;
    arg14 = (PLINT)SWIG_As_long(obj10); 
    if (PyErr_Occurred()) SWIG_fail;
    arg15 = (PLINT)SWIG_As_long(obj11); 
    if (PyErr_Occurred()) SWIG_fail;
    arg16 = (PLINT)SWIG_As_long(obj12); 
    if (PyErr_Occurred()) SWIG_fail;
    arg17 = (PLINT)SWIG_As_long(obj13); 
    if (PyErr_Occurred()) SWIG_fail;
    arg19 = (PLINT)SWIG_As_long(obj14); 
    if (PyErr_Occurred()) SWIG_fail;
    if (obj15) {
        {
            /* it must be a callable */
            if(!PyCallable_Check((PyObject*)obj15)) {
                PyErr_SetString(PyExc_ValueError, "pltr argument must be callable");
                return NULL;
            }
            arg20 = marshal_pltr(obj15);
        }
    }
    if (obj16) {
        {
            if(obj16 == Py_None)
            arg21 = NULL;
            else {
                arg21 = marshal_PLPointer(obj16);
            }
        }
    }
    plshade(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15,arg16,arg17,arg18,arg19,arg20,arg21);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        Py_DECREF(tmp1);
        free(arg1);
    }
    {
        cleanup_pltr();
    }
    {
        cleanup_PLPointer();
    }
    return resultobj;
    fail:
    {
        Py_DECREF(tmp1);
        free(arg1);
    }
    {
        cleanup_pltr();
    }
    {
        cleanup_PLPointer();
    }
    return NULL;
}


#define _doc_plsmaj "Set up lengths of major tick marks." 
static PyObject *_wrap_plsmaj(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT arg1 ;
    PLFLT arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:plsmaj",&obj0,&obj1)) goto fail;
    arg1 = (PLFLT)SWIG_As_double(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLFLT)SWIG_As_double(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    plsmaj(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plsmin "Set up lengths of minor tick marks." 
static PyObject *_wrap_plsmin(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT arg1 ;
    PLFLT arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:plsmin",&obj0,&obj1)) goto fail;
    arg1 = (PLFLT)SWIG_As_double(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLFLT)SWIG_As_double(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    plsmin(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plsori "Set orientation.  Must be done before calling plinit." 
static PyObject *_wrap_plsori(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:plsori",&obj0)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    plsori(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plspage "Set output device parameters.  Usually ignored by the driver." 
static PyObject *_wrap_plspage(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT arg1 ;
    PLFLT arg2 ;
    PLINT arg3 ;
    PLINT arg4 ;
    PLINT arg5 ;
    PLINT arg6 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj5 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOOOO:plspage",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) goto fail;
    arg1 = (PLFLT)SWIG_As_double(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLFLT)SWIG_As_double(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    arg3 = (PLINT)SWIG_As_long(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    arg4 = (PLINT)SWIG_As_long(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    arg5 = (PLINT)SWIG_As_long(obj4); 
    if (PyErr_Occurred()) SWIG_fail;
    arg6 = (PLINT)SWIG_As_long(obj5); 
    if (PyErr_Occurred()) SWIG_fail;
    plspage(arg1,arg2,arg3,arg4,arg5,arg6);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plspause "Set the pause (on end-of-page) status." 
static PyObject *_wrap_plspause(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:plspause",&obj0)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    plspause(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plsstrm "Set stream number." 
static PyObject *_wrap_plsstrm(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:plsstrm",&obj0)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    plsstrm(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plssub "Set the number of subwindows in x and y." 
static PyObject *_wrap_plssub(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PLINT arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:plssub",&obj0,&obj1)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLINT)SWIG_As_long(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    plssub(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plssym "Set symbol height." 
static PyObject *_wrap_plssym(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT arg1 ;
    PLFLT arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:plssym",&obj0,&obj1)) goto fail;
    arg1 = (PLFLT)SWIG_As_double(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLFLT)SWIG_As_double(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    plssym(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plstar "Initialize PLplot, passing in the windows/page settings." 
static PyObject *_wrap_plstar(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PLINT arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:plstar",&obj0,&obj1)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLINT)SWIG_As_long(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    plstar(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plstart "Initialize PLplot, passing the device name and windows/page settings." 
static PyObject *_wrap_plstart(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    PLINT arg2 ;
    PLINT arg3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:plstart",&obj0,&obj1,&obj2)) goto fail;
    if (!SWIG_AsCharPtr(obj0, (char**)&arg1)) SWIG_fail;
    arg2 = (PLINT)SWIG_As_long(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    arg3 = (PLINT)SWIG_As_long(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    plstart((char const *)arg1,arg2,arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plstripa "Add a point to a stripchart. " 
static PyObject *_wrap_plstripa(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PLINT arg2 ;
    PLFLT arg3 ;
    PLFLT arg4 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOO:plstripa",&obj0,&obj1,&obj2,&obj3)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLINT)SWIG_As_long(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    arg3 = (PLFLT)SWIG_As_double(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    arg4 = (PLFLT)SWIG_As_double(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    plstripa(arg1,arg2,arg3,arg4);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plstripc "Create 1d stripchart." 
static PyObject *_wrap_plstripc(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT *arg1 = (PLINT *) 0 ;
    char *arg2 ;
    char *arg3 ;
    PLFLT arg4 ;
    PLFLT arg5 ;
    PLFLT arg6 ;
    PLFLT arg7 ;
    PLFLT arg8 ;
    PLFLT arg9 ;
    PLFLT arg10 ;
    PLINT arg11 ;
    PLINT arg12 ;
    PLINT arg13 ;
    PLINT arg14 ;
    PLINT *arg15 = (PLINT *) 0 ;
    PLINT *arg16 = (PLINT *) 0 ;
    char **arg17 ;
    char *arg18 ;
    char *arg19 ;
    char *arg20 ;
    PLINT temp1 ;
    int res1 = 0 ;
    PyArrayObject *tmp15 ;
    PyArrayObject *tmp16 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj5 = 0 ;
    PyObject * obj6 = 0 ;
    PyObject * obj7 = 0 ;
    PyObject * obj8 = 0 ;
    PyObject * obj9 = 0 ;
    PyObject * obj10 = 0 ;
    PyObject * obj11 = 0 ;
    PyObject * obj12 = 0 ;
    PyObject * obj13 = 0 ;
    PyObject * obj14 = 0 ;
    PyObject * obj15 = 0 ;
    PyObject * obj16 = 0 ;
    PyObject * obj17 = 0 ;
    PyObject * obj18 = 0 ;
    
    arg1 = &temp1; res1 = SWIG_NEWOBJ;
    if(!PyArg_ParseTuple(args,(char *)"OOOOOOOOOOOOOOOOOOO:plstripc",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10,&obj11,&obj12,&obj13,&obj14,&obj15,&obj16,&obj17,&obj18)) goto fail;
    if (!SWIG_AsCharPtr(obj0, (char**)&arg2)) SWIG_fail;
    if (!SWIG_AsCharPtr(obj1, (char**)&arg3)) SWIG_fail;
    arg4 = (PLFLT)SWIG_As_double(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    arg5 = (PLFLT)SWIG_As_double(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    arg6 = (PLFLT)SWIG_As_double(obj4); 
    if (PyErr_Occurred()) SWIG_fail;
    arg7 = (PLFLT)SWIG_As_double(obj5); 
    if (PyErr_Occurred()) SWIG_fail;
    arg8 = (PLFLT)SWIG_As_double(obj6); 
    if (PyErr_Occurred()) SWIG_fail;
    arg9 = (PLFLT)SWIG_As_double(obj7); 
    if (PyErr_Occurred()) SWIG_fail;
    arg10 = (PLFLT)SWIG_As_double(obj8); 
    if (PyErr_Occurred()) SWIG_fail;
    arg11 = (PLINT)SWIG_As_long(obj9); 
    if (PyErr_Occurred()) SWIG_fail;
    arg12 = (PLINT)SWIG_As_long(obj10); 
    if (PyErr_Occurred()) SWIG_fail;
    arg13 = (PLINT)SWIG_As_long(obj11); 
    if (PyErr_Occurred()) SWIG_fail;
    arg14 = (PLINT)SWIG_As_long(obj12); 
    if (PyErr_Occurred()) SWIG_fail;
    {
        tmp15 = (PyArrayObject *)PyArray_ContiguousFromObject(obj13, PyArray_PLINT, 1, 1);
        if(tmp15 == NULL) return NULL;
        Alen = tmp15->dimensions[0];
        arg15 = (PLINT*)tmp15->data;
    }
    {
        tmp16 = (PyArrayObject *)PyArray_ContiguousFromObject(obj14, PyArray_PLINT, 1, 1);
        if(tmp16 == NULL) return NULL;
        if(tmp16->dimensions[0] != Alen) {
            PyErr_SetString(PyExc_ValueError, "Vectors must be same length.");
            return NULL;
        }
        arg16 = (PLINT*)tmp16->data;
    }
    {
        int i;
        if(!PySequence_Check(obj15) || PySequence_Size(obj15) != 4) {
            PyErr_SetString(PyExc_ValueError, "Requires a sequence of 4 strings.");
            return NULL;
        }
        if(Alen != 4) {
            PyErr_SetString(PyExc_ValueError, "colline and styline args must be length 4.");
            return NULL;
        }
        arg17 = malloc(sizeof(char*)*4);
        for(i=0; i<4; i++) {
            arg17[i] = PyString_AsString(PySequence_Fast_GET_ITEM(obj15, i));
            if(arg17[i] == NULL) {
                free(arg17);
                return NULL;
            }
        }
    }
    if (!SWIG_AsCharPtr(obj16, (char**)&arg18)) SWIG_fail;
    if (!SWIG_AsCharPtr(obj17, (char**)&arg19)) SWIG_fail;
    if (!SWIG_AsCharPtr(obj18, (char**)&arg20)) SWIG_fail;
    plstripc(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15,arg16,arg17,arg18,arg19,arg20);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    resultobj = t_output_helper(resultobj, ((res1 == SWIG_NEWOBJ) ?
    SWIG_From_long((*arg1)) : SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_PLINT, 0)));
    {
        Py_DECREF(tmp15);
    }
    {
        Py_DECREF(tmp16);
    }
    {
        free(arg17);
    }
    return resultobj;
    fail:
    {
        Py_DECREF(tmp15);
    }
    {
        Py_DECREF(tmp16);
    }
    {
        free(arg17);
    }
    return NULL;
}


#define _doc_plstripd "Deletes and releases memory used by a stripchart. " 
static PyObject *_wrap_plstripd(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:plstripd",&obj0)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    plstripd(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plstyl "Set up a new line style." 
static PyObject *_wrap_plstyl(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PLINT *arg2 = (PLINT *) 0 ;
    PLINT *arg3 = (PLINT *) 0 ;
    PyArrayObject *tmp1 ;
    PyArrayObject *tmp2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:plstyl",&obj0,&obj1)) goto fail;
    {
        tmp1 = (PyArrayObject *)PyArray_ContiguousFromObject(obj0, PyArray_PLINT, 1, 1);
        if(tmp1 == NULL) return NULL;
        arg1 = Alen = tmp1->dimensions[0];
        arg2 = (PLINT*)tmp1->data;
    }
    {
        tmp2 = (PyArrayObject *)PyArray_ContiguousFromObject(obj1, PyArray_PLINT, 1, 1);
        if(tmp2 == NULL) return NULL;
        if(tmp2->dimensions[0] != Alen) {
            PyErr_SetString(PyExc_ValueError, "Vectors must be same length.");
            return NULL;
        }
        arg3 = (PLINT*)tmp2->data;
    }
    plstyl(arg1,arg2,arg3);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    return resultobj;
    fail:
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    return NULL;
}


#define _doc_plsvect "Set vector arrow style." 
static PyObject *_wrap_plsvect(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT *arg1 = (PLFLT *) 0 ;
    PLFLT *arg2 = (PLFLT *) 0 ;
    PLINT arg3 ;
    PLINT arg4 ;
    PyArrayObject *tmp1 ;
    PyArrayObject *tmp2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:plsvect",&obj0,&obj1,&obj2)) goto fail;
    {
        tmp1 = (PyArrayObject *)myArray_ContiguousFromObject(obj0, PyArray_PLFLT, 1, 1);
        if(tmp1 == NULL) return NULL;
        Alen = tmp1->dimensions[0];
        arg1 = (PLFLT*)tmp1->data;
    }
    {
        tmp2 = (PyArrayObject *)myArray_ContiguousFromObject(obj1, PyArray_PLFLT, 1, 1);
        if(tmp2 == NULL) return NULL;
        if(tmp2->dimensions[0] != Alen) {
            PyErr_SetString(PyExc_ValueError, "Vectors must be same length.");
            return NULL;
        }
        arg2 = (PLFLT*)tmp2->data;
        arg3 = tmp2->dimensions[0];
    }
    arg4 = (PLINT)SWIG_As_long(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    plsvect(arg1,arg2,arg3,arg4);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    return resultobj;
    fail:
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    return NULL;
}


#define _doc_plsvpa "Set the edges of the viewport to the specified absolute coordinates." 
static PyObject *_wrap_plsvpa(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT arg1 ;
    PLFLT arg2 ;
    PLFLT arg3 ;
    PLFLT arg4 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOO:plsvpa",&obj0,&obj1,&obj2,&obj3)) goto fail;
    arg1 = (PLFLT)SWIG_As_double(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLFLT)SWIG_As_double(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    arg3 = (PLFLT)SWIG_As_double(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    arg4 = (PLFLT)SWIG_As_double(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    plsvpa(arg1,arg2,arg3,arg4);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plsxax "Set x axis labeling parameters." 
static PyObject *_wrap_plsxax(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PLINT arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:plsxax",&obj0,&obj1)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLINT)SWIG_As_long(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    plsxax(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plsyax "Set y axis labeling parameters." 
static PyObject *_wrap_plsyax(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PLINT arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:plsyax",&obj0,&obj1)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLINT)SWIG_As_long(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    plsyax(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plsym "Plot array y against x for n points using Hershey symbol \"code\"" 
static PyObject *_wrap_plsym(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PLFLT *arg2 = (PLFLT *) 0 ;
    PLFLT *arg3 = (PLFLT *) 0 ;
    PLINT arg4 ;
    PyArrayObject *tmp1 ;
    PyArrayObject *tmp2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:plsym",&obj0,&obj1,&obj2)) goto fail;
    {
        tmp1 = (PyArrayObject *)myArray_ContiguousFromObject(obj0, PyArray_PLFLT, 1, 1);
        if(tmp1 == NULL) return NULL;
        arg1 = Alen = tmp1->dimensions[0];
        arg2 = (PLFLT*)tmp1->data;
    }
    {
        tmp2 = (PyArrayObject *)myArray_ContiguousFromObject(obj1, PyArray_PLFLT, 1, 1);
        if(tmp2 == NULL) return NULL;
        if(tmp2->dimensions[0] != Alen) {
            PyErr_SetString(PyExc_ValueError, "Vectors must be same length.");
            return NULL;
        }
        arg3 = (PLFLT*)tmp2->data;
    }
    arg4 = (PLINT)SWIG_As_long(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    plsym(arg1,arg2,arg3,arg4);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    return resultobj;
    fail:
    {
        Py_DECREF(tmp1);
    }
    {
        Py_DECREF(tmp2);
    }
    return NULL;
}


#define _doc_plszax "Set z axis labeling parameters" 
static PyObject *_wrap_plszax(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PLINT arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:plszax",&obj0,&obj1)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLINT)SWIG_As_long(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    plszax(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_pltext "Switch to text screen." 
static PyObject *_wrap_pltext(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    
    if(!PyArg_ParseTuple(args,(char *)":pltext")) goto fail;
    pltext();
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plvasp "Sets the edges of the viewport with the given aspect ratio, leaving room for labels." 
static PyObject *_wrap_plvasp(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT arg1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:plvasp",&obj0)) goto fail;
    arg1 = (PLFLT)SWIG_As_double(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    plvasp(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plvect "Plot vectors." 
static PyObject *_wrap_plvect(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT **arg1 = (PLFLT **) 0 ;
    PLFLT **arg2 = (PLFLT **) 0 ;
    PLINT arg3 ;
    PLINT arg4 ;
    PLFLT arg5 ;
    pltr_func arg6 = (pltr_func) 0 ;
    PLPointer arg7 = (PLPointer) 0 ;
    PyArrayObject *tmp1 ;
    PyArrayObject *tmp2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    
    {
        python_pltr = 0;
        arg6 = NULL;
    }
    {
        arg7 = NULL;
    }
    if(!PyArg_ParseTuple(args,(char *)"OOO|OO:plvect",&obj0,&obj1,&obj2,&obj3,&obj4)) goto fail;
    {
        int i, size;
        tmp1 = (PyArrayObject *)myArray_ContiguousFromObject(obj0, PyArray_PLFLT, 2, 2);
        if(tmp1 == NULL) return NULL;
        Xlen = tmp1->dimensions[0];
        Ylen = tmp1->dimensions[1];
        size = sizeof(PLFLT)*Ylen;
        arg1 = (PLFLT**)malloc(sizeof(PLFLT*)*Xlen);
        for(i=0; i<Xlen; i++)
        arg1[i] = (PLFLT*)(tmp1->data + i*size);
    }
    {
        int i, size;
        tmp2 = (PyArrayObject *)myArray_ContiguousFromObject(obj1, PyArray_PLFLT, 2, 2);
        if(tmp2 == NULL) return NULL;
        if(Xlen != tmp2->dimensions[0] || Ylen != tmp2->dimensions[1]) {
            PyErr_SetString(PyExc_ValueError, "Vectors must match matrix.");
            return NULL;
        }
        arg3 = tmp2->dimensions[0];
        arg4 = tmp2->dimensions[1];
        size = sizeof(PLFLT)*arg4;
        arg2 = (PLFLT**)malloc(sizeof(PLFLT*)*arg3);
        for(i=0; i<arg3; i++)
        arg2[i] = (PLFLT*)(tmp2->data + i*size);
    }
    arg5 = (PLFLT)SWIG_As_double(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    if (obj3) {
        {
            /* it must be a callable */
            if(!PyCallable_Check((PyObject*)obj3)) {
                PyErr_SetString(PyExc_ValueError, "pltr argument must be callable");
                return NULL;
            }
            arg6 = marshal_pltr(obj3);
        }
    }
    if (obj4) {
        {
            if(obj4 == Py_None)
            arg7 = NULL;
            else {
                arg7 = marshal_PLPointer(obj4);
            }
        }
    }
    plvect(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        Py_DECREF(tmp1);
        free(arg1);
    }
    {
        Py_DECREF(tmp2);
        free(arg2);
    }
    {
        cleanup_pltr();
    }
    {
        cleanup_PLPointer();
    }
    return resultobj;
    fail:
    {
        Py_DECREF(tmp1);
        free(arg1);
    }
    {
        Py_DECREF(tmp2);
        free(arg2);
    }
    {
        cleanup_pltr();
    }
    {
        cleanup_PLPointer();
    }
    return NULL;
}


#define _doc_plvpas "Create the largest viewport of the specified aspect ratio that fits within the specified normalized subpage coordinates." 
static PyObject *_wrap_plvpas(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT arg1 ;
    PLFLT arg2 ;
    PLFLT arg3 ;
    PLFLT arg4 ;
    PLFLT arg5 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOOO:plvpas",&obj0,&obj1,&obj2,&obj3,&obj4)) goto fail;
    arg1 = (PLFLT)SWIG_As_double(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLFLT)SWIG_As_double(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    arg3 = (PLFLT)SWIG_As_double(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    arg4 = (PLFLT)SWIG_As_double(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    arg5 = (PLFLT)SWIG_As_double(obj4); 
    if (PyErr_Occurred()) SWIG_fail;
    plvpas(arg1,arg2,arg3,arg4,arg5);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plvpor "Create a viewport with the specified normalized subpage coordinates." 
static PyObject *_wrap_plvpor(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT arg1 ;
    PLFLT arg2 ;
    PLFLT arg3 ;
    PLFLT arg4 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOO:plvpor",&obj0,&obj1,&obj2,&obj3)) goto fail;
    arg1 = (PLFLT)SWIG_As_double(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLFLT)SWIG_As_double(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    arg3 = (PLFLT)SWIG_As_double(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    arg4 = (PLFLT)SWIG_As_double(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    plvpor(arg1,arg2,arg3,arg4);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plvsta "Define a \"standard\" viewport with seven character heights for the left margin and four character heights everywhere else." 
static PyObject *_wrap_plvsta(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    
    if(!PyArg_ParseTuple(args,(char *)":plvsta")) goto fail;
    plvsta();
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plw3d "Set up a window for three-dimensional plotting." 
static PyObject *_wrap_plw3d(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT arg1 ;
    PLFLT arg2 ;
    PLFLT arg3 ;
    PLFLT arg4 ;
    PLFLT arg5 ;
    PLFLT arg6 ;
    PLFLT arg7 ;
    PLFLT arg8 ;
    PLFLT arg9 ;
    PLFLT arg10 ;
    PLFLT arg11 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj5 = 0 ;
    PyObject * obj6 = 0 ;
    PyObject * obj7 = 0 ;
    PyObject * obj8 = 0 ;
    PyObject * obj9 = 0 ;
    PyObject * obj10 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOOOOOOOOO:plw3d",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10)) goto fail;
    arg1 = (PLFLT)SWIG_As_double(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLFLT)SWIG_As_double(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    arg3 = (PLFLT)SWIG_As_double(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    arg4 = (PLFLT)SWIG_As_double(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    arg5 = (PLFLT)SWIG_As_double(obj4); 
    if (PyErr_Occurred()) SWIG_fail;
    arg6 = (PLFLT)SWIG_As_double(obj5); 
    if (PyErr_Occurred()) SWIG_fail;
    arg7 = (PLFLT)SWIG_As_double(obj6); 
    if (PyErr_Occurred()) SWIG_fail;
    arg8 = (PLFLT)SWIG_As_double(obj7); 
    if (PyErr_Occurred()) SWIG_fail;
    arg9 = (PLFLT)SWIG_As_double(obj8); 
    if (PyErr_Occurred()) SWIG_fail;
    arg10 = (PLFLT)SWIG_As_double(obj9); 
    if (PyErr_Occurred()) SWIG_fail;
    arg11 = (PLFLT)SWIG_As_double(obj10); 
    if (PyErr_Occurred()) SWIG_fail;
    plw3d(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plwid "Set pen width." 
static PyObject *_wrap_plwid(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:plwid",&obj0)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    plwid(arg1);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plwind "Set up world coordinates of the viewport boundaries (2d plots)." 
static PyObject *_wrap_plwind(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLFLT arg1 ;
    PLFLT arg2 ;
    PLFLT arg3 ;
    PLFLT arg4 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOO:plwind",&obj0,&obj1,&obj2,&obj3)) goto fail;
    arg1 = (PLFLT)SWIG_As_double(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    arg2 = (PLFLT)SWIG_As_double(obj1); 
    if (PyErr_Occurred()) SWIG_fail;
    arg3 = (PLFLT)SWIG_As_double(obj2); 
    if (PyErr_Occurred()) SWIG_fail;
    arg4 = (PLFLT)SWIG_As_double(obj3); 
    if (PyErr_Occurred()) SWIG_fail;
    plwind(arg1,arg2,arg3,arg4);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plxormod "Set xor mode; mode = 1-enter, 0-leave, status = 0 if not interactive device." 
static PyObject *_wrap_plxormod(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLINT arg1 ;
    PLINT *arg2 = (PLINT *) 0 ;
    PLINT temp2 ;
    int res2 = 0 ;
    PyObject * obj0 = 0 ;
    
    arg2 = &temp2; res2 = SWIG_NEWOBJ;
    if(!PyArg_ParseTuple(args,(char *)"O:plxormod",&obj0)) goto fail;
    arg1 = (PLINT)SWIG_As_long(obj0); 
    if (PyErr_Occurred()) SWIG_fail;
    plxormod(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    resultobj = t_output_helper(resultobj, ((res2 == SWIG_NEWOBJ) ?
    SWIG_From_long((*arg2)) : SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_PLINT, 0)));
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_plClearOpts(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    
    if(!PyArg_ParseTuple(args,(char *)":plClearOpts")) goto fail;
    plClearOpts();
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_plResetOpts(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    
    if(!PyArg_ParseTuple(args,(char *)":plResetOpts")) goto fail;
    plResetOpts();
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_plSetUsage(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    char *arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:plSetUsage",&obj0,&obj1)) goto fail;
    if (!SWIG_AsCharPtr(obj0, (char**)&arg1)) SWIG_fail;
    if (!SWIG_AsCharPtr(obj1, (char**)&arg2)) SWIG_fail;
    plSetUsage(arg1,arg2);
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_plOptUsage(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    
    if(!PyArg_ParseTuple(args,(char *)":plOptUsage")) goto fail;
    plOptUsage();
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


#define _doc_plGetCursor "Wait for graphics input event and translate to world coordinates" 
static PyObject *_wrap_plGetCursor(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PLGraphicsIn *arg1 = (PLGraphicsIn *) 0 ;
    PLINT result;
    PLGraphicsIn tmp1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:plGetCursor",&obj0)) goto fail;
    {
        if(!PySequence_Check(obj0) || PySequence_Size(obj0) != 2) {
            PyErr_SetString(PyExc_ValueError, "Expecting a sequence of 2 numbers.");
            return NULL;
        }
        arg1 = &tmp1;
        arg1->dX = PyFloat_AsDouble(PySequence_Fast_GET_ITEM(obj0, 0));
        arg1->dY = PyFloat_AsDouble(PySequence_Fast_GET_ITEM(obj0, 1));
    }
    result = (PLINT)plGetCursor(arg1);
    
    resultobj = SWIG_From_long((long)result);
    {
        PyObject *o;
        o = PyFloat_FromDouble(arg1->wX);
        resultobj = t_output_helper(resultobj, o);
        o = PyFloat_FromDouble(arg1->wY);
        resultobj = t_output_helper(resultobj, o);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyMethodDef SwigMethods[] = {
	 { (char *)"pltr0", _wrap_pltr0, METH_VARARGS, NULL },
	 { (char *)"pltr1", _wrap_pltr1, METH_VARARGS, NULL },
	 { (char *)"pltr2", _wrap_pltr2, METH_VARARGS, NULL },
	 { (char *)"plsxwin", _wrap_plsxwin, METH_VARARGS, NULL },
	 { (char *)"pl_setcontlabelformat", _wrap_pl_setcontlabelformat, METH_VARARGS, NULL },
	 { (char *)"pl_setcontlabelparam", _wrap_pl_setcontlabelparam, METH_VARARGS, NULL },
	 { (char *)"pladv", _wrap_pladv, METH_VARARGS, NULL },
	 { (char *)"plaxes", _wrap_plaxes, METH_VARARGS, NULL },
	 { (char *)"plbin", _wrap_plbin, METH_VARARGS, NULL },
	 { (char *)"plbop", _wrap_plbop, METH_VARARGS, NULL },
	 { (char *)"plbox", _wrap_plbox, METH_VARARGS, NULL },
	 { (char *)"plbox3", _wrap_plbox3, METH_VARARGS, NULL },
	 { (char *)"plcalc_world", _wrap_plcalc_world, METH_VARARGS, NULL },
	 { (char *)"plclear", _wrap_plclear, METH_VARARGS, NULL },
	 { (char *)"plcol0", _wrap_plcol0, METH_VARARGS, NULL },
	 { (char *)"plcol1", _wrap_plcol1, METH_VARARGS, NULL },
	 { (char *)"plcont", _wrap_plcont, METH_VARARGS, NULL },
	 { (char *)"plcpstrm", _wrap_plcpstrm, METH_VARARGS, NULL },
	 { (char *)"plend", _wrap_plend, METH_VARARGS, NULL },
	 { (char *)"plend1", _wrap_plend1, METH_VARARGS, NULL },
	 { (char *)"plenv", _wrap_plenv, METH_VARARGS, NULL },
	 { (char *)"pleop", _wrap_pleop, METH_VARARGS, NULL },
	 { (char *)"plerrx", _wrap_plerrx, METH_VARARGS, NULL },
	 { (char *)"plerry", _wrap_plerry, METH_VARARGS, NULL },
	 { (char *)"plfamadv", _wrap_plfamadv, METH_VARARGS, NULL },
	 { (char *)"plfill", _wrap_plfill, METH_VARARGS, NULL },
	 { (char *)"plfill3", _wrap_plfill3, METH_VARARGS, NULL },
	 { (char *)"plflush", _wrap_plflush, METH_VARARGS, NULL },
	 { (char *)"plfont", _wrap_plfont, METH_VARARGS, NULL },
	 { (char *)"plfontld", _wrap_plfontld, METH_VARARGS, NULL },
	 { (char *)"plgchr", _wrap_plgchr, METH_VARARGS, NULL },
	 { (char *)"plgcol0", _wrap_plgcol0, METH_VARARGS, NULL },
	 { (char *)"plgcolbg", _wrap_plgcolbg, METH_VARARGS, NULL },
	 { (char *)"plgcompression", _wrap_plgcompression, METH_VARARGS, NULL },
	 { (char *)"plgdev", _wrap_plgdev, METH_VARARGS, NULL },
	 { (char *)"plgdidev", _wrap_plgdidev, METH_VARARGS, NULL },
	 { (char *)"plgdiori", _wrap_plgdiori, METH_VARARGS, NULL },
	 { (char *)"plgdiplt", _wrap_plgdiplt, METH_VARARGS, NULL },
	 { (char *)"plgfam", _wrap_plgfam, METH_VARARGS, NULL },
	 { (char *)"plgfci", _wrap_plgfci, METH_VARARGS, NULL },
	 { (char *)"plgfnam", _wrap_plgfnam, METH_VARARGS, NULL },
	 { (char *)"plglevel", _wrap_plglevel, METH_VARARGS, NULL },
	 { (char *)"plgpage", _wrap_plgpage, METH_VARARGS, NULL },
	 { (char *)"plgra", _wrap_plgra, METH_VARARGS, NULL },
	 { (char *)"plgspa", _wrap_plgspa, METH_VARARGS, NULL },
	 { (char *)"plgstrm", _wrap_plgstrm, METH_VARARGS, NULL },
	 { (char *)"plgver", _wrap_plgver, METH_VARARGS, NULL },
	 { (char *)"plgvpd", _wrap_plgvpd, METH_VARARGS, NULL },
	 { (char *)"plgvpw", _wrap_plgvpw, METH_VARARGS, NULL },
	 { (char *)"plgxax", _wrap_plgxax, METH_VARARGS, NULL },
	 { (char *)"plgyax", _wrap_plgyax, METH_VARARGS, NULL },
	 { (char *)"plgzax", _wrap_plgzax, METH_VARARGS, NULL },
	 { (char *)"plhist", _wrap_plhist, METH_VARARGS, NULL },
	 { (char *)"plhls", _wrap_plhls, METH_VARARGS, NULL },
	 { (char *)"plhlsrgb", _wrap_plhlsrgb, METH_VARARGS, NULL },
	 { (char *)"plinit", _wrap_plinit, METH_VARARGS, NULL },
	 { (char *)"pljoin", _wrap_pljoin, METH_VARARGS, NULL },
	 { (char *)"pllab", _wrap_pllab, METH_VARARGS, NULL },
	 { (char *)"pllightsource", _wrap_pllightsource, METH_VARARGS, NULL },
	 { (char *)"plline", _wrap_plline, METH_VARARGS, NULL },
	 { (char *)"plline3", _wrap_plline3, METH_VARARGS, NULL },
	 { (char *)"pllsty", _wrap_pllsty, METH_VARARGS, NULL },
	 { (char *)"plmesh", _wrap_plmesh, METH_VARARGS, NULL },
	 { (char *)"plmeshc", _wrap_plmeshc, METH_VARARGS, NULL },
	 { (char *)"plmkstrm", _wrap_plmkstrm, METH_VARARGS, NULL },
	 { (char *)"plmtex", _wrap_plmtex, METH_VARARGS, NULL },
	 { (char *)"plot3d", _wrap_plot3d, METH_VARARGS, NULL },
	 { (char *)"plot3dc", _wrap_plot3dc, METH_VARARGS, NULL },
	 { (char *)"plot3dcl", _wrap_plot3dcl, METH_VARARGS, NULL },
	 { (char *)"plsurf3d", _wrap_plsurf3d, METH_VARARGS, NULL },
	 { (char *)"plsurf3dl", _wrap_plsurf3dl, METH_VARARGS, NULL },
	 { (char *)"plparseopts", _wrap_plparseopts, METH_VARARGS, NULL },
	 { (char *)"plpat", _wrap_plpat, METH_VARARGS, NULL },
	 { (char *)"plpoin", _wrap_plpoin, METH_VARARGS, NULL },
	 { (char *)"plpoin3", _wrap_plpoin3, METH_VARARGS, NULL },
	 { (char *)"plpoly3", _wrap_plpoly3, METH_VARARGS, NULL },
	 { (char *)"plprec", _wrap_plprec, METH_VARARGS, NULL },
	 { (char *)"plpsty", _wrap_plpsty, METH_VARARGS, NULL },
	 { (char *)"plptex", _wrap_plptex, METH_VARARGS, NULL },
	 { (char *)"plreplot", _wrap_plreplot, METH_VARARGS, NULL },
	 { (char *)"plrgbhls", _wrap_plrgbhls, METH_VARARGS, NULL },
	 { (char *)"plschr", _wrap_plschr, METH_VARARGS, NULL },
	 { (char *)"plscmap0", _wrap_plscmap0, METH_VARARGS, NULL },
	 { (char *)"plscmap0n", _wrap_plscmap0n, METH_VARARGS, NULL },
	 { (char *)"plscmap1", _wrap_plscmap1, METH_VARARGS, NULL },
	 { (char *)"plscmap1l", _wrap_plscmap1l, METH_VARARGS, NULL },
	 { (char *)"plscmap1n", _wrap_plscmap1n, METH_VARARGS, NULL },
	 { (char *)"plscol0", _wrap_plscol0, METH_VARARGS, NULL },
	 { (char *)"plscolbg", _wrap_plscolbg, METH_VARARGS, NULL },
	 { (char *)"plscolor", _wrap_plscolor, METH_VARARGS, NULL },
	 { (char *)"plscompression", _wrap_plscompression, METH_VARARGS, NULL },
	 { (char *)"plsdev", _wrap_plsdev, METH_VARARGS, NULL },
	 { (char *)"plsdidev", _wrap_plsdidev, METH_VARARGS, NULL },
	 { (char *)"plsdimap", _wrap_plsdimap, METH_VARARGS, NULL },
	 { (char *)"plsdiori", _wrap_plsdiori, METH_VARARGS, NULL },
	 { (char *)"plsdiplt", _wrap_plsdiplt, METH_VARARGS, NULL },
	 { (char *)"plsdiplz", _wrap_plsdiplz, METH_VARARGS, NULL },
	 { (char *)"plsesc", _wrap_plsesc, METH_VARARGS, NULL },
	 { (char *)"plsetopt", _wrap_plsetopt, METH_VARARGS, NULL },
	 { (char *)"plsfam", _wrap_plsfam, METH_VARARGS, NULL },
	 { (char *)"plsfci", _wrap_plsfci, METH_VARARGS, NULL },
	 { (char *)"plsfnam", _wrap_plsfnam, METH_VARARGS, NULL },
	 { (char *)"plshades", _wrap_plshades, METH_VARARGS, NULL },
	 { (char *)"plshade", _wrap_plshade, METH_VARARGS, NULL },
	 { (char *)"plsmaj", _wrap_plsmaj, METH_VARARGS, NULL },
	 { (char *)"plsmin", _wrap_plsmin, METH_VARARGS, NULL },
	 { (char *)"plsori", _wrap_plsori, METH_VARARGS, NULL },
	 { (char *)"plspage", _wrap_plspage, METH_VARARGS, NULL },
	 { (char *)"plspause", _wrap_plspause, METH_VARARGS, NULL },
	 { (char *)"plsstrm", _wrap_plsstrm, METH_VARARGS, NULL },
	 { (char *)"plssub", _wrap_plssub, METH_VARARGS, NULL },
	 { (char *)"plssym", _wrap_plssym, METH_VARARGS, NULL },
	 { (char *)"plstar", _wrap_plstar, METH_VARARGS, NULL },
	 { (char *)"plstart", _wrap_plstart, METH_VARARGS, NULL },
	 { (char *)"plstripa", _wrap_plstripa, METH_VARARGS, NULL },
	 { (char *)"plstripc", _wrap_plstripc, METH_VARARGS, NULL },
	 { (char *)"plstripd", _wrap_plstripd, METH_VARARGS, NULL },
	 { (char *)"plstyl", _wrap_plstyl, METH_VARARGS, NULL },
	 { (char *)"plsvect", _wrap_plsvect, METH_VARARGS, NULL },
	 { (char *)"plsvpa", _wrap_plsvpa, METH_VARARGS, NULL },
	 { (char *)"plsxax", _wrap_plsxax, METH_VARARGS, NULL },
	 { (char *)"plsyax", _wrap_plsyax, METH_VARARGS, NULL },
	 { (char *)"plsym", _wrap_plsym, METH_VARARGS, NULL },
	 { (char *)"plszax", _wrap_plszax, METH_VARARGS, NULL },
	 { (char *)"pltext", _wrap_pltext, METH_VARARGS, NULL },
	 { (char *)"plvasp", _wrap_plvasp, METH_VARARGS, NULL },
	 { (char *)"plvect", _wrap_plvect, METH_VARARGS, NULL },
	 { (char *)"plvpas", _wrap_plvpas, METH_VARARGS, NULL },
	 { (char *)"plvpor", _wrap_plvpor, METH_VARARGS, NULL },
	 { (char *)"plvsta", _wrap_plvsta, METH_VARARGS, NULL },
	 { (char *)"plw3d", _wrap_plw3d, METH_VARARGS, NULL },
	 { (char *)"plwid", _wrap_plwid, METH_VARARGS, NULL },
	 { (char *)"plwind", _wrap_plwind, METH_VARARGS, NULL },
	 { (char *)"plxormod", _wrap_plxormod, METH_VARARGS, NULL },
	 { (char *)"plClearOpts", _wrap_plClearOpts, METH_VARARGS, NULL },
	 { (char *)"plResetOpts", _wrap_plResetOpts, METH_VARARGS, NULL },
	 { (char *)"plSetUsage", _wrap_plSetUsage, METH_VARARGS, NULL },
	 { (char *)"plOptUsage", _wrap_plOptUsage, METH_VARARGS, NULL },
	 { (char *)"plGetCursor", _wrap_plGetCursor, METH_VARARGS, NULL },
	 { NULL, NULL, 0, NULL }
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_PLcGrid[] = {{"_p_PLcGrid", 0, "PLcGrid *", 0, 0, 0, 0},{"_p_PLcGrid", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_PLcGrid2[] = {{"_p_PLcGrid2", 0, "PLcGrid2 *", 0, 0, 0, 0},{"_p_PLcGrid2", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_char[] = {{"_p_char", 0, "char *", 0, 0, 0, 0},{"_p_char", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_p_char[] = {{"_p_p_char", 0, "char **", 0, 0, 0, 0},{"_p_p_char", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__defined_func[] = {{"_defined_func", 0, "long (*)(double,double)|defined_func", 0, 0, 0, 0},{"_defined_func", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__pltr_func[] = {{"_pltr_func", 0, "void (*)(double,double,double *,double *,void *)|pltr_func", 0, 0, 0, 0},{"_pltr_func", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_PLUNICODE[] = {{"_p_PLUNICODE", 0, "unsigned int *|PLUNICODE *", 0, 0, 0, 0},{"_p_PLUNICODE", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_PLFLT[] = {{"_p_PLFLT", 0, "double *|PLFLT *", 0, 0, 0, 0},{"_p_PLFLT", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_PLINT[] = {{"_p_PLINT", 0, "long *|PLINT *", 0, 0, 0, 0},{"_p_PLINT", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_p_PLFLT[] = {{"_p_p_PLFLT", 0, "double **|PLFLT **", 0, 0, 0, 0},{"_p_p_PLFLT", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_int[] = {{"_p_int", 0, "int *", 0, 0, 0, 0},{"_p_int", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__fill_func[] = {{"_fill_func", 0, "void (*)(long,double *,double *)|fill_func", 0, 0, 0, 0},{"_fill_func", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_PLGraphicsIn[] = {{"_p_PLGraphicsIn", 0, "PLGraphicsIn *", 0, 0, 0, 0},{"_p_PLGraphicsIn", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_PLcGrid, 
_swigt__p_PLcGrid2, 
_swigt__p_char, 
_swigt__p_p_char, 
_swigt__defined_func, 
_swigt__pltr_func, 
_swigt__p_PLUNICODE, 
_swigt__p_PLFLT, 
_swigt__p_PLINT, 
_swigt__p_p_PLFLT, 
_swigt__p_int, 
_swigt__fill_func, 
_swigt__p_PLGraphicsIn, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_const_info swig_const_table[] = {
{0, 0, 0, 0.0, 0, 0}};

#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C"
#endif
SWIGEXPORT(void) SWIG_init(void) {
    static PyObject *SWIG_globals = 0; 
    static int       typeinit = 0;
    PyObject *m, *d;
    int       i;
    if (!SWIG_globals) SWIG_globals = SWIG_newvarlink();
    m = Py_InitModule((char *) SWIG_name, SwigMethods);
    d = PyModule_GetDict(m);
    
    if (!typeinit) {
        for (i = 0; swig_types_initial[i]; i++) {
            swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
        }
        typeinit = 1;
    }
    SWIG_InstallConstants(d,swig_const_table);
    
    
    import_array();
    
    PyDict_SetItemString(d,"PLESC_SET_RGB", SWIG_From_int((int)1));
    PyDict_SetItemString(d,"PLESC_ALLOC_NCOL", SWIG_From_int((int)2));
    PyDict_SetItemString(d,"PLESC_SET_LPB", SWIG_From_int((int)3));
    PyDict_SetItemString(d,"PLESC_EXPOSE", SWIG_From_int((int)4));
    PyDict_SetItemString(d,"PLESC_RESIZE", SWIG_From_int((int)5));
    PyDict_SetItemString(d,"PLESC_REDRAW", SWIG_From_int((int)6));
    PyDict_SetItemString(d,"PLESC_TEXT", SWIG_From_int((int)7));
    PyDict_SetItemString(d,"PLESC_GRAPH", SWIG_From_int((int)8));
    PyDict_SetItemString(d,"PLESC_FILL", SWIG_From_int((int)9));
    PyDict_SetItemString(d,"PLESC_DI", SWIG_From_int((int)10));
    PyDict_SetItemString(d,"PLESC_FLUSH", SWIG_From_int((int)11));
    PyDict_SetItemString(d,"PLESC_EH", SWIG_From_int((int)12));
    PyDict_SetItemString(d,"PLESC_GETC", SWIG_From_int((int)13));
    PyDict_SetItemString(d,"PLESC_SWIN", SWIG_From_int((int)14));
    PyDict_SetItemString(d,"PLESC_PLFLTBUFFERING", SWIG_From_int((int)15));
    PyDict_SetItemString(d,"PLESC_XORMOD", SWIG_From_int((int)16));
    PyDict_SetItemString(d,"PLESC_SET_COMPRESSION", SWIG_From_int((int)17));
    PyDict_SetItemString(d,"PLESC_CLEAR", SWIG_From_int((int)18));
    PyDict_SetItemString(d,"PLESC_DASH", SWIG_From_int((int)19));
    PyDict_SetItemString(d,"PLESC_HAS_TEXT", SWIG_From_int((int)20));
    PyDict_SetItemString(d,"PLESC_IMAGE", SWIG_From_int((int)21));
    PyDict_SetItemString(d,"PLESC_IMAGEOPS", SWIG_From_int((int)22));
    PyDict_SetItemString(d,"DRAW_LINEX", SWIG_From_int((int)0x01));
    PyDict_SetItemString(d,"DRAW_LINEY", SWIG_From_int((int)0x02));
    PyDict_SetItemString(d,"DRAW_LINEXY", SWIG_From_int((int)0x03));
    PyDict_SetItemString(d,"MAG_COLOR", SWIG_From_int((int)0x04));
    PyDict_SetItemString(d,"BASE_CONT", SWIG_From_int((int)0x08));
    PyDict_SetItemString(d,"TOP_CONT", SWIG_From_int((int)0x10));
    PyDict_SetItemString(d,"SURF_CONT", SWIG_From_int((int)0x20));
    PyDict_SetItemString(d,"DRAW_SIDES", SWIG_From_int((int)0x40));
    PyDict_SetItemString(d,"FACETED", SWIG_From_int((int)0x80));
    PyDict_SetItemString(d,"MESH", SWIG_From_int((int)0x100));
    PyDict_SetItemString(d,"PLSWIN_DEVICE", SWIG_From_int((int)1));
    PyDict_SetItemString(d,"PLSWIN_WORLD", SWIG_From_int((int)2));
    PyDict_SetItemString(d,"PL_OPT_ENABLED", SWIG_From_int((int)0x0001));
    PyDict_SetItemString(d,"PL_OPT_ARG", SWIG_From_int((int)0x0002));
    PyDict_SetItemString(d,"PL_OPT_NODELETE", SWIG_From_int((int)0x0004));
    PyDict_SetItemString(d,"PL_OPT_INVISIBLE", SWIG_From_int((int)0x0008));
    PyDict_SetItemString(d,"PL_OPT_DISABLED", SWIG_From_int((int)0x0010));
    PyDict_SetItemString(d,"PL_OPT_FUNC", SWIG_From_int((int)0x0100));
    PyDict_SetItemString(d,"PL_OPT_BOOL", SWIG_From_int((int)0x0200));
    PyDict_SetItemString(d,"PL_OPT_INT", SWIG_From_int((int)0x0400));
    PyDict_SetItemString(d,"PL_OPT_FLOAT", SWIG_From_int((int)0x0800));
    PyDict_SetItemString(d,"PL_OPT_STRING", SWIG_From_int((int)0x1000));
    PyDict_SetItemString(d,"PL_PARSE_PARTIAL", SWIG_From_int((int)0x0000));
    PyDict_SetItemString(d,"PL_PARSE_FULL", SWIG_From_int((int)0x0001));
    PyDict_SetItemString(d,"PL_PARSE_QUIET", SWIG_From_int((int)0x0002));
    PyDict_SetItemString(d,"PL_PARSE_NODELETE", SWIG_From_int((int)0x0004));
    PyDict_SetItemString(d,"PL_PARSE_SHOWALL", SWIG_From_int((int)0x0008));
    PyDict_SetItemString(d,"PL_PARSE_OVERRIDE", SWIG_From_int((int)0x0010));
    PyDict_SetItemString(d,"PL_PARSE_NOPROGRAM", SWIG_From_int((int)0x0020));
    PyDict_SetItemString(d,"PL_PARSE_NODASH", SWIG_From_int((int)0x0040));
    PyDict_SetItemString(d,"PL_PARSE_SKIP", SWIG_From_int((int)0x0080));
    PyDict_SetItemString(d,"PL_MAXKEY", SWIG_From_int((int)16));
    PyDict_SetItemString(d,"PL_MAXWINDOWS", SWIG_From_int((int)64));
    PyDict_SetItemString(d,"PL_NOTSET", SWIG_From_int((int)(-42)));
    PyDict_SetItemString(d,"PLESPLFLTBUFFERING_ENABLE", SWIG_From_int((int)1));
    PyDict_SetItemString(d,"PLESPLFLTBUFFERING_DISABLE", SWIG_From_int((int)2));
    PyDict_SetItemString(d,"PLESPLFLTBUFFERING_QUERY", SWIG_From_int((int)3));
}

