Here is how to generate the new Java interface to PLplot using swig.

PREREQUISITE: swig-1.3.21 (or later) must be installed if you are trying the
java interface to PLplot from the cvs version of PLplot. If you are doing
this from a PLplot tarball, it should have all the swig-created files in it
already, and you shouldn't need swig at all.

(1) Install a Java SDK (Software Development Kit).  I use
IBMJava2-SDK-14.tgz which is freely downloadable from IBM.  (See
http://www-106.ibm.com/developerworks/java/jdk/linux/tested.html for product
description.)

(2) If the java include files are not in a default include directory then
you need to tell configure where they are. You can either use the
--with-java-home option to set the SDK directory e.g.
./configure --with-java-home=/home/software/java/IBMJava2-14/
Previously this was done via the environment variables JAVA_HOME, which
still works for backwards compatibility.

(3) The rest is highly automated.  Move to the top-level PLplot build
directory and configure, build, and install.

cd plplot
./configure --prefix=/usr/local/plplot  (+ other options you care to
specify).

Note the option --enable-java is turned on by default, and if you have
set the above environment variables the report at the end will indicate
that java was not turned off by the configure script because of some
problem.

make
make install

That completes the installation of the Java interface to PLplot.
To test it with a number of example scripts, have a look at
../../examples/java/README.javademos.

For the curious, here are some more details about the 'make' and 'make
install' steps above.

'make' automatically runs swig (version 1.3.21 or above) on plplotjavac.i
(which does an include of ../swig-support/plplotcapi.i) to generate all the
interface files that are needed for further processing.  To understand these
two *.i files and what they do, you should read the latest java interface
documentation from swig version 1.3.21.  The result should be a complete
interface (aside from the limitations mentioned below) for Java to the
PLplot common API.

The files generated by swig are necessary java files and plplotjavac_wrap.c.
(These files should already be pre-generated if you have received PLplot as
a tarball).  'make' builds the java interface shared object module (DLL)
plplotjavac_wrap.SOBJEXT from plplotjavac_wrap.c. 'make' also builds the
class files corresponding to the swig-generated java files, the configured
config.java file, and the PLStream.java file which is hand-crafted (swig
might be able to do this in future) so that calling a method in the class
will ensure the stream is correctly set before calling the underlying API
function.  The relevant java files and corresponding class files that are
compiled from them make up the plplot.core package.

Note that a quite different PLStream.java file that was used in the
historical hand-crafted interface to java (discussed below) is now stored in
the old subdirectory of the top-level source tree for reference purposes.
Note javabind.c from that historical interface is also stored in the old
subdirectory.

'make install' installs the relevant java and class files that are part of
the plplot.core package in $prefix/share/java/plplot/core, 
installs the shared object module (DLL) plplotjavac_wrap.SOBJEXT for the 
java PLplot interface in the $prefix/lib/jni, and also installs 
(from ../../examples/java) the example java scripts and corresponding class 
files that are part of the plplot.examples package into 
$prefix/share/plplot5.3.1/java/plplot/examples. For more details about the 
examples, please see ../../examples/java/README.javademos or the installed 
version of that file in $prefix/share/plplot5.3.1/examples/java/. Copies of
the java files are also in this directory for convenience.
At the end of the install process all the files in 
$prefix/share/java/plplot/ are bundled into a jar file
$prefix/share/java/plplot.jar and the plplot directory is
deleted.

Here is how to add a new function to the Java API for PLplot:

Edit ../swig-support/plplotcapi.i.  (If you want just a Java interface to
this PLplot function and not a python or any other interface, then wrap your
entry with #ifdef SWIG_JAVA ... #endif, but ordinarily you will be adding
functions for all swig-generated interfaces so you will not use a java-only
#ifdef at all.) Find a function with the same argument types that you have
in your new function, and copy those argument types and argument names
*EXACTLY*.  The typedefs in plplotjavac.i process argument type and argument
name patterns to produce the required java files and java interface code. So
give it the same pattern (white space doesn't matter), and you will get the
same argument processing that worked before for the old function. In the
unlikely event that you have a new pattern of argument list, then it is time
to dig into the Java interface documentation for swig.

Limitations of the current swig-generated Java interface to PLplot:

* The new Java interface to PLplot should be complete, but that
functionality has not been thoroughly tested.  All the example scripts run
fine which is an excellent sign, but those only exercise a subset of the
Java PLplot API.  In particular, very few of the many 'plg' style functions
that obtain floating point or integer information from the PLplot
environment have been exercised.  You will have to look up the JNI tutorial
from Sun or the swig documentation to see how to access variables returned
as arguments in the Java environment.

* A user-friendly (UF) wrapper to the raw java interface should be made to
give us a variety of different simplified argument lists similarly to the
way plplot.py wraps the plplotc extension module.  I assume that java is
more powerful than C so that it makes sense to write the UF interface in
java rather than C. Note the raw interface only allows two-dimensional xg,
and yg arrays to plcont, plshades, and plshade. The options of no xg, yg,
and one-dimensional xg, and yg should also be allowed for the UI interface.
Also note the raw interface to plparseopts demands you must be explicit
about ORing in pls.PL_PARSE_NOPROGRAM to the parse mode parameter.  This
idiosyncrasy of Java should be hidden for the UF interface.

If someone will show me (AWI) the way by writing such a java wrapper with
just one argument list simplification, I can fill out the rest following the
user-friendly simplified argument list variations that have been implemented
in plplot.py.

* Only the default java double-precision can be used from Java.  That is
what the examples use (by default) and that is what works.  I believe the way
to do this properly with swig is simply to make both single and double
precision versions of the PLplot API description, and the two possible
function calls will automatically be overloaded.  But I may have that wrong.

N.B. This java precision issue should not be confused with the double or
single precision PLplot library issue.  I have been doing my testing with
both the single-precision and double-precision forms of the PLplot library,
and all double-precision java entities are transformed to the appropriate C
precision (either single or double) without problems.

* The callback functions should be done properly so that Java methods can
be used for transformations for the full 3-D PLplot API.  This approach
would be similar to the way the Python interface fully implements the
callback functions (see the mypltr definition and use in xw09.py).  For now,
though, we will be taking a simplified approach to the 3-d API similar to
what is done for the Tcl interface rather than the preferred complete
callback approach used for the Python interface.

Alan W. Irwin 
Andrew Ross (last updated 2004-07-01)
_________________________________________________________________

The following notes (written by Geoffrey Furnish with some minor editing
from Alan W. Irwin & others) concern the historical way we handcrafted a
partial Java interface to PLplot.  The resulting PLStream.java and
javabind.c files were quite useful in helping to understand what was needed
for the swig interface, and they may also be used to resolve any swig
problems in the future.  Thus, we will keep them in CVS (in the old
subdirectory of the top-level source tree) for reference.

Here is the historical hand-crafted way to add additional PLplot API to Java
under jdk 1.3.1. This may well work for other jdk versions, but it has not
been tested for them.

1) Edit PLStream.java, add "native" prototype for a new PLplot API
   function. 

2) Do all the java setup mentioned in plplot/examples/java/README.javademos
   and execute ./configure and make from the plplot directory.  This
   should compile PLStream.java with javac.

3) (from the tmp directory) "javah plplot.core.PLStream".

4) less the big hairy file that comes out.  The name of this file should
   be something like:
      plplot_core_PLStream.h
   If you use a "/" instead of a "." in the javah command, it may look like:
      plplot_0002fcore_0002fPLStream.h
   where the "0002f" means "/".  So use the "." syntax instead.

5) Find the prototypes for the JNI functions corresponding to the new
   API(s) you prototyped in 1) above.

6) Paste that (comment block plus function decl) into javabind.c, in
   the appropriate place.  I am more-or-less trying to keep javabind.c
   and PLStream.java ordered the same way as they're declared in
   plplot.h.  But plplot.h's function decls aren't actually all
   alphabetical for one thing, and also for the Java binding, I
   hoisted a few things to the top of javabind.c, just because it made
   sense to me at the time.  I forget the exact justification, but it
   had something to do with some things seeming to me that they were
   only useful inside the JNI code (javabind.c), and not really
   something we wanted to expose to the (Java-side) user of
   PLStream.java.  Also, I kept the (only partially implemented) arg
   parsing stuff together, irrespective of alphabetization.

7) Edit out any occurances of the "0002f" string if they occur (see #2 for
   avoiding this).

8) Fill in the function parameter names.

9) Implement the function.  For this, what I do, is cut and paste.  I
   find an existing function with argument signature similar to the
   one I'm doing now, copy its function body into place, and tweak as
   required.  Maybe arg names have to be changed, or maybe only the
   actual embedded call to the PLplot API function.  For instance,
   last night I built fill by copying line's body, and changing the
   call from plline(...) to plfill(...), and that was it.  For fill3 I
   took fill's body, added handling for z, changed plfill(...) to
   plfill3(...), and that was it.  Then line3 was made from fill3 in
   the same way that fill was made from line.

10) make (builds javabind.c, libplplot)

11) Edit x??.java to use the new api, then make jdemos

12) java plplot/examples/x??, be happy.  Or fix bugs :-/, as
    required. 

I think you'll be able to do the monkey-see-monkey-do thing easily
enough to cover many of the cases.  I think the existing functions are
fairly solid examples of how to do JNI code.

There are some problems.  I think I probably have a pretty bad bug in
some of the code that handles 2-d arrays.  There are some comments
about this in there somewhere, how I tried to do something I thought
was obvious but it didn't work, so I left it somehow that works, but
am concerned that it isn't right.  I've had some more thoughts about
those things, but haven't had time to try to set it straight.  I think
it comes down to lifetime management of stuff you fetch from JNI, and
probably I have to hold onto things more carefully.  Those sections of
code will probably become substantially more complex than they are
now, which is part of why I haven't attacked it yet.

[Update, 1/18/02:  The plcont wrappers do the 2-d lifetime management
stuff right.  Other 2-d functions (using jobjectarrays) should be
retrofitted, and certainly new wrappers involving 2-d data args should
be modelled after the plcont memory management style.]

But the simpler things you should be able to handle uneventfully.
Things that take scalars, or simple arrays, I think you can follow in
the footsteps of plline(), or other simple/similar signature
functions, and be okay.

Geoffrey, 28 December 2001
