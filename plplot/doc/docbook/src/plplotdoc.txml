<?xml version="1.0" encoding="utf-8"?>
<texinfo file=""><directory><menuentry file=""><menuentrytitle>The PLplot Plotting Library</menuentrytitle><menuentrydescrip>
            ???
          </menuentrydescrip></menuentry></directory><node name="Top" previous="" next="Introduction"/><top>The PLplot Plotting Library</top><menu><menuentry node="Introduction"><menuentrytitle>Introduction</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Simple Use of PLplot"><menuentrytitle>Simple Use of PLplot</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Advanced Use of PLplot"><menuentrytitle>Advanced Use of PLplot</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Deploying programs that use PLplot"><menuentrytitle>Deploying programs that use PLplot</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="The PLplot Display Driver Family"><menuentrytitle>The PLplot Display Driver Family</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="The PLplot Output Driver Family"><menuentrytitle>The PLplot Output Driver Family</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="C Language"><menuentrytitle>C Language</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Fortran Language"><menuentrytitle>Fortran Language</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="A C++ Interface for PLplot"><menuentrytitle>A C++ Interface for PLplot</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Using PLplot from Tcl"><menuentrytitle>Using PLplot from Tcl</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Building an Extended WISH"><menuentrytitle>Building an Extended WISH</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Embedding Plots in Graphical User Interfaces"><menuentrytitle>Embedding Plots in Graphical User Interfaces</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Using PLplot from Perl"><menuentrytitle>Using PLplot from Perl</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Using PLplot from Python"><menuentrytitle>Using PLplot from Python</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Bibliography"><menuentrytitle>Bibliography</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="The Common API for PLplot"><menuentrytitle>The Common API for PLplot</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="The Specialized C API for PLplot"><menuentrytitle>The Specialized C API for PLplot</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="The Specialized Fortran API for PLplot"><menuentrytitle>The Specialized Fortran API for PLplot</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="API compatibility definition"><menuentrytitle>API compatibility definition</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Obsolete/Deprecated API for PLplot"><menuentrytitle>Obsolete/Deprecated API for PLplot</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Notes for each Operating System that We Support"><menuentrytitle>Notes for each Operating System that We Support</menuentrytitle><menuentrydescrip/></menuentry><detailmenu><menuline>— The Detailed Node Listing —</menuline><menuline/><menuline>Introduction</menuline><menuline/><menuentry node="The PLplot Plotting Library"><menuentrytitle>The PLplot Plotting Library</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Getting a Copy of the PLplot Package"><menuentrytitle>Getting a Copy of the PLplot Package</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Installing and Using the PLplot Library"><menuentrytitle>Installing and Using the PLplot Library</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Organization of this Manual"><menuentrytitle>Organization of this Manual</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Copyrights"><menuentrytitle>Copyrights</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Credits"><menuentrytitle>Credits</menuentrytitle><menuentrydescrip/></menuentry><menuline/><menuline>Simple Use of PLplot</menuline><menuline/><menuentry node="Plotting a Simple Graph"><menuentrytitle>Plotting a Simple Graph</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Initializing PLplot"><menuentrytitle>Initializing PLplot</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Defining Plot Scales and Axes"><menuentrytitle>Defining Plot Scales and Axes</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Labeling the Graph"><menuentrytitle>Labeling the Graph</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Drawing the Graph"><menuentrytitle>Drawing the Graph</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Finishing Up"><menuentrytitle>Finishing Up</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="In Case of Error"><menuentrytitle>In Case of Error</menuentrytitle><menuentrydescrip/></menuentry><menuline/><menuline>Advanced Use of PLplot</menuline><menuline/><menuentry node="Command Line Arguments"><menuentrytitle>Command Line Arguments</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Output Devices"><menuentrytitle>Output Devices</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Adding FreeType Library Support to Bitmap Drivers"><menuentrytitle>Adding FreeType Library Support to Bitmap Drivers</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="View Surfaces; [Sub-]Pages; Viewports and Windows"><menuentrytitle>View Surfaces, (Sub-)Pages, Viewports and Windows</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Setting Line Attributes"><menuentrytitle>Setting Line Attributes</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Setting the Area Fill Pattern"><menuentrytitle>Setting the Area Fill Pattern</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Setting Color"><menuentrytitle>Setting Color</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Setting Character Attributes"><menuentrytitle>Setting Character Attributes</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Three Dimensional Surface Plots"><menuentrytitle>Three Dimensional Surface Plots</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Contour and Shade Plots"><menuentrytitle>Contour and Shade Plots</menuentrytitle><menuentrydescrip/></menuentry><menuline/><menuline>The PLplot Display Driver Family</menuline><menuline/><menuentry node="The Xwin Driver [X-Windows]"><menuentrytitle>The Xwin Driver (X-Windows)</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="The GCW Driver [Gnome 2]"><menuentrytitle>The GCW Driver (Gnome 2)</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="The Tk Driver"><menuentrytitle>The Tk Driver</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="The AquaTerm Driver [Mac OS X]"><menuentrytitle>The AquaTerm Driver (Mac OS X)</menuentrytitle><menuentrydescrip/></menuentry><menuline/><menuline>The PLplot Output Driver Family</menuline><menuline/><menuentry node="The Postscript Driver"><menuentrytitle>The Postscript Driver</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="The GD Driver"><menuentrytitle>The GD Driver</menuentrytitle><menuentrydescrip/></menuentry><menuline/><menuline>A C++ Interface for PLplot</menuline><menuline/><menuentry node="Motivation for the C++ Interface"><menuentrytitle>Motivation for the C++ Interface</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Design of the PLplot C++ Interface"><menuentrytitle>Design of the PLplot C++ Interface</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Specializing the PLplot C++ Interface"><menuentrytitle>Specializing the PLplot C++ Interface</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Status of the C++ Interface"><menuentrytitle>Status of the C++ Interface</menuentrytitle><menuentrydescrip/></menuentry><menuline/><menuline>Using PLplot from Tcl</menuline><menuline/><menuentry node="Motivation for the Tcl Interface to PLplot"><menuentrytitle>Motivation for the Tcl Interface to PLplot</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Overview of the Tcl Language Binding"><menuentrytitle>Overview of the Tcl Language Binding</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="The PLplot Tcl Matrix Extension"><menuentrytitle>The PLplot Tcl Matrix Extension</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Contouring and Shading from Tcl"><menuentrytitle>Contouring and Shading from Tcl</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Understanding the Performance Characteristics of Tcl"><menuentrytitle>Understanding the Performance Characteristics of Tcl</menuentrytitle><menuentrydescrip/></menuentry><menuline/><menuline>Building an Extended WISH</menuline><menuline/><menuentry node="Introduction to Tcl"><menuentrytitle>Introduction to Tcl</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Introduction to Tk"><menuentrytitle>Introduction to Tk</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Introduction to [incr Tcl]"><menuentrytitle>Introduction to [incr Tcl]</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="PLplot Extensions to Tcl"><menuentrytitle>PLplot Extensions to Tcl</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Custom Extensions to Tcl"><menuentrytitle>Custom Extensions to Tcl</menuentrytitle><menuentrydescrip/></menuentry><menuline/><menuline>Embedding Plots in Graphical User Interfaces</menuline><menuline/><menuentry node="The PlplotCanvas Widget for Gnome/GTK Applications"><menuentrytitle>The PlplotCanvas Widget for Gnome/GTK Applications</menuentrytitle><menuentrydescrip/></menuentry><menuline/><menuline>Bibliography</menuline><menuline/><menuentry node="References"><menuentrytitle>References</menuentrytitle><menuentrydescrip/></menuentry><menuline/><menuline>The Common API for PLplot</menuline><menuline/><menuentry node="pl_setcontlabelformat; Set&#10;format of numerical label for contours"><menuentrytitle>pl_setcontlabelformat: Set
format of numerical label for contours</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="pl_setcontlabelparam; Set parameters of&#10;contour labelling other than format of numerical label"><menuentrytitle>pl_setcontlabelparam: Set parameters of
contour labelling other than format of numerical label</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="pladv; Advance the [sub-]page"><menuentrytitle>pladv: Advance the (sub-)page</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plaxes; Draw a box with axes; etc_ with arbitrary&#10;origin&#10;    "><menuentrytitle>
      plaxes: Draw a box with axes, etc. with arbitrary
origin
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plbin; Plot a histogram from binned data&#10;    "><menuentrytitle>
      plbin: Plot a histogram from binned data
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="plbop; Begin a new page"><menuentrytitle>plbop: Begin a new page</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="plbox; Draw a box with axes; etc"><menuentrytitle>plbox: Draw a box with axes, etc</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plbox3; Draw a box with axes; etc; in 3-d&#10;    "><menuentrytitle>
      plbox3: Draw a box with axes, etc, in 3-d
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plcalc_world; Calculate world coordinates and&#10;corresponding window index from relative device coordinates&#10;    "><menuentrytitle>
      plcalc_world: Calculate world coordinates and
corresponding window index from relative device coordinates
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plclear; Clear current [sub]page&#10;    "><menuentrytitle>
      plclear: Clear current (sub)page
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plcol0; Set color; map0&#10;    "><menuentrytitle>
      plcol0: Set color, map0
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plcol1; Set color; map1&#10;    "><menuentrytitle>
      plcol1: Set color, map1
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plcont; Contour plot&#10;    "><menuentrytitle>
      plcont: Contour plot
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plcpstrm; Copy state parameters from the&#10;reference stream to the current stream&#10;    "><menuentrytitle>
      plcpstrm: Copy state parameters from the
reference stream to the current stream
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plend; End plotting session&#10;    "><menuentrytitle>
      plend: End plotting session
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plend1; End plotting session for current stream&#10;    "><menuentrytitle>
      plend1: End plotting session for current stream
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plenv0; Same as plenv but if in multiplot&#10;      mode does not advance the subpage; instead clears it_&#10;    "><menuentrytitle>
      plenv0: Same as <code>plenv</code> but if in multiplot
      mode does not advance the subpage, instead clears it.
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plenv; Set up standard window and draw box&#10;    "><menuentrytitle>
      plenv: Set up standard window and draw box
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      pleop; Eject current page&#10;    "><menuentrytitle>
      pleop: Eject current page
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plerrx; Draw x error bar&#10;    "><menuentrytitle>
      plerrx: Draw x error bar
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plerry; Draw y error bar&#10;    "><menuentrytitle>
      plerry: Draw y error bar
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plfamadv; Advance to the next family file on the&#10;next new page&#10;    "><menuentrytitle>
      plfamadv: Advance to the next family file on the
next new page
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plfill; Draw filled polygon&#10;    "><menuentrytitle>
      plfill: Draw filled polygon
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plfill3; Draw filled polygon in 3D&#10;    "><menuentrytitle>
      plfill3: Draw filled polygon in 3D
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plflush; Flushes the output stream&#10;    "><menuentrytitle>
      plflush: Flushes the output stream
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plfont; Set character font&#10;    "><menuentrytitle>
      plfont: Set character font
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plfontld; Load character font&#10;    "><menuentrytitle>
      plfontld: Load character font
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgchr; Get character default height and current&#10;[scaled] height&#10;    "><menuentrytitle>
      plgchr: Get character default height and current
(scaled) height
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgcol0; Returns 8-bit RGB values for given color&#10;from color map0&#10;    "><menuentrytitle>
      plgcol0: Returns 8-bit RGB values for given color
from color map0
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgcolbg;  Returns the background color&#10;[cmap0[0]] by 8-bit RGB value&#10;    "><menuentrytitle>
      plgcolbg:  Returns the background color
(cmap0[0]) by 8-bit RGB value
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgcompression; Get the current&#10;      device-compression setting&#10;    "><menuentrytitle>
      plgcompression: Get the current
      device-compression setting
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgdev; Get the current device [keyword] name&#10;    "><menuentrytitle>
      plgdev: Get the current device (keyword) name
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgdidev; Get parameters that define current&#10;      device-space window&#10;    "><menuentrytitle>
      plgdidev: Get parameters that define current
      device-space window
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgdiori; Get plot orientation&#10;    "><menuentrytitle>
      plgdiori: Get plot orientation
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgdiplt; Get parameters that define current&#10;      plot-space window&#10;    "><menuentrytitle>
      plgdiplt: Get parameters that define current
      plot-space window
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgfam; Get family file parameters&#10;    "><menuentrytitle>
      plgfam: Get family file parameters
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgfci; Get FCI [font characterization integer]&#10;    "><menuentrytitle>
      plgfci: Get FCI (font characterization integer)
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgfnam; Get output file name&#10;    "><menuentrytitle>
      plgfnam: Get output file name
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plglevel; Get the [current] run level&#10;    "><menuentrytitle>
      plglevel: Get the (current) run level
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgpage; Get page parameters&#10;    "><menuentrytitle>
      plgpage: Get page parameters
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgra; Switch to graphics screen&#10;    "><menuentrytitle>
      plgra: Switch to graphics screen
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgriddata; Grid data from irregularly sampled&#10;      data&#10;    "><menuentrytitle>
      plgriddata: Grid data from irregularly sampled
      data
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgspa; Get current subpage parameters&#10;    "><menuentrytitle>
      plgspa: Get current subpage parameters
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgstrm; Get current stream number&#10;    "><menuentrytitle>
      plgstrm: Get current stream number
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgver; Get the current library version number&#10;    "><menuentrytitle>
      plgver: Get the current library version number
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgvpd; Get viewport limits in normalized&#10;device coordinates&#10;    "><menuentrytitle>
      plgvpd: Get viewport limits in normalized
device coordinates
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgvpw; Get viewport limits in world coordinates&#10;    "><menuentrytitle>
      plgvpw: Get viewport limits in world coordinates
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgxax; Get x axis parameters&#10;    "><menuentrytitle>
      plgxax: Get x axis parameters
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgyax; Get y axis parameters&#10;    "><menuentrytitle>
      plgyax: Get y axis parameters
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgzax; Get z axis parameters&#10;    "><menuentrytitle>
      plgzax: Get z axis parameters
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plhist; Plot a histogram from unbinned data&#10;    "><menuentrytitle>
      plhist: Plot a histogram from unbinned data
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plhlsrgb; Convert HLS color to RGB&#10;    "><menuentrytitle>
      plhlsrgb: Convert HLS color to RGB
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plinit; Initialize PLplot&#10;    "><menuentrytitle>
      plinit: Initialize PLplot
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      pljoin; Draw a line between two points&#10;    "><menuentrytitle>
      pljoin: Draw a line between two points
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      pllab; Simple routine to write labels&#10;    "><menuentrytitle>
      pllab: Simple routine to write labels
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      pllightsource; Sets the 3D position of the light&#10;source&#10;    "><menuentrytitle>
      pllightsource: Sets the 3D position of the light
source
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plline; Draw a line&#10;    "><menuentrytitle>
      plline: Draw a line
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plline3; Draw a line in 3 space&#10;    "><menuentrytitle>
      plline3: Draw a line in 3 space
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      pllsty; Select line style&#10;    "><menuentrytitle>
      pllsty: Select line style
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plmesh; Plot surface mesh&#10;    "><menuentrytitle>
      plmesh: Plot surface mesh
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plmeshc; Magnitude colored plot surface mesh with contour_&#10;    "><menuentrytitle>
      plmeshc: Magnitude colored plot surface mesh with contour.
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plmkstrm; Creates a new stream and makes it the&#10;default&#10;    "><menuentrytitle>
      plmkstrm: Creates a new stream and makes it the
default
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plmtex; Write text relative to viewport boundaries&#10;    "><menuentrytitle>
      plmtex: Write text relative to viewport boundaries
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plot3d; Plot 3-d surface plot&#10;    "><menuentrytitle>
      plot3d: Plot 3-d surface plot
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plot3dc; Magnitude colored plot surface with contour_&#10;    "><menuentrytitle>
      plot3dc: Magnitude colored plot surface with contour.
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plparseopts; Parse command-line arguments&#10;    "><menuentrytitle>
      plparseopts: Parse command-line arguments
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plpat; Set area fill pattern&#10;    "><menuentrytitle>
      plpat: Set area fill pattern
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plpoin; Plots a character at the specified points&#10;    "><menuentrytitle>
      plpoin: Plots a character at the specified points
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plpoin3;  Plots a character at the specified&#10;      points in 3 space&#10;    "><menuentrytitle>
      plpoin3:  Plots a character at the specified
      points in 3 space
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plpoly3; Draw a polygon in 3 space&#10;    "><menuentrytitle>
      plpoly3: Draw a polygon in 3 space
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plprec; Set precision in numeric labels&#10;    "><menuentrytitle>
      plprec: Set precision in numeric labels
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plpsty; Select area fill pattern&#10;    "><menuentrytitle>
      plpsty: Select area fill pattern
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plptex; Write text inside the viewport&#10;    "><menuentrytitle>
      plptex: Write text inside the viewport
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plreplot; Replays contents of plot buffer to&#10;current device/file&#10;    "><menuentrytitle>
      plreplot: Replays contents of plot buffer to
current device/file
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plrgbhls; Convert RGB color to HLS&#10;    "><menuentrytitle>
      plrgbhls: Convert RGB color to HLS
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plschr; Set character size&#10;    "><menuentrytitle>
      plschr: Set character size
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plscmap0; Set color map0 colors by 8-bit RGB&#10;values&#10;    "><menuentrytitle>
      plscmap0: Set color map0 colors by 8-bit RGB
values
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plscmap0n; Set number of colors in color map0&#10;    "><menuentrytitle>
      plscmap0n: Set number of colors in color map0
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plscmap1; Set color map1 colors using 8-bit RGB&#10;values&#10;    "><menuentrytitle>
      plscmap1: Set color map1 colors using 8-bit RGB
values
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plscmap1l; Set color map1 colors using a&#10;piece-wise linear relationship&#10;    "><menuentrytitle>
      plscmap1l: Set color map1 colors using a
piece-wise linear relationship
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plscmap1n; Set number of colors in color map1&#10;    "><menuentrytitle>
      plscmap1n: Set number of colors in color map1
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plscol0;  Set a given color from color map0 by 8&#10;bit RGB value&#10;    "><menuentrytitle>
      plscol0:  Set a given color from color map0 by 8
bit RGB value
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plscolbg; Set the background color&#10;by 8-bit RGB value&#10;    "><menuentrytitle>
      plscolbg: Set the background color
by 8-bit RGB value
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plscolor; Used to globally turn color output on/off&#10;    "><menuentrytitle>
      plscolor: Used to globally turn color output on/off
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plscompression; Set device-compression level&#10;    "><menuentrytitle>
      plscompression: Set device-compression level
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsdev; Set the device [keyword] name&#10;    "><menuentrytitle>
      plsdev: Set the device (keyword) name
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsdidev; Set parameters that define current&#10;      device-space window&#10;    "><menuentrytitle>
      plsdidev: Set parameters that define current
      device-space window
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsdimap; Set up transformation from metafile&#10;coordinates&#10;    "><menuentrytitle>
      plsdimap: Set up transformation from metafile
coordinates
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsdiori; Set plot orientation&#10;    "><menuentrytitle>
      plsdiori: Set plot orientation
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsdiplt; Set parameters that define current&#10;      plot-space window&#10;    "><menuentrytitle>
      plsdiplt: Set parameters that define current
      plot-space window
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsdiplz; Set parameters incrementally [zoom mode]&#10;      that define current plot-space window&#10;    "><menuentrytitle>
      plsdiplz: Set parameters incrementally (zoom mode)
      that define current plot-space window
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsesc; Set the escape character for text strings&#10;    "><menuentrytitle>
      plsesc: Set the escape character for text strings
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsetopt; Set any command-line option&#10;    "><menuentrytitle>
      plsetopt: Set any command-line option
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsfam; Set family file parameters&#10;    "><menuentrytitle>
      plsfam: Set family file parameters
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsfci; Set FCI [font characterization integer]&#10;    "><menuentrytitle>
      plsfci: Set FCI (font characterization integer)
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsfnam; Set output file name&#10;    "><menuentrytitle>
      plsfnam: Set output file name
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plshades; Shade regions on the basis of value&#10;    "><menuentrytitle>
      plshades: Shade regions on the basis of value
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plshade;  Shade individual region on the basis of value&#10;    "><menuentrytitle>
      plshade:  Shade individual region on the basis of value
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plshade1; Shade individual region on the basis of value&#10;    "><menuentrytitle>
      plshade1: Shade individual region on the basis of value
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsmaj; Set length of major ticks&#10;    "><menuentrytitle>
      plsmaj: Set length of major ticks
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsmem; Set the memory area to be plotted&#10;    "><menuentrytitle>
      plsmem: Set the memory area to be plotted
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsmin; Set length of minor ticks&#10;    "><menuentrytitle>
      plsmin: Set length of minor ticks
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsori; Set orientation&#10;    "><menuentrytitle>
      plsori: Set orientation
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plspage; Set page parameters&#10;    "><menuentrytitle>
      plspage: Set page parameters
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plspause; Set the pause [on end-of-page] status&#10;    "><menuentrytitle>
      plspause: Set the pause (on end-of-page) status
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsstrm; Set current output stream&#10;    "><menuentrytitle>
      plsstrm: Set current output stream
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plssub; Set the number of subpages in x and y&#10;    "><menuentrytitle>
      plssub: Set the number of subpages in x and y
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plssym; Set symbol size&#10;    "><menuentrytitle>
      plssym: Set symbol size
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plstar; Initialization&#10;    "><menuentrytitle>
      plstar: Initialization
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plstart; Initialization&#10;    "><menuentrytitle>
      plstart: Initialization
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plstripa; Add a point to a stripchart&#10;    "><menuentrytitle>
      plstripa: Add a point to a stripchart
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plstripc; Create a 4-pen stripchart&#10;    "><menuentrytitle>
      plstripc: Create a 4-pen stripchart
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plstripd; Deletes and releases memory used by a&#10;stripchart&#10;    "><menuentrytitle>
      plstripd: Deletes and releases memory used by a
stripchart
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plstyl; Set line style&#10;    "><menuentrytitle>
      plstyl: Set line style
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsurf3d; Plot shaded 3-d surface plot&#10;    "><menuentrytitle>
      plsurf3d: Plot shaded 3-d surface plot
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsvect; Set arrow style for vector plots&#10;    "><menuentrytitle>
      plsvect: Set arrow style for vector plots
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsvpa; Specify viewport in absolute coordinates&#10;    "><menuentrytitle>
      plsvpa: Specify viewport in absolute coordinates
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsxax; Set x axis parameters&#10;    "><menuentrytitle>
      plsxax: Set x axis parameters
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsyax; Set y axis parameters&#10;    "><menuentrytitle>
      plsyax: Set y axis parameters
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsym; Plots a symbol at the specified points&#10;    "><menuentrytitle>
      plsym: Plots a symbol at the specified points
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plszax; Set z axis parameters&#10;    "><menuentrytitle>
      plszax: Set z axis parameters
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      pltext; Switch to text screen&#10;    "><menuentrytitle>
      pltext: Switch to text screen
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plvasp; Specify viewport using aspect ratio only&#10;    "><menuentrytitle>
      plvasp: Specify viewport using aspect ratio only
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plvect; Vector plot&#10;    "><menuentrytitle>
      plvect: Vector plot
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plvpas; Specify viewport using coordinates and aspect ratio&#10;    "><menuentrytitle>
      plvpas: Specify viewport using coordinates and aspect ratio
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plvpor; Specify viewport using coordinates&#10;    "><menuentrytitle>
      plvpor: Specify viewport using coordinates
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plvsta; Select standard viewport&#10;    "><menuentrytitle>
      plvsta: Select standard viewport
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plw3d; Set up window for 3-d plotting&#10;    "><menuentrytitle>
      plw3d: Set up window for 3-d plotting
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plwid; Set pen width&#10;    "><menuentrytitle>
      plwid: Set pen width
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plwind; Specify world coordinates of viewport boundaries&#10;    "><menuentrytitle>
      plwind: Specify world coordinates of viewport boundaries
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plxormod; Enter or leave xor mode&#10;    "><menuentrytitle>
      plxormod: Enter or leave xor mode
    </menuentrytitle><menuentrydescrip/></menuentry><menuline/><menuline>The Specialized C API for PLplot</menuline><menuline/><menuentry node="&#10;      plP_checkdriverinit; Checks to see if any&#10;      of the specified drivers have been initialized&#10;    "><menuentrytitle>
      plP_checkdriverinit: Checks to see if any
      of the specified drivers have been initialized
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plP_getinitdriverlist; Get the initialized-driver&#10;      list&#10;    "><menuentrytitle>
      plP_getinitdriverlist: Get the initialized-driver
      list
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plabort; Error abort&#10;    "><menuentrytitle>
      plabort: Error abort
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plexit; Error exit&#10;    "><menuentrytitle>
      plexit: Error exit
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgfile; Get output file handle&#10;    "><menuentrytitle>
      plgfile: Get output file handle
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsabort; Set abort handler&#10;    "><menuentrytitle>
      plsabort: Set abort handler
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsexit; Set exit handler&#10;    "><menuentrytitle>
      plsexit: Set exit handler
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsfile; Set output file handle&#10;    "><menuentrytitle>
      plsfile: Set output file handle
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      pltr0; Identity transformation for grid to world&#10;mapping&#10;    "><menuentrytitle>
      pltr0: Identity transformation for grid to world
mapping
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      pltr1; Linear interpolation for grid to world&#10;mapping using singly dimensioned coord arrays&#10;    "><menuentrytitle>
      pltr1: Linear interpolation for grid to world
mapping using singly dimensioned coord arrays
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      pltr2; Linear interpolation for grid to world&#10;      mapping using doubly dimensioned coord arrays [column&#10;      dominant; as per normal C 2d arrays]&#10;    "><menuentrytitle>
      pltr2: Linear interpolation for grid to world
      mapping using doubly dimensioned coord arrays (column
      dominant, as per normal C 2d arrays)
    </menuentrytitle><menuentrydescrip/></menuentry><menuline/><menuline>The Specialized Fortran API for PLplot</menuline><menuline/><menuentry node="&#10;      plcon0; Contour plot; identity mapping for fortran&#10;    "><menuentrytitle>
      plcon0: Contour plot, identity mapping for fortran
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plcon1; Contour plot; general 1-d mapping for&#10;fortran&#10;    "><menuentrytitle>
      plcon1: Contour plot, general 1-d mapping for
fortran
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plcon2; Contour plot; general 2-d mapping for&#10;fortran&#10;    "><menuentrytitle>
      plcon2: Contour plot, general 2-d mapping for
fortran
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plcont; Contour plot; fixed linear mapping for&#10;fortran&#10;    "><menuentrytitle>
      plcont: Contour plot, fixed linear mapping for
fortran
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plvec0; Vector plot; identity mapping for fortran&#10;    "><menuentrytitle>
      plvec0: Vector plot, identity mapping for fortran
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plvec1; Vector plot; general 1-d mapping for&#10;fortran&#10;    "><menuentrytitle>
      plvec1: Vector plot, general 1-d mapping for
fortran
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plvec2; Vector plot; general 2-d mapping for&#10;fortran&#10;    "><menuentrytitle>
      plvec2: Vector plot, general 2-d mapping for
fortran
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plvect; Vector plot; fixed linear mapping for&#10;fortran&#10;    "><menuentrytitle>
      plvect: Vector plot, fixed linear mapping for
fortran
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plmesh; Plot surface mesh for fortran&#10;    "><menuentrytitle>
      plmesh: Plot surface mesh for fortran
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plot3d; Plot 3-d surface plot for fortran&#10;    "><menuentrytitle>
      plot3d: Plot 3-d surface plot for fortran
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plparseopts; parse arguments for fortran&#10;    "><menuentrytitle>
      plparseopts: parse arguments for fortran
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsesc; Set the escape character for text strings&#10;for fortran&#10;    "><menuentrytitle>
      plsesc: Set the escape character for text strings
for fortran
    </menuentrytitle><menuentrydescrip/></menuentry><menuline/><menuline>API compatibility definition</menuline><menuline/><menuentry node="&#10;      What is in the API?&#10;    "><menuentrytitle>
      What is in the API?
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      Regression test for backwards compatibility&#10;    "><menuentrytitle>
      Regression test for backwards compatibility
    </menuentrytitle><menuentrydescrip/></menuentry><menuline/><menuline>Obsolete/Deprecated API for PLplot</menuline><menuline/><menuentry node="&#10;      plclr; Eject current page&#10;    "><menuentrytitle>
      plclr: Eject current page
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plcol; Set color&#10;    "><menuentrytitle>
      plcol: Set color
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plhls; Set current color by HLS&#10;    "><menuentrytitle>
      plhls: Set current color by HLS
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plHLS_RGB; Convert HLS color to RGB&#10;    "><menuentrytitle>
      plHLS_RGB: Convert HLS color to RGB
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plpage; Begin a new page&#10;    "><menuentrytitle>
      plpage: Begin a new page
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plrgb; Set line color by red; green&#10;    "><menuentrytitle>
      plrgb: Set line color by red, green
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plrgb1; Set line color by 8-bit RGB values&#10;    "><menuentrytitle>
      plrgb1: Set line color by 8-bit RGB values
    </menuentrytitle><menuentrydescrip/></menuentry><menuline/><menuline>Notes for each Operating System that We Support</menuline><menuline/><menuentry node="Linux/Unix Notes"><menuentrytitle>Linux/Unix Notes</menuentrytitle><menuentrydescrip/></menuentry><menuline/></detailmenu></menu><node name="Introduction" previous="Top" next="Simple Use of PLplot" up="Top"/><chapter>Introduction</chapter><menu><menuentry node="The PLplot Plotting Library"><menuentrytitle>The PLplot Plotting Library</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Getting a Copy of the PLplot Package"><menuentrytitle>Getting a Copy of the PLplot Package</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Installing and Using the PLplot Library"><menuentrytitle>Installing and Using the PLplot Library</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Organization of this Manual"><menuentrytitle>Organization of this Manual</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Copyrights"><menuentrytitle>Copyrights</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Credits"><menuentrytitle>Credits</menuentrytitle><menuentrydescrip/></menuentry></menu><node name="The PLplot Plotting Library" next="Getting a Copy of the PLplot Package" up="Introduction"/><section>The PLplot Plotting Library</section><para> PLplot is a library of C functions that are useful for making
scientific plots from programs written in C, C++, Fortran, Octave, Python,
and Tcl/Tk. The PLplot project is being developed by a world-wide team who
interact via the facilities provided by SourceForge (<uref url="http://sourceforge.net/projects/plplot">http://sourceforge.net/projects/plplot</uref>)
</para><para> The PLplot library can be used to create standard x-y plots, semi-log
plots, log-log plots, contour plots, 3D plots, shade (gray-scale and color)
plots, mesh plots, bar charts and pie charts. Multiple graphs (of the same
or different sizes) may be placed on a single page with multiple lines in
each graph. Different line styles, widths and colors are supported. A
virtually infinite number of distinct area fill patterns may be used. There
are almost 1000 characters in the extended character set.  This includes
four different fonts, the Greek alphabet and a host of mathematical,
musical, and other symbols.  The fonts can be scaled to any desired size.  A
variety of output devices and file formats are supported including a
metafile format which can be subsequently rendered to any device/file.  New
devices and file formats can be easily added by writing a driver routine.
For example, we have recently added PNG and JPEG file drivers, and a GNOME
interactive driver is being developed. </para><para>
      PLplot was originally developed by Sze Tan of the University of
      Auckland in Fortran-77.  Many of the underlying concepts used in the
      PLplot package are based on ideas used in Tim Pearson's PGPLOT
      package.  Sze Tan writes:
    <quotation><para>
	I'm rather amazed how far PLPLOT has traveled given its origins
	etc. I first used PGPLOT on the Starlink VAX computers while I was
	a graduate student at the Mullard Radio Astronomy Observatory in
	Cambridge from 1983-1987. At the beginning of 1986, I was to give a
	seminar within the department at which I wanted to have a computer
	graphics demonstration on an IBM PC which was connected to a
	completely non-standard graphics card. Having about a week to do
	this and not having any drivers for the card, I started from the
	back end and designed PLPLOT to be such that one only needed to be
	able to draw a line or a dot on the screen in order to do arbitrary
	graphics.  The application programmer's interface was made as
	similar as possible to PGPLOT so that I could easily port my
	programs from the VAX to the PC.  The kernel of PLPLOT was modeled
	on PGPLOT but the code is not derived from it.
      </para></quotation>
    </para><para>
      The C version of PLplot was developed by Tony Richardson on a
      Commodore Amiga.  In the process, several of the routines were
      rewritten to improve efficiency and some new features added.  The
      program structure was changed somewhat to make it easier to
      incorporate new devices.  Additional features were added to allow
      three-dimensional plotting and better access to low-level routines.
    </para><para>
      PLplot 5.0 is a continuation of our work on PLplot 4.0, which never
      got widely distributed.  It became clear during the work on 4.0 that
      in order to support an interactive driver under Unix (using Tcl/Tk),
      many additions to the basic capabilities of the package were needed.
      So without stopping to fully document and bug-fix the 4.0 additions,
      work on 5.0 was begun.  The result is that a very capable
      PLplot-based widget for the Tk toolkit has been written.  This widget
      can manipulate the plot (zoom/pan, scale, orient, change colors), as
      well dump it to any supported device.  There are help menus and user
      customization options.  These are still in the process of being
      documented.
    </para><para>
      Other changes include the introduction of a new color palette (cmap1)
      for smooth color shaded images (typically for 2d or 3d plots --
      in which color represents function intensity), support for color fill
      plots, and lots more cool stuff.  The manual has been rewritten in
      LaTeXinfo, so that there is now a printed version and an online
      (info) version of the document.  The manual is still in a state of
      flux and will be fleshed out in more detail in later updates.
    </para><para>
      Some of the improvements in PLplot 5.0 include: the addition of
      several new routines to enhance usage from Fortran and design of a
      portable C to Fortran interface.  Additional support was added for
      coordinate mappings in contour plots and some bugs fixed.  New
      labeling options were added.  The font handling code was made more
      flexible and portable.  A portable PLplot metafile driver and
      renderer was developed, allowing one to create a generic graphics
      file and do the actual rendering later (even on a different
      system).  The ability to create family output files was added.  The
      internal code structure was dramatically reworked, with elimination
      of global variables (for a more robust package), the drivers
      rewritten to improve consistency, and the ability to maintain
      multiple output streams added.  An XFig driver was added.  Other
      contributions include Clair Nielsen's (LANL) X-window driver (very
      nice for high-speed color graphics) and tektronix file viewer.  At
      present, Maurice LeBrun and Geoff Furnish are the active developers
      and maintainers of PLplot.
    </para><para>
      We have attempted to keep PLplot 5.0 backward compatible with
      previous versions of PLplot.  However, some functions are now
      obsolete, and many new ones have been added (e.g.  new contouring
      functions, variable get/set routines, functions that affect label
      appearance).  Codes written in C that use PLplot must be recompiled
      including the new header file <file>plplot.h</file> before
      linking to the new PLplot library.
    </para><para>
      PLplot is currently known to work on the following systems:
      Unix/Linux, OS/2, Mac, MS-DOS, and Win9x.  The Unix/Linux version is
      the best supported of these possibilities.
      The PLplot package is freely
      distributable, but <i>not</i> in the public domain.
      See <ref node="Copyrights" file="">Copyrights</ref> for distribution criteria.
    </para><para>
      We welcome suggestions on how to improve this code, especially in
      the form of user-contributed enhancements or bug fixes.  If PLplot
      is used in any published papers, please include an acknowledgment
      or citation of our work, which will help us to continue improving
      PLplot.  Please direct all communication to the general PLplot
      mailing list, plplot-general@lists.sourceforge.net.
    </para><node name="Getting a Copy of the PLplot Package" previous="The PLplot Plotting Library" next="Installing and Using the PLplot Library" up="Introduction"/><section>Getting a Copy of the PLplot Package</section><para>
      At present, the only mechanism we are providing for distribution of
      the PLplot is by electronic transmission over the Internet.  We
      encourage others to make it available to users without Internet
      access.  PLplot is a SourceForge project and may be obtained by
      the usual SourceForge file release and anonymous cvs access that is made
      available from links at
      <uref url="http://sourceforge.net/projects/plplot">http://sourceforge.net/projects/plplot</uref>.
    </para><node name="Installing and Using the PLplot Library" previous="Getting a Copy of the PLplot Package" next="Organization of this Manual" up="Introduction"/><section>Installing and Using the PLplot Library</section><para>
      The installation procedure is by necessity system specific;
      installation notes for each system are provided in
      <ref node="Notes for each Operating System that We Support" file="">Notes for each Operating System that We Support</ref>.
      The procedure requires that all of the routines be
      compiled and they are then usually placed in a linkable
      library.
    </para><para>
      After the library has been created, you can write your main program
      to make the desired PLplot calls.  Example programs in C, C++, and
      Fortran are included as a guide.
      Plots generated from the example programs are shown
      <uref url="http://plplot.sf.net/examples/index.html">here</uref>.
    </para><para>
      You will then need to compile your program and link it with the
      PLplot library(s).  See
      <ref node="Notes for each Operating System that We Support" file="">Notes for each Operating System that We Support</ref> for more details).
    </para><para>
      You can also use Tcl/Tk scripts or Python scripts to generate plots
      using the PLplot libraries.  Examples of these possibilities are
      also included as a guide.

    </para><node name="Organization of this Manual" previous="Installing and Using the PLplot Library" next="Copyrights" up="Introduction"/><section>Organization of this Manual</section><para>
      OLD DOCS, NEEDS UPDATING!
    </para><para>
      The PLplot library has been designed so that it is easy to write
      programs producing graphical output without having to set up large
      numbers of parameters.  However, more precise control of the results
      may be necessary, and these are accommodated by providing lower-level
      routines which change the system defaults.  The manual first describes
      the overall process of producing a graph using the high-level
      routines (see <ref node="Plotting a Simple Graph" file="">Plotting a Simple Graph</ref>).  For a discussion of
      the underlying concepts of the plotting process and an introduction
      to some of the more complex routines (see <ref node="Advanced Use of PLplot" file="">Advanced Use of PLplot</ref>).
      An alphabetical list of the user-accessible PLplot functions with
      detailed descriptions is given in the reference section of the manual
      (see <ref node="The Common API for PLplot" file="">The Common API for PLplot</ref>).
    </para><para>
      Because the PLplot kernel is written in C, standard C syntax is used
      in the description of each PLplot function.  The C and Fortran
      language interfaces are discussed in Appendix \ref{ap:lang}; look
      there if you have difficulty interpreting the call syntax as
      described in this manual.  The meaning of function (subroutine)
      arguments is typically the same regardless of whether you are calling
      from C or Fortran (but there are some exceptions to this).  The
      arguments for each function are usually specified in terms of PLFLT
      and PLINT---these are the internal PLplot representations for
      integer and floating point, and are typically a long and a float (or
      an INTEGER and a REAL, for Fortran programmers).  See Appendix
      \ref{ap:lang} for more detail.
    </para><para>
      Also, you can use PLplot from C++ just as you would from C.  No
      special classes are available at this time, just use it as any other
      procedural type library.  Simply include
      <file>plplot.h</file>, and invoke as you would from C.
    </para><para>
      The output devices supported by PLplot are listed in Appendix
      \ref{ap:dev}, along with description of the device driver--PLplot
      interface, metafile output, family files, and vt100/tek4010
      emulators.  In Appendix\ref{ap:sys} the usage and installation for
      each system supported by PLplot is described (not guaranteed to be
      entirely up-to-date; check the release notes to be sure).
    </para><node name="Copyrights" previous="Organization of this Manual" next="Credits" up="Introduction"/><section>Copyrights</section><para>
      The PLplot package may be distributed under the following terms:
    </para><example>
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public
    License along with this library; if not, write to the Free
    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
    </example><para>
      The text of this license is given in the file COPYING.LIB in the
      distribution directory.  Exceptions are noted below.
    </para><para>
      The intent behind distributing PLplot under the LGPL is to ensure
      that it continues to evolve in a positive way, while remaining freely
      distributable.  The package is considered a "library" even though
      there are associated programs, such as plrender, pltek, plserver, and
      pltcl.  The ties between these programs and the library are so great
      that I consider them as part of the library, so distribution under
      the terms of the LGPL makes sense.  Software developers are allowed
      and encouraged to use PLplot as an integral part of their product,
      even a commercial product.  Under the conditions of the LGPL,
      however, the PLplot source code must remain freely available,
      including any modifications you make to it (if you distribute a
      program based on the modified library).  Please read the full license
      for more info.
    </para><menu><menuentry node="Additional Copyrights"><menuentrytitle>Additional Copyrights</menuentrytitle><menuentrydescrip/></menuentry></menu><node name="Additional Copyrights" up="Copyrights"/><subsection>Additional Copyrights</subsection><para>
	The startup code used in argument handling
	(<file>utils/plrender.c</file> and
	<file>src/plargs.c</file>) is partially derived from
	<file>xterm.c</file> of the X11R5 distribution, and its
	copyright is reproduced here:
      </para><example>
******************************************************************************
Copyright 1987, 1988 by Digital Equipment Corporation, Maynard,
Massachusetts, and the Massachusetts Institute of Technology, Cambridge,
Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the names of Digital or MIT not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.
******************************************************************************
      </example><para>
	Any file that is explicitly marked as "public domain" is free
	from any restriction on distribution.
      </para><para>
	Any file that has a explicit copyright notice may be distributed
	under the terms of both the LGPL and whatever stated conditions
	accompany the copyright.
      </para><node name="Credits" previous="Copyrights" up="Introduction"/><section>Credits</section><para>
      PLplot 5.0 was created through the effort of many individuals and
      funding agencies.  We would like to acknowledge the support
      (financial and otherwise) of the following institutions:
    </para><itemize markchar="•"><listitem><para>
	  The Institute for Fusion Studies, University of Texas at Austin
	</para></listitem><listitem><para>
	  The Scientific and Technology Agency of Japan
	</para></listitem><listitem><para>
	  Japan Atomic Energy Research Institute
	</para></listitem><listitem><para>
	  Duke University
	</para></listitem><listitem><para>
	  Universite de Nice
	</para></listitem><listitem><para>
	  National Energy Research Supercomputer Center
	</para></listitem><listitem><para>
	  Los Alamos National Labs
	</para></listitem></itemize><para>
      Thanks are also due to the many contributors to PLplot, including:
    </para><itemize markchar="•"><listitem><para>
	  Tony Richardson: Creator of PLplot 2.6b, 3.0
	</para></listitem><listitem><para>
	  Sam Paolucci (postscript driver)
	</para></listitem><listitem><para>
	  Sam Paolucci (postscript driver)
	</para></listitem><listitem><para>
	  Tom Rokicki (IFF driver and Amiga printer driver)
	</para></listitem></itemize><para>
      Finally, thanks to all those who submitted bug reports and other
      suggestions.
    </para><node name="Simple Use of PLplot" previous="Introduction" next="Advanced Use of PLplot" up="Top"/><chapter>Simple Use of PLplot</chapter><menu><menuentry node="Plotting a Simple Graph"><menuentrytitle>Plotting a Simple Graph</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Initializing PLplot"><menuentrytitle>Initializing PLplot</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Defining Plot Scales and Axes"><menuentrytitle>Defining Plot Scales and Axes</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Labeling the Graph"><menuentrytitle>Labeling the Graph</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Drawing the Graph"><menuentrytitle>Drawing the Graph</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Finishing Up"><menuentrytitle>Finishing Up</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="In Case of Error"><menuentrytitle>In Case of Error</menuentrytitle><menuentrydescrip/></menuentry></menu><node name="Plotting a Simple Graph" next="Initializing PLplot" up="Simple Use of PLplot"/><section>Plotting a Simple Graph</section><para>
      We shall first consider plotting simple graphs showing the dependence
      of one variable upon another.  Such a graph may be composed of
      several elements:
    </para><itemize markchar="•"><listitem><para>
	  A box which defines the ranges of the variables, perhaps with
	  axes and numeric labels along its edges.
	</para></listitem><listitem><para>
	  A set of points or lines within the box showing the functional
	  dependence.
	</para></listitem><listitem><para>
	  A set of labels for the variables and a title for the graph.
	</para></listitem></itemize><para>
      In order to draw such a graph, it is necessary to call at least four
      of the PLplot functions:
    </para><enumerate><listitem><para>
	  <code>plinit</code> (<pxref node="&#10;      plinit; Initialize PLplot&#10;    " file=""/>), to initialize PLplot.
	</para></listitem><listitem><para>
	  <code>plenv</code> (<pxref node="&#10;      plenv; Set up standard window and draw box&#10;    " file=""/>), to define the range and scale of the
	  graph, and draw labels, axes, etc.
	</para></listitem><listitem><para>
	  One or more calls to <code>plline</code> (<pxref node="&#10;      plline; Draw a line&#10;    " file=""/>) or <code>plpoin</code> (<pxref node="&#10;      plpoin; Plots a character at the specified points&#10;    " file=""/>) to draw lines or points
	  as needed.  Other more complex routines include <code>plbin</code> (<pxref node="&#10;      plbin; Plot a histogram from binned data&#10;    " file=""/>) and
	  <code>plhist</code> (<pxref node="&#10;      plhist; Plot a histogram from unbinned data&#10;    " file=""/>) to draw histograms, <code>plerrx</code> (<pxref node="&#10;      plerrx; Draw x error bar&#10;    " file=""/>) and <code>plerry</code> (<pxref node="&#10;      plerry; Draw y error bar&#10;    " file=""/>) to draw
	  error-bars.
	</para></listitem><listitem><para>
	  <code>plend</code> (<pxref node="&#10;      plend; End plotting session&#10;    " file=""/>), to close the plot.
	</para></listitem></enumerate><para>
      More than one graph can be drawn on a single set of axes by making
      repeated calls to the routines listed in item 3 above.  PLplot only
      needs to be initialized once unless plotting to multiple output
      devices.
    </para><node name="Initializing PLplot" previous="Plotting a Simple Graph" next="Defining Plot Scales and Axes" up="Simple Use of PLplot"/><section>Initializing PLplot</section><para>
      Before any actual plotting calls are made, a graphics program must
      call <code>plinit</code> (<pxref node="&#10;      plinit; Initialize PLplot&#10;    " file=""/>), is the main initialization routine for PLplot.  It
      sets up all internal data structures necessary for plotting and
      initializes the output device driver.  If the output device has not
      already been specified when <code>plinit</code> (<pxref node="&#10;      plinit; Initialize PLplot&#10;    " file=""/>) is called, a list of valid
      output devices is given and the user is prompted for a choice.
      Either the device number or a device keyword is accepted.
    </para><para>
      There are several routines affecting the initialization that must
      be called <i>before</i> <code>plinit</code> (<pxref node="&#10;      plinit; Initialize PLplot&#10;    " file=""/>), if they are used.  The
      function <code>plsdev</code> (<pxref node="&#10;      plsdev; Set the device [keyword] name&#10;    " file=""/>) allows you to set the device explicitly.  The
      function <code>plsetopt</code> (<pxref node="&#10;      plsetopt; Set any command-line option&#10;    " file=""/>) allows you to set any command-line option
      internally in your code.  The function <code>plssub</code> (<pxref node="&#10;      plssub; Set the number of subpages in x and y&#10;    " file=""/>) may be called to
      divide the output device plotting area into several subpages of equal
      size, each of which can be used separately. </para><para>
      One advances to the next page (or screen) via <code>pladv</code> (<pxref node="pladv; Advance the [sub-]page" file=""/>).  If subpages
      are used, this can be used to advance to the next subpage or to a
      particular subpage.
    </para><node name="Defining Plot Scales and Axes" previous="Initializing PLplot" next="Labeling the Graph" up="Simple Use of PLplot"/><section>Defining Plot Scales and Axes</section><para>
      The function <code>plenv</code> (<pxref node="&#10;      plenv; Set up standard window and draw box&#10;    " file=""/>) is used to define the scales and axes for simple
      graphs.  <code>plenv</code> (<pxref node="&#10;      plenv; Set up standard window and draw box&#10;    " file=""/>) starts a new picture on the next subpage (or a new
      page if necessary), and defines the ranges of the variables required.
      The routine will also draw a box, axes, and numeric labels if
      requested.  The syntax for <code>plenv</code> (<pxref node="&#10;      plenv; Set up standard window and draw box&#10;    " file=""/>) is:
    </para><para>
      <quotation><para><t>
	  <b>plenv</b>
	(<i>xmin</i>, <i>xmax</i>, <i>ymin</i>, <i>ymax</i>, <i>just</i>, <i>axis</i>);</t></para></quotation>
    </para><varlist><varlistentry><term>
	  <code>xmin, xmax</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The left and right limits for the horizontal axis.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ymin, ymax</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The bottom and top limits for the vertical axis.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>just</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    This should be zero or one.  If <code>just</code> is
	    one, the scales of the x-axis and y-axis will be the same (in
	    units per millimeter); otherwise the axes are scaled
	    independently.  This parameter is useful for ensuring that
	    objects such as circles have the correct aspect ratio in the
	    final plot.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>axis</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    <code>axis</code> controls whether a box, tick marks,
	    labels, axes, and/or a grid are drawn.
	  </para><itemize markchar="•"><listitem><para>
		<code>axis</code> = -2: No box or annotation.
	      </para></listitem><listitem><para>
		<code>axis</code> = -1: Draw box only.
	      </para></listitem><listitem><para>
		<code>axis</code> = 0: Draw box, labeled with
		coordinate values around edge.
	      </para></listitem><listitem><para>
		<code>axis</code> = 1: In addition to box and labels,
		draw the two axes X = 0 and Y = 0.
	      </para></listitem><listitem><para>
		<code>axis</code> = 2: Same as
		<code>axis</code> = 1, but also draw a grid at the
		major tick interval.
	      </para></listitem><listitem><para>
		<code>axis</code> = 10: Logarithmic X axis, linear Y
		axis.
	      </para></listitem><listitem><para>
		<code>axis</code> = 11: Logarithmic X axis, linear Y
		axis and draw line Y = 0.
	      </para></listitem><listitem><para>
		<code>axis</code> = 20: Linear X axis,
		logarithmic Y axis.
	      </para></listitem><listitem><para>
		<code>axis</code> = 21: Linear X axis, logarithmic Y
		axis and draw line X = 0.
	      </para></listitem><listitem><para>
		<code>axis</code> = 30: Logarithmic X and Y axes.
	      </para></listitem></itemize></listitem></varlistentry></varlist><para>
      Note: Logarithmic axes only affect the appearance of the axes and
      their labels, so it is up to the user to compute the logarithms prior
      to passing them to <code>plenv</code> (<pxref node="&#10;      plenv; Set up standard window and draw box&#10;    " file=""/>) and any of the other routines.  Thus, if a
      graph has a 3-cycle logarithmic axis from 1 to 1000, we need to set
      <code>xmin</code> =
      <code>log_10</code>(1) = 0.0, and
      <code>xmax</code> =
      <code>log_10</code>(1000) = 3.0.
    </para><para>
      For greater control over the size of the plots, axis labeling and
      tick intervals, more complex graphs should make use of the functions
      <code>plvpor</code> (<pxref node="&#10;      plvpor; Specify viewport using coordinates&#10;    " file=""/>), <code>plvasp</code> (<pxref node="&#10;      plvasp; Specify viewport using aspect ratio only&#10;    " file=""/>), <code>plvpas</code> (<pxref node="&#10;      plvpas; Specify viewport using coordinates and aspect ratio&#10;    " file=""/>), <code>plwind</code> (<pxref node="&#10;      plwind; Specify world coordinates of viewport boundaries&#10;    " file=""/>), <code>plbox</code> (<pxref node="plbox; Draw a box with axes; etc" file=""/>), and routines for
      manipulating axis labeling <code>plgxax</code> (<pxref node="&#10;      plgxax; Get x axis parameters&#10;    " file=""/>) through <code>plszax</code> (<pxref node="&#10;      plszax; Set z axis parameters&#10;    " file=""/>).
    </para><node name="Labeling the Graph" previous="Defining Plot Scales and Axes" next="Drawing the Graph" up="Simple Use of PLplot"/><section>Labeling the Graph</section><para>
      The function <code>pllab</code> (<pxref node="&#10;      pllab; Simple routine to write labels&#10;    " file=""/>) may be called after <code>plenv</code> (<pxref node="&#10;      plenv; Set up standard window and draw box&#10;    " file=""/>) to write labels on
      the x and y axes, and at the top of the picture.  All the variables
      are character variables or constants.  Trailing spaces are removed
      and the label is centered in the appropriate field.  The syntax for
      <code>pllab</code> (<pxref node="&#10;      pllab; Simple routine to write labels&#10;    " file=""/>) is:
    </para><para>
      <quotation><para><t>
	  <b>pllab</b>
	(<i>xlbl</i>, <i>ylbl</i>, <i>toplbl</i>);</t></para></quotation>
    </para><varlist><varlistentry><term>
	<code>xlbl</code> (<samp>char *</samp>, input)
	</term><listitem><para>
	    Pointer to string with label for the X-axis (bottom of graph).
	  </para></listitem></varlistentry><varlistentry><term>
	<code>ylbl</code> (<samp>char *</samp>, input)
	</term><listitem><para>
	    Pointer to string with label for the Y-axis (left of graph).
	  </para></listitem></varlistentry><varlistentry><term>
	<code>toplbl</code> (<samp>char *</samp>, input)
	</term><listitem><para>
	    Pointer to string with label for the plot (top of picture).}
	  </para></listitem></varlistentry></varlist><para>
      More complex labels can be drawn using the function <code>plmtex</code> (<pxref node="&#10;      plmtex; Write text relative to viewport boundaries&#10;    " file=""/>).  For
      discussion of writing text in a plot see <ref node="Writing Text on a Graph" file="">Writing Text on a Graph</ref>, and
      for more detailed discussion about label generation see <ref node="Writing Text on a Graph" file="">Writing Text on a Graph</ref>.
    </para><node name="Drawing the Graph" previous="Labeling the Graph" next="Finishing Up" up="Simple Use of PLplot"/><section>Drawing the Graph</section><para>
      PLplot can draw graphs consisting of points with optional error bars,
      line segments or histograms.  Functions which perform each of these
      actions may be called after setting up the plotting environment using
      <code>plenv</code> (<pxref node="&#10;      plenv; Set up standard window and draw box&#10;    " file=""/>).  All of the following functions draw within the box defined
      by <code>plenv</code> (<pxref node="&#10;      plenv; Set up standard window and draw box&#10;    " file=""/>), and any lines crossing the boundary are clipped.
      Functions are also provided for drawing surface and contour
      representations of multi-dimensional functions.  See <ref node="Advanced Use of PLplot" file="">Advanced Use of PLplot</ref> for discussion of finer control of plot
	generation.
    </para><menu><menuentry node="Drawing Points"><menuentrytitle>Drawing Points</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Drawing Lines or Curves"><menuentrytitle>Drawing Lines or Curves</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Writing Text on a Graph"><menuentrytitle>Writing Text on a Graph</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Area Fills"><menuentrytitle>Area Fills</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="More Complex Graphs"><menuentrytitle>More Complex Graphs</menuentrytitle><menuentrydescrip/></menuentry></menu><node name="Drawing Points" next="Drawing Lines or Curves" up="Drawing the Graph"/><subsection>Drawing Points</subsection><para>
	<code>plpoin</code> (<pxref node="&#10;      plpoin; Plots a character at the specified points&#10;    " file=""/>) and <code>plsym</code> (<pxref node="&#10;      plsym; Plots a symbol at the specified points&#10;    " file=""/>) mark out <samp>n</samp> points
	<samp>(x[i], y[i])</samp> with the specified symbol.  The
	routines differ only in the interpretation of the symbol codes.
	<code>plpoin</code> (<pxref node="&#10;      plpoin; Plots a character at the specified points&#10;    " file=""/>) uses an extended ASCII representation, with the printable
	ASCII codes mapping to the respective characters in the current
	font, and the codes from 0--31 mapping to various useful
	symbols.  In <code>plsym</code> (<pxref node="&#10;      plsym; Plots a symbol at the specified points&#10;    " file=""/>) however, the code is a Hershey font code
	number.  Example programs are provided which display each of the
	symbols available using these routines.
      </para><para>
	<quotation><para><t>
	    <b>plpoin</b>(<i>n</i>, <i>x</i>, <i>y</i>, <i>code</i>);</t></para></quotation>
      </para><para>
	<quotation><para><t>
	    <b>plsym</b>
	  (<i>n</i>, <i>x</i>, <i>y</i>, <i>code</i>);</t></para></quotation>
      </para><varlist><varlistentry><term>
	    <code>n</code> (<samp>PLINT</samp>, input)
	  </term><listitem><para>
	      The number of points to plot.
	    </para></listitem></varlistentry><varlistentry><term>
	    <code>x, y</code> (<samp>PLFLT *</samp>, input)
	  </term><listitem><para>
	      Pointers to arrays of the coordinates of the
	      <samp>n</samp> points.
	    </para></listitem></varlistentry><varlistentry><term> <code>code</code> (<samp>PLINT</samp>,
	    input)
	  </term><listitem><para>
	      Code number of symbol to draw
	    </para></listitem></varlistentry></varlist><node name="Drawing Lines or Curves" previous="Drawing Points" next="Writing Text on a Graph" up="Drawing the Graph"/><subsection>Drawing Lines or Curves</subsection><para>
	PLplot provides two functions for drawing line graphs.  All lines are
	drawn in the currently selected color, style and width.  See <ref node="Setting Line Attributes" file="">Setting Line Attributes</ref> for information about changing these
	  parameters.
      </para><para>
	<code>plline</code> (<pxref node="&#10;      plline; Draw a line&#10;    " file=""/>) draws a line or curve.  The curve consists of
	<samp>n-1</samp> line segments joining the <samp>n</samp>
	points in the input arrays.  For single line segments, <code>pljoin</code> (<pxref node="&#10;      pljoin; Draw a line between two points&#10;    " file=""/>) is
	used to join two points.
      </para><para>
	<quotation><para><t>
	    <b>plline</b>
	  (<i>n</i>, <i>x</i>, <i>y</i>);</t></para></quotation>
      </para><varlist><varlistentry><term>
	    <code>n</code> (<samp>PLINT</samp>, input)
	  </term><listitem><para>
	      The number of points.
	    </para></listitem></varlistentry><varlistentry><term>
	    <code>x, y</code> (<samp>PLFLT *</samp>, input)
	  </term><listitem><para>
	      Pointers to arrays with coordinates of the <samp>n</samp>
	      points.
	    </para></listitem></varlistentry></varlist><para>
	<quotation><para><t>
	    <b>pljoin</b>
	  (<i>x1</i>, <i>y1</i>, <i>x2</i>, <i>y2</i>);</t></para></quotation>
      </para><varlist><varlistentry><term>
	    <code>x1, y1</code> (<samp>PLFLT</samp>, input)
	  </term><listitem><para>
	      Coordinates of the first point.
	    </para></listitem></varlistentry><varlistentry><term>
	    <code>x2, y2</code> (<samp>PLFLT</samp>, input)
	  </term><listitem><para>
	      Coordinates of the second point.
	    </para></listitem></varlistentry></varlist><node name="Writing Text on a Graph" previous="Drawing Lines or Curves" next="Area Fills" up="Drawing the Graph"/><subsection>Writing Text on a Graph</subsection><para>
	<code>plptex</code> (<pxref node="&#10;      plptex; Write text inside the viewport&#10;    " file=""/>) allows text to be written within the limits set by <code>plenv</code> (<pxref node="&#10;      plenv; Set up standard window and draw box&#10;    " file=""/>).
	The reference point of a text string may be located anywhere along an
	imaginary horizontal line passing through the string at half the
	height of a capital letter.  The parameter
	<code>just</code> specifies where along this line the
	reference point is located.  The string is then rotated about the
	reference point through an angle specified by the parameters
	<code>dx</code> and <code>dy</code>, so that the
	string becomes parallel to a line joining <samp>(x, y)</samp>
	to <samp>(x+dx, y+dy)</samp>.
      </para><para>
	<quotation><para><t>
	    <b>plptex</b>
	  (<i>x</i>, <i>y</i>, <i>dx</i>, <i>dy</i>, <i>just</i>, <i>text</i>);</t></para></quotation>
      </para><varlist><varlistentry><term>
	    <code>x, y</code> (<samp>PLFLT</samp>, input)
	  </term><listitem><para>
	      Coordinates of the reference point.
	    </para></listitem></varlistentry><varlistentry><term>
	    <code>dx, dy</code> (<samp>PLFLT</samp>, input)
	  </term><listitem><para>
	      These specify the angle at which the text is to be printed.
	      The text is written parallel to a line joining the points
	      <samp>(x, y)</samp> to <samp>(x+dx, y+dy)</samp>
	      on the graph.
	    </para></listitem></varlistentry><varlistentry><term>
	    <code>dx, dy</code> (<samp>PLFLT</samp>, input)
	  </term><listitem><para>
	      These specify the angle at which the text is to be printed.
	      The text is written parallel to a line joining the points
	      <samp>(x, y)</samp> to <samp>(x+dx, y+dy)</samp> on
	      the graph.
	    </para></listitem></varlistentry><varlistentry><term>
	    <code>just</code> (<samp>PLFLT</samp>, input)
	  </term><listitem><para>
	      Determines justification of the string by specifying which
	      point within the string is placed at the reference point
	      <samp>(x, y)</samp>.  This parameter is a fraction of the
	      distance along the string.  Thus if
	      <samp><code>just</code> = 0.0</samp>, the
	      reference point is at the left-hand edge of the string.  If
	      <samp><code>just</code> = 0.5</samp>, it is at
	      the center and if <samp><code>just</code> =
		1.0</samp>, it is at the right-hand edge.
	    </para></listitem></varlistentry><varlistentry><term>
	    <code>text</code> (<samp>char *</samp>, input)
	  </term><listitem><para>
	      Pointer to the string of characters to be written.
	    </para></listitem></varlistentry></varlist><node name="Area Fills" previous="Writing Text on a Graph" next="More Complex Graphs" up="Drawing the Graph"/><subsection>Area Fills</subsection><para>
	Area fills are done in the currently selected color, line style, line
	width and pattern style.
      </para><para>
	<code>plfill</code> (<pxref node="&#10;      plfill; Draw filled polygon&#10;    " file=""/>) fills a polygon.  The polygon consists of
	<samp>n</samp> vertices which define the polygon.
      </para><para>
	<quotation><para><t>
	    <b>plfill</b>
	  (<i>n</i>, <i>x</i>, <i>y</i>);</t></para></quotation>
      </para><varlist><varlistentry><term>
	    <code>n</code> (<samp>PLINT</samp>, input)
	  </term><listitem><para>
	      The number of vertices.
	    </para></listitem></varlistentry><varlistentry><term>
	    <code>x, y</code> (<samp>PLFLT *</samp>, input)
	  </term><listitem><para>
	      Pointers to arrays with coordinates of the <samp>n</samp>
	      vertices.
	    </para></listitem></varlistentry></varlist><node name="More Complex Graphs" previous="Area Fills" up="Drawing the Graph"/><subsection>More Complex Graphs</subsection><para>
	Functions <code>plbin</code> (<pxref node="&#10;      plbin; Plot a histogram from binned data&#10;    " file=""/>) and <code>plhist</code> (<pxref node="&#10;      plhist; Plot a histogram from unbinned data&#10;    " file=""/>) are provided for drawing histograms,
	and functions <code>plerrx</code> (<pxref node="&#10;      plerrx; Draw x error bar&#10;    " file=""/>) and <code>plerry</code> (<pxref node="&#10;      plerry; Draw y error bar&#10;    " file=""/>) draw error bars about specified
	points.  There are lots more too (see <ref node="The Common API for PLplot" file="">The Common API for PLplot</ref>).
      </para><node name="Finishing Up" previous="Drawing the Graph" next="In Case of Error" up="Simple Use of PLplot"/><section>Finishing Up</section><para>
      Before the end of the program, <i>always</i> call
      <code>plend</code> (<pxref node="&#10;      plend; End plotting session&#10;    " file=""/>) to close any output plot files and to free up resources.  For
      devices that have separate graphics and text modes, <code>plend</code> (<pxref node="&#10;      plend; End plotting session&#10;    " file=""/>) resets
      the device to text mode.
    </para><node name="In Case of Error" previous="Finishing Up" up="Simple Use of PLplot"/><section>In Case of Error</section><para>
      If a fatal error is encountered during execution of a PLplot routine
      then <code>plexit</code> (<pxref node="&#10;      plexit; Error exit&#10;    " file=""/>) is called.  This routine prints an error message,
      does resource recovery, and then exits.  The user may specify an error
      handler via <code>plsexit</code> that gets called before anything else is
      done, allowing either the user to abort the error termination, or
      clean up user-specific data structures before exit.
    </para><node name="Advanced Use of PLplot" previous="Simple Use of PLplot" next="Deploying programs that use PLplot" up="Top"/><chapter>Advanced Use of PLplot</chapter><para> In this chapter, we describe advanced use of PLplot. </para><menu><menuentry node="Command Line Arguments"><menuentrytitle>Command Line Arguments</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Output Devices"><menuentrytitle>Output Devices</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Adding FreeType Library Support to Bitmap Drivers"><menuentrytitle>Adding FreeType Library Support to Bitmap Drivers</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="View Surfaces; [Sub-]Pages; Viewports and Windows"><menuentrytitle>View Surfaces, (Sub-)Pages, Viewports and Windows</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Setting Line Attributes"><menuentrytitle>Setting Line Attributes</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Setting the Area Fill Pattern"><menuentrytitle>Setting the Area Fill Pattern</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Setting Color"><menuentrytitle>Setting Color</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Setting Character Attributes"><menuentrytitle>Setting Character Attributes</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Three Dimensional Surface Plots"><menuentrytitle>Three Dimensional Surface Plots</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Contour and Shade Plots"><menuentrytitle>Contour and Shade Plots</menuentrytitle><menuentrydescrip/></menuentry></menu><node name="Command Line Arguments" next="Output Devices" up="Advanced Use of PLplot"/><section>Command Line Arguments</section><para>
      PLplot supports a large number of command line arguments, but it is
      up to the user to pass these to PLplot for processing at the
      beginning of execution.
      <code>plparseopts</code> (<pxref node="&#10;      plparseopts; Parse command-line arguments&#10;    " file=""/>) is responsible for parsing
      the argument list, removing all that are recognized by PLplot, and
      taking the appropriate action before returning.  There are an
      extensive number of options available to affect this process.  The
      command line arguments recognized by PLplot are given by the -h
      option:
    </para><para>
      <example>
% x01c -h
Usage:
        ./x01c [options]

PLplot options:
    -h                   Print out this message
    -v                   Print out the PLplot library version number
    -verbose             Be more verbose than usual
    -debug               Print debugging info (implies -verbose)
    -dev name            Output device name
    -o name              Output filename
    -display name        X server to contact
    -px number           Plots per page in x
    -py number           Plots per page in y
    -geometry geom       Window size, in pixels (e.g. -geometry 400x300)
    -wplt xl,yl,xr,yr    Relative coordinates [0-1] of window into plot
    -mar margin          Margin space in relative coordinates (0 to 0.5, def 0)
    -a aspect            Page aspect ratio (def: same as output device)
    -jx justx            Page justification in x (-0.5 to 0.5, def 0)
    -jy justy            Page justification in y (-0.5 to 0.5, def 0)
    -ori orient          Plot orientation (0,2=landscape, 1,3=portrait)
    -freeaspect          Do not preserve aspect ratio on orientation swaps
    -portrait            Sets portrait mode (both orientation and aspect ratio)
    -width width         Sets pen width (1 &lt;= width &lt;= 10)
    -bg color            Background color (0=black, FFFFFF=white)
    -ncol0 n             Number of colors to allocate in cmap 0 (upper bound)
    -ncol1 n             Number of colors to allocate in cmap 1 (upper bound)
    -fam                 Create a family of output files
    -fsiz size[kKmMgG]   Output family file size in MB (e.g. -fsiz 0.5G, def MB)
    -fbeg number         First family member number on output
    -finc number         Increment between family members
    -fflen length        Family member number minimum field width
    -nopixmap            Don't use pixmaps in X-based drivers
    -db                  Double buffer X window output
    -np                  No pause between pages
    -server_name name    Main window name of PLplot server (tk driver)
    -dpi dpi             Resolution, in dots per inch (e.g. -dpi 360x360)
    -compression num     Sets compression level in supporting devices
    -drvopt option[=value][,option[=value]]* Driver specific options
</example>
    </para><para>
    The command-line options can also be set using the <code>plsetopt</code> (<pxref node="&#10;      plsetopt; Set any command-line option&#10;    " file=""/>) function, if invoked before <code>plinit</code> (<pxref node="&#10;      plinit; Initialize PLplot&#10;    " file=""/>).
    </para><para>
      Some options are may not be recognized by individual drivers.  If an option is not recognized but should be, please contact the driver author via the plplot mailing lists.
    </para><para>Many drivers have specific options that can be set using the -drvopt command line option or with <code>plsetopt</code> (<pxref node="&#10;      plsetopt; Set any command-line option&#10;    " file=""/>).  These options are documented in <ref node="The PLplot Display Driver Family" file="">The PLplot Display Driver Family</ref> and <ref node="The PLplot Output Driver Family" file="">The PLplot Output Driver Family</ref>.
    </para><node name="Output Devices" previous="Command Line Arguments" next="Adding FreeType Library Support to Bitmap Drivers" up="Advanced Use of PLplot"/><section>Output Devices</section><para>
PLplot supports a variety of output devices, via a set of device drivers.
Each driver is required to emulate a small set of low-level graphics
primitives such as initialization, line draw and page advance, as well
as be completely independent of the PLplot package as a whole.  Thus a
driver may be very simple, as in the case of the many black and white file
drivers (tektronix, etc.).  More complicated and/or color systems require a
bit more effort by the driver, with the most effort required by an output
device with a graphical user interface, including menus for screen dumps,
palette manipulation, and so forth.  At present only the tk driver does
the latter on Unix systems.  At present we aren't pursuing
a Macintosh development effort due to a lack of time and expertise, but
will assist anyone wanting to volunteer for the job.
</para><para> Note that if you always render to a PLplot metafile, you can always
<code>plrender</code> them to new devices as they become available.
</para><para>
The list of available devices presented when starting PLplot (via
<samp>plstar</samp>) is determined at compile time.  When installing PLplot you may wish
to exclude devices not available on your system in order to reduce screen
clutter.  To include a specified device, simply define the appropriate macro
constant when building PLplot (see the installation instructions for your
system).
</para><para>
The device drivers for PLplot terminal output at present are given in 
<ref node="PLplot Terminal Output Devices" file="">PLplot Terminal Output Devices</ref> while 
drivers for file output are given in
<ref node="PLplot File Output Devices" file="">PLplot File Output Devices</ref>.
The driver for OS/2 PM is available separately.  See the section on OS/2 in
the Appendix for more details.

<anchor node="PLplot Terminal Output Devices"/><para><strong>PLplot Terminal Output Devices</strong></para><multitable cols="3"><colspec width="1" colnum=""/><colspec width="1" colnum=""/><colspec width="1" colnum=""/><tbody><row><entry>Device</entry><entry>keyword</entry><entry>driver file</entry></row><row><entry>X-Window Screen</entry><entry>xwin</entry><entry>xwin.c</entry></row><row><entry>Tcl/Tk widget</entry><entry>tk</entry><entry>tk.c</entry></row><row><entry>Linux console VGA</entry><entry>vga</entry><entry>linuxvga.c</entry></row><row><entry>Xterm Window</entry><entry>xterm</entry><entry>tek.c</entry></row><row><entry>Tektronix Terminal (4010)</entry><entry>tekt</entry><entry>tek.c</entry></row><row><entry>Tektronix Terminal (4105/4107)</entry><entry>tek4107t</entry><entry>tek.c</entry></row><row><entry>MS-Kermit emulator</entry><entry>mskermit</entry><entry>tek.c</entry></row><row><entry>Versaterm vt100/tek emulator</entry><entry>versaterm</entry><entry>tek.c</entry></row><row><entry>VLT vt100/tek emulator</entry><entry>vlt</entry><entry>tek.c</entry></row><row><entry>Conex vt320/tek emulator</entry><entry>conex</entry><entry>tek.c</entry></row><row><entry>DG300 Terminal</entry><entry>dg300</entry><entry>dg300.c</entry></row><row><entry>NeXT display (unsupported)</entry><entry>nx</entry><entry>next.c</entry></row><row><entry>GNOME display</entry><entry>gnome</entry><entry>gnome.c</entry></row><row><entry>GNOME Canvas Widget / Display</entry><entry>gcw</entry><entry>gcw.c</entry></row></tbody></multitable>

<anchor node="PLplot File Output Devices"/><para><strong>PLplot File Output Devices</strong></para><multitable cols="3"><colspec width="1" colnum=""/><colspec width="1" colnum=""/><colspec width="1" colnum=""/><tbody><row><entry>Device</entry><entry>keyword</entry><entry>driver file</entry></row><row><entry>PLplot Native Meta-File</entry><entry>plmeta</entry><entry>plmeta.c</entry></row><row><entry>Tektronix File (4010)</entry><entry>tekf</entry><entry>tek.c</entry></row><row><entry>Tektronix File (4105/4107)</entry><entry>tek4107f</entry><entry>tek.c</entry></row><row><entry>PostScript File (monochrome)</entry><entry>ps</entry><entry>ps.c</entry></row><row><entry>PostScript File (color)</entry><entry>psc</entry><entry>ps.c</entry></row><row><entry>XFig file</entry><entry>xfig</entry><entry>xfig.c</entry></row><row><entry>LaserJet IIp Bitmap File </entry><entry>ljiip</entry><entry>ljiip.c</entry></row><row><entry>LaserJet II Bitmap File (150 dpi)</entry><entry>ljii</entry><entry>ljii.c</entry></row><row><entry>HP 7470 Plotter File (HPGL Cartridge Small Plotter)</entry><entry>hp7470</entry><entry>hpgl.c</entry></row><row><entry>HP 7580 Plotter File (Large Plotter)</entry><entry>hp7580</entry><entry>hpgl.c</entry></row><row><entry>HP Laser Jet, HPGL file</entry><entry>lj_hpgl</entry><entry>hpgl.c</entry></row><row><entry>Impress File</entry><entry>imp</entry><entry>impress.c</entry></row><row><entry>Portable bitmap file</entry><entry>pbm</entry><entry>pbm.c</entry></row><row><entry>Null device</entry><entry>null</entry><entry>null.c</entry></row><row><entry>JPEG file</entry><entry>jpeg</entry><entry>gd.c</entry></row><row><entry>PNG file</entry><entry>png</entry><entry>gd.c</entry></row><row><entry>Computer Graphics Metafile</entry><entry>cgm</entry><entry>cgm.c</entry></row></tbody></multitable>
</para><menu><menuentry node="Driver Functions"><menuentrytitle>Driver Functions</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="PLplot Metafiles and Plrender"><menuentrytitle>PLplot Metafiles and Plrender</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Family File Output"><menuentrytitle>Family File Output</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Interactive Output Devices"><menuentrytitle>Interactive Output Devices</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Specifying the Output Device"><menuentrytitle>Specifying the Output Device</menuentrytitle><menuentrydescrip/></menuentry></menu><node name="Driver Functions" next="PLplot Metafiles and Plrender" up="Output Devices"/><subsection>Driver Functions</subsection><para> A dispatch table is used to direct function calls to whatever driver
is chosen at run-time.  Below are listed the names of each entry in the
PLDispatchTable dispatch table struct defined in
<file>plcore.h</file>.  The entries specific to each device (defined
in <file>drivers/*.c</file>) are typically named similarly but with
pl_ replaced by a string specific for that device (the
logical order must be preserved, however). The dispatch table entries are :

      <itemize markchar="•"><listitem><para>
<samp>pl_MenuStr</samp>: Pointer to string that is printed in device menu.
	  </para></listitem><listitem><para>
<samp>pl_DevName</samp>: A short device "name" for device selection by name.
	  </para></listitem><listitem><para>
<samp>pl_type</samp>: 0 for file-oriented device, 1 for interactive
(the null driver uses -1 here).
	  </para></listitem><listitem><para>
<samp>pl_init</samp>: Initialize device.  This routine may also prompt the user
for certain device parameters or open a graphics file
(see Notes).  Called only once to set things up.  Certain
options such as familying and resolution (dots/mm) should
be set up before calling this routine (note: some drivers
ignore these).
	  </para></listitem><listitem><para>
<samp>pl_line</samp>: Draws a line between two points.
	  </para></listitem><listitem><para>
<samp>pl_polyline</samp>: Draws a polyline (no broken segments).
	  </para></listitem><listitem><para>
<samp>pl_eop</samp>: Finishes out current page (see Notes).
	  </para></listitem><listitem><para>
<samp>pl_bop</samp>: Set up for plotting on a new page. May also open a new
a new graphics file (see Notes).
	  </para></listitem><listitem><para>
<samp>pl_tidy</samp>: Tidy up. May close graphics file (see Notes).
	  </para></listitem><listitem><para>
<samp>pl_state</samp>: Handle change in PLStream state
(color, pen width, fill attribute, etc).
	  </para></listitem><listitem><para>
<samp>pl_esc</samp>: Escape function for driver-specific commands.
	  </para></listitem></itemize>
Notes: Most devices allow multi-page plots to be stored in a single graphics
file, in which case the graphics file should be opened in the pl_init()
routine, closed in pl_tidy(), and page advances done by calling pl_eop and
pl_bop() in sequence. If multi-page plots need to be stored in different
files then pl_bop() should open the file and pl_eop() should close it.  Do
NOT open files in both pl_init() and pl_bop() or close files in both
pl_eop() and pl_tidy(). It is recommended that when adding new functions to
only a certain driver, the escape function be used.  Otherwise it is
necessary to add a null routine to all the other drivers to handle the new
function. 
</para><node name="PLplot Metafiles and Plrender" previous="Driver Functions" next="Family File Output" up="Output Devices"/><subsection>PLplot Metafiles and Plrender</subsection><para>
The PLplot metafile is a way to store and transport your graphical data for
rendering at a later time or on a different system.  A PLplot metafile is
in binary format in order to speed access and keep storage costs
reasonable.  All data is stored in device-independent format (written as a
stream of bytes); the resulting file is about as portable as a tektronix
vector graphics file and only slightly larger. 
</para><para>
Each PLplot metafile begins with a header string that identifies it as
such, as well as the version number of the format since
this may change in time.  The utility for rendering the metafile,
<code>plrender</code>, verifies that the input file is indeed a valid PLplot metafile,
and that it understands the format the metafile is written in.
<code>plrender</code> is part of the PLplot package and should be built at the time of
building PLplot, and then put into your search path.  It is capable of 
high speed rendering of the graphics file, especially if the output device
can accept commands at a high rate (e.g. X windows). 
</para><para>
The commands as written by the metafile driver at present are as follows:
<itemize markchar="•"><listitem><para><samp>INITIALIZE</samp></para></listitem><listitem><para><samp>CLOSE</samp></para></listitem><listitem><para><samp>SWITCH_TO_TEXT</samp></para></listitem><listitem><para><samp>SWITCH_TO_GRAPH</samp></para></listitem><listitem><para><samp>CLEAR</samp></para></listitem><listitem><para><samp>PAGE</samp></para></listitem><listitem><para><samp>NEW_COLOR</samp></para></listitem><listitem><para><samp>NEW_WIDTH</samp></para></listitem><listitem><para><samp>LINE</samp></para></listitem><listitem><para><samp>LINETO</samp></para></listitem><listitem><para><samp>ESCAPE</samp></para></listitem><listitem><para><samp>ADVANCE</samp></para></listitem></itemize>
</para><para> 
Each command is written as a single byte, possibly followed by
additional data bytes.  The <samp>NEW_COLOR</samp> and
<samp>NEW_WIDTH</samp> commands each write 2 data bytes, the
<samp>LINETO</samp> command writes 4 data bytes, and the
<samp>LINE</samp> command writes 8 data bytes.  The most common
instruction in the typical metafile will be the <samp>LINETO</samp>
command, which draws a continuation of the previous line to the given point.
This data encoding is not quite as efficient as the tektronix format, which
uses 4 bytes instead of 5 here (1 command <samp>+</samp> 4 data),
however the PLplot encoding is far simpler to implement and more robust. The
<samp>ESCAPE</samp> function writes a second command character
(opcode) followed by an arbitrary number of data bytes depending on the
value of the opcode. Note that any data written must be in device
independent form to maintain the transportability of the metafile so
floating point numbers are not allowed. 
</para><para>
The short usage message for <code>plrender</code> is printed if one inputs
insufficient or invalid arguments, and is as follows:
<example>
% plrender

No filename specified.

Usage:
        plrender [options] [files]

plrender options:
    [-v] [-i name] [-b number] [-e number] [-p page]

PLplot options:
    [-h] [-v] [-verbose] [-debug] [-dev name] [-o name] [-display name]
    [-px number] [-py number] [-geometry geom] [-wplt xl,yl,xr,yr]
    [-mar margin] [-a aspect] [-jx justx] [-jy justy] [-ori orient]
    [-freeaspect] [-width width] [-bg color] [-ncol0 n] [-ncol1 n] [-fam]
    [-fsiz size] [-fbeg number] [-finc number] [-fflen length] [-nopixmap]
    [-db] [-np] [-server_name name] [-server_host name] [-server_port name]
    [-user name]


Type plrender -h for a full description.

</example>
</para><para>
The longer usage message goes into more detail, and is as follows:
<example>
% plrender -h

Usage:
        plrender [options] [files]

plrender options:
    -v                   Print out the plrender version number
    -i name              Input filename
    -b number            Beginning page number
    -e number            End page number
    -p page              Plot given page only

If the "-i" flag is omitted, unrecognized input will assumed to be filename
parameters.  Specifying "-" for the input or output filename means use stdin
or stdout, respectively.  See the manual for more detail.

PLplot options:
    -h                   Print out this message
    -v                   Print out the PLplot library version number
    -verbose             Be more verbose than usual
    -debug               Print debugging info (implies -verbose)
    -dev name            Output device name
    -o name              Output filename
    -display name        X server to contact
    -px number           Plots per page in x
    -py number           Plots per page in y
    -geometry geom       Window size, in pixels (e.g. -geometry 400x300)
    -wplt xl,yl,xr,yr    Relative coordinates [0-1] of window into plot
    -mar margin          Margin space in relative coordinates (0 to 0.5, def 0)
    -a aspect            Page aspect ratio (def: same as output device)
    -jx justx            Page justification in x (-0.5 to 0.5, def 0)
    -jy justy            Page justification in y (-0.5 to 0.5, def 0)
    -ori orient          Plot orientation (0,2=landscape, 1,3=portrait)
    -freeaspect          Do not preserve aspect ratio on orientation swaps
    -portrait            Sets portrait mode (both orientation and aspect ratio)
    -width width         Sets pen width (1 &lt;= width &lt;= 10)
    -bg color            Background color (0=black, FFFFFF=white)
    -ncol0 n             Number of colors to allocate in cmap 0 (upper bound)
    -ncol1 n             Number of colors to allocate in cmap 1 (upper bound)
    -fam                 Create a family of output files
    -fsiz size[kKmMgG]   Output family file size in MB (e.g. -fsiz 0.5G, def MB)
    -fbeg number         First family member number on output
    -finc number         Increment between family members
    -fflen length        Family member number minimum field width
    -nopixmap            Don't use pixmaps in X-based drivers
    -db                  Double buffer X window output
    -np                  No pause between pages
    -server_name name    Main window name of PLplot server (tk driver)
    -dpi dpi             Resolution, in dots per inch (e.g. -dpi 360x360)
    -compression num     Sets compression level in supporting devices
    -drvopt option[=value][,option[=value]]* Driver specific options
</example>
</para><para>
The options are generally self explanatory (family files are explained in
<ref node="Family File Output" file="">Family File Output</ref>).
Most of these options have default values, and for those that don't
<code>plrender</code> will prompt the user.  The
<samp>-px</samp> and <samp>-py</samp> options are
not so useful at present, because everything is scaled down by the
specified factor --- resulting in labels that are too small (future
versions of <code>plrender</code> might allow changing the label size as well). 
</para><para>
Additional options may be added in future releases.
</para><node name="Family File Output" previous="PLplot Metafiles and Plrender" next="Interactive Output Devices" up="Output Devices"/><subsection>Family File Output</subsection><para>
When sending PLplot to a file, the user has the option of generating a
family of output files for most output file drivers.
This can be valuable when generating a large amount of output, so as to not
strain network or printer facilities by processing extremely large single
files.  Each family member file can be treated as a completely independent
file.  In addition, <code>plrender</code> has the ability to process a set of
family member files as a single logical file.
</para><para> To create a family file, one must simply call <code>plsfam</code> (<pxref node="&#10;      plsfam; Set family file parameters&#10;    " file=""/>) with the
familying flag <samp>fam</samp> set to 1, and the desired maximum
member size (in bytes) in <samp>bmax</samp>.  <code>plsfam</code> (<pxref node="&#10;      plsfam; Set family file parameters&#10;    " file=""/>) also allows
you to set the current family file number.  If the current output
driver does not support familying, there will be no effect.  This call must
be made <i>before</i> calling <code>plstar</code> (<pxref node="&#10;      plstar; Initialization&#10;    " file=""/>) or <code>plstart</code> (<pxref node="&#10;      plstart; Initialization&#10;    " file=""/>). </para><para> If familying is enabled, the name given for the output file (on the
command line, in response to the <code>plstar</code> (<pxref node="&#10;      plstar; Initialization&#10;    " file=""/>) prompt, as a <code>plstart</code> (<pxref node="&#10;      plstart; Initialization&#10;    " file=""/>) argument,
or as the result of a call to <code>plsfnam</code> (<pxref node="&#10;      plsfnam; Set output file name&#10;    " file=""/>)) becomes the name template for the
family.  Thus, if you request a plmeta output file with name
<file>test-%n.plm</file>, the files actually created will be
<file>test-1.plm</file>, <file>test-2.plm</file>, and so on,
where <file>%n</file> indicates where the member number is replaced.
If there is no <file>%n</file>, then the output file becomes the
stem name and the created files will be like
<file>test.plm.1</file>, <file>test.plm.2</file>, and so on.
A new file is automatically started once the byte limit for the current file
is passed, but not until the next page break. One may insure a new file at
every page break by making the byte limit small enough.  Alternatively, if
the byte limit is large you can still insure a new file is automatically
started after a page break if you precede the call to <code>pleop</code> (<pxref node="&#10;      pleop; Eject current page&#10;    " file=""/>) with a call to
<code>plfamadv</code> (<pxref node="&#10;      plfamadv; Advance to the next family file on the&#10;next new page&#10;    " file=""/>).</para><para>
The <code>plgfam</code> (<pxref node="&#10;      plgfam; Get family file parameters&#10;    " file=""/>) routine can be used from within the user program to find
out more about the graphics file being written.  In particular, by
periodically checking the number of the member file currently being written
to, one can detect when a new member file is started.  This information
might be used in various ways; for example you could spawn a process to
automatically plrender each metafile after it is closed (perhaps during a
long simulation run) and send it off to be printed. 
</para><para> <code>plrender</code> has several options for dealing with
family files.  It can process a single member file
(<code>plrender</code>  <file>test.plm.1</file>)
or the entire family if given only the stem name
(<code>plrender</code>  <file>test.plm</file>)
It can also create family files on output, rendering to any
device that supports familying, including another metafile if desired.  The
size of member files in this case is input through the argument list, and
defaults to 1MB if unspecified (this may be changed during the PLplot
installation, however). <code>plrender</code> can also create a
single output file from a familied input metafile. </para><node name="Interactive Output Devices" previous="Family File Output" next="Specifying the Output Device" up="Output Devices"/><subsection>Interactive Output Devices</subsection><para>
Here we shall discuss briefly some of the more common interactive output
devices.  
</para><para>
Many popular terminals or terminal emulators at present have a
facility for switching between text and graphics screens.
This includes the xterm emulator under X-windows, vt100's with
Retrographics, and numerous emulators for microcomputers which have a dual
vt100/tek4010 emulation capability.  On these devices, it is possible to
switch between the text and graphics screens by surrounding your PLplot
calls by calls to <code>plgra</code> (<pxref node="&#10;      plgra; Switch to graphics screen&#10;    " file=""/>) and <code>pltext</code> (<pxref node="&#10;      pltext; Switch to text screen&#10;    " file=""/>).  This will allow your diagnostic and
informational code output to not interfere with your graphical output.
</para><para>
At present, only the xterm driver supports switching between text
and graphics screens.  The escape sequences as sent by the xterm driver
are fairly standard, however, and have worked correctly on most other
popular vt100/tek4010 emulators we've tried.
</para><para>
When using the xterm driver, hitting a RETURN will advance and clear the
page.  If indeed running from an xterm, you may resize, move, cover and
uncover the window.  The behavior of the X-window driver is quite different,
however.  First, it is much faster, as there is no tty-like handshaking
going on.  Second, a mouse click is used to advance and clear the page,
rather than a RETURN.
</para><para>
On a tektronix 4014 compatible device, you may preview tektronix output
files via the <code>pltek</code> utility.
<code>pltek</code> will let you step through the file interactively,
skipping backward or forward if desired.  The help message for
<code>pltek</code> is as follows:

<example>
% pltek
Usage: pltek filename 
At the prompt, the following replies are recognized:
   h,?    Give this help message.
    q     Quit program.
   &lt;n&gt;    Go to the specified page number.
   -&lt;n&gt;   Go back &lt;n&gt; pages.
   +&lt;n&gt;   Go forward &lt;n&gt; pages.
 &lt;Return&gt; Go to the next page.

</example>
The output device is switched to text mode before the prompt is given,
which causes the prompt to go to the vt102 window under xterm and
most vt100/tek4010 emulators.
</para><node name="Specifying the Output Device" previous="Interactive Output Devices" up="Output Devices"/><subsection>Specifying the Output Device</subsection><para>
      The main initialization routine for PLplot is <code>plinit</code> (<pxref node="&#10;      plinit; Initialize PLplot&#10;    " file=""/>), which sets up
      all internal data structures necessary for plotting and initializes
      the output device driver.  The output device can be a terminal, disk
      file, window system, pipe, or socket.  If the output device has not
      already been specified when <code>plinit</code> (<pxref node="&#10;      plinit; Initialize PLplot&#10;    " file=""/>) is called, a list of valid
      output devices is given and the user is prompted for a choice.  For
      example:
    </para><para>
      <example>
% x01c
	
Plotting Options:
 &lt; 1&gt; xwin       X-Window (Xlib)
 &lt; 2&gt; tk         Tcl/TK Window
 &lt; 3&gt; xterm      Xterm Window
 &lt; 4&gt; tekt       Tektronix Terminal (4010)
 &lt; 5&gt; tek4107t   Tektronix Terminal (4105/4107)
 &lt; 6&gt; mskermit   MS-Kermit emulator
 &lt; 7&gt; versaterm  Versaterm vt100/tek emulator
 &lt; 8&gt; vlt        VLT vt100/tek emulator
 &lt; 9&gt; plmeta     PLPLOT Native Meta-File
 &lt;10&gt; tekf       Tektronix File (4010)
 &lt;11&gt; tek4107f   Tektronix File (4105/4107)
 &lt;12&gt; ps         PostScript File (monochrome)
 &lt;13&gt; psc        PostScript File (color)
 &lt;14&gt; xfig       Xfig file
 &lt;15&gt; ljiip      LaserJet IIp/deskjet compressed graphics
 &lt;16&gt; ljii       LaserJet II Bitmap File (150 dpi)
 &lt;17&gt; null       Null device

Enter device number or keyword: </example>
    </para><para>
      Either the device number or a device keyword is accepted.  Specifying
      the device by keyword is preferable in aliases or scripts since the
      device number is dependent on the install procedure (the installer
      can choose which device drivers to include).  The device can be
      specified prior to the call to <code>plinit</code> (<pxref node="&#10;      plinit; Initialize PLplot&#10;    " file=""/>) by:

      <itemize markchar="•"><listitem><para>
	    A call to <code>plsdev</code> (<pxref node="&#10;      plsdev; Set the device [keyword] name&#10;    " file=""/>).
	  </para></listitem><listitem><para>
	    The <samp>-dev</samp> <var>device</var>
	    command line argument, if the program's command line arguments
	    are being passed to the PLplot function
	    <code>plparseopts</code> (<pxref node="&#10;      plparseopts; Parse command-line arguments&#10;    " file=""/>).
	  </para></listitem></itemize>
      
    </para><para>
      Additional startup routines <code>plstar</code> (<pxref node="&#10;      plstar; Initialization&#10;    " file=""/>) and <code>plstart</code> (<pxref node="&#10;      plstart; Initialization&#10;    " file=""/>) are available but
      these are simply front-ends to <code>plinit</code> (<pxref node="&#10;      plinit; Initialize PLplot&#10;    " file=""/>), and should be avoided.  It
      is preferable to call <code>plinit</code> (<pxref node="&#10;      plinit; Initialize PLplot&#10;    " file=""/>) directly, along with the appropriate
      setup calls, for the greater amount of control this provides (see the
      example programs for more info).
    </para><para>
      Before <code>plinit</code> (<pxref node="&#10;      plinit; Initialize PLplot&#10;    " file=""/>) is called, you may modify the number of subpages the
      output device is divided into via a call to
      <code>plssub</code>.  Subpages are useful for placing several
      graphs on a page, but all subpages are constrained to be of the same
      size.  For greater flexibility, viewports can be used (see <ref node="Defining the Viewport" file="">Defining the Viewport</ref> for more info on viewports).  The routine
	<code>pladv</code> (<pxref node="pladv; Advance the [sub-]page" file=""/>) is used to advance to a particular subpage or to the next
	subpage.  The screen is cleared (or a new piece of paper loaded) if a
	new subpage is requested when there are no subpages left on the
	current page.  When a page is divided into subpages, the default
	character, symbol and tick sizes are scaled inversely as the square
	root of the number of subpages in the vertical direction.  This is
	designed to improve readability of plot labels as the plot size
	shrinks.
    </para><para>
      PLplot has the ability to write to multiple output streams.  An
      output stream corresponds to a single logical device to which one
      plots independent of all other streams.  The function <code>plsstrm</code> (<pxref node="&#10;      plsstrm; Set current output stream&#10;    " file=""/>) is
      used to switch between streams -- you may only write to one output
      stream at a time.  At present, an output stream is not limited by the
      type of device, however, it may not be wise to attempt opening two
      terminal devices.  An example usage for the creation of multiple
      streams is as follows:
    </para><para>
      <example>#include "plplot.h"

main()
{
    int nx = 2, ny = 2;

    plssub(nx, ny);
    plsdev("xwin");
    plinit();

    plots for stream 0

    plsstrm(1);
    plssub(nx, ny);
    plsdev("plmeta");
    plsfnam("tst.plm");
    plinit();

    plots for stream 1

    plsstrm(0);

    plots for stream 0</example>
    </para><para>
      and so on, for sending output simultaneously to an X-window and a
      metafile.  The default stream corresponds to stream number zero.  At
      present, the majority of output drivers can only be used by a single
      stream (exceptions include the metafile driver and X-window driver).
      Also see example program 14 (note: only the C version is available,
      although it can be done equally well from Fortran).
    </para><para>
      At the end of a plotting program, it is important to close the
      plotting device by calling <code>plend</code> (<pxref node="&#10;      plend; End plotting session&#10;    " file=""/>).  This flushes any internal
      buffers and frees any memory that may have been allocated, for all
      open output streams.  You may call <code>plend1</code> (<pxref node="&#10;      plend1; End plotting session for current stream&#10;    " file=""/>) to close the plotting
      device for the current output stream only.  Note that if PLplot is
      initialized more than once during a program to change the output
      device, an automatic call to <code>plend1</code> (<pxref node="&#10;      plend1; End plotting session for current stream&#10;    " file=""/>) is made before the new device
      is opened for the given stream.
    </para><node name="Adding FreeType Library Support to Bitmap Drivers" previous="Output Devices" next="View Surfaces; [Sub-]Pages; Viewports and Windows" up="Advanced Use of PLplot"/><section>Adding FreeType Library Support to Bitmap Drivers</section><para>Any bitmap driver in the PLplot family should be able to use fonts
(TrueType and others) that are rendered by the FreeType library just as long
as the device supports setting an individual pixel. Note that drivers
interact with FreeType using the support routines 
<samp>plD_FreeType_init</samp>,
<samp>plD_render_freetype_text</samp>,
<samp>plD_FreeType_Destroy</samp>,
<samp>pl_set_extended_cmap0</samp>, and
<samp>pl_RemakeFreeType_text_from_buffer</samp> that are coded in
<file>plfreetype.c</file>.</para><para>The use of these support routines is exemplified by the
<file>gd.c</file> driver.  Here we make some notes to accompany
this driver which should make it easier to migrate other drivers to
use the FreeType library.  Every code fragment we mention below should be surrounded
with a <samp>#ifdef HAVE_FREETYPE...#endif</samp> to quarantine these
fragments for systems without the FreeType library.  For interactive devices that
need caching of text drawing, reference should also be made to
<file>wingcc.c</file>.</para><menu><menuentry node="Write a call back function to plot a single pixel"><menuentrytitle>Write a call back function to plot a single pixel</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Initialise FreeType"><menuentrytitle>Initialise FreeType</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Add A Command to redraw text [interactive drivers only]"><menuentrytitle>Add A Command to redraw text (interactive drivers only)</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Add Function Prototypes"><menuentrytitle>Add Function Prototypes</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Add Closing functions"><menuentrytitle>Add Closing functions</menuentrytitle><menuentrydescrip/></menuentry></menu><node name="Write a call back function to plot a single pixel" next="Initialise FreeType" up="Adding FreeType Library Support to Bitmap Drivers"/><subsection>Write a call back function to plot a single pixel</subsection><para>First, write a call back function, of type
<samp>plD_pixel_fp</samp>, which specifies how a single pixel is set
in the current colour. This can be of type static void. For example, in the
<file>gd.c</file> driver it looks like this:

<example>
void plD_pixel_gd (PLStream *pls, short x, short y)
{
png_Dev *dev=(png_Dev *)pls-&gt;dev;

   gdImageSetPixel(dev-&gt;im_out, x, y,dev-&gt;colour);
}
</example>
</para><node name="Initialise FreeType" previous="Write a call back function to plot a single pixel" next="Add A Command to redraw text [interactive drivers only]" up="Adding FreeType Library Support to Bitmap Drivers"/><subsection>Initialise FreeType</subsection><para>Next, we have to initialise the FreeType library. For the
<file>gd.c</file> driver this is done via two separate functions due
to the order that dependent information is initialised in the driver.</para><para>The "level 1" initialisation of FreeType does two things: 1) calls
<samp>plD_FreeType_init(pls)</samp>, which in turn allocates memory to
the pls-&gt;FT structure; and 2) stores the location of the call back routine.
</para><para>
<example>
void init_freetype_lv1 (PLStream *pls)
{
FT_Data *FT;

plD_FreeType_init(pls);

FT=(FT_Data *)pls-&gt;FT;
FT-&gt;pixel= (plD_pixel_fp)plD_pixel_gd;

}
</example>
</para><para>This initialisation routine is called at the end of 
<samp>plD_init_png_Dev(PLStream *pls)</samp> in the
<file>gd.c</file> driver:</para><para>
<example>
if (freetype)
   {
    pls-&gt;dev_text = 1; /* want to draw text */
    init_freetype_lv1(pls);
    FT=(FT_Data *)pls-&gt;FT;
    FT-&gt;smooth_text=smooth_text;
   }
</example>
</para><para><samp>"freetype"</samp> is a local variable which is parsed
through <samp>plParseDrvOpts</samp> to determine if the user wanted
FreeType text. In that case <samp>pls-&gt;dev_text</samp> is set to 1 to
indicate the driver will be rendering it's own text. After that, we always
use <samp>pls-&gt;dev_text</samp> to work out if we want FreeType or
not.</para><para>Similarly, <samp>"smooth_text"</samp> is a local variable passed
through <samp>plParseDrvOpts</samp> to find out if the user wants
smoothing. Since there is nothing in PLStream to track smoothing, we have to
set the FT-&gt;smooth_text flag as well at this time.</para><para>The "level 2" initialisation function initialises everything else
required for using the FreeType library but has to be called after the
screen resolution and dpi have been set. Therefore, it is called at the end
of <samp>plD_init_png()</samp>, where it looks like:

<example>
if (pls-&gt;dev_text)
   {
    init_freetype_lv2(pls);
   }
</example>
</para><para>The actual function looks like this:

<example>
static void init_freetype_lv2 (PLStream *pls)
{
png_Dev *dev=(png_Dev *)pls-&gt;dev;
FT_Data *FT=(FT_Data *)pls-&gt;FT;

FT-&gt;scale=dev-&gt;scale;
FT-&gt;ymax=dev-&gt;pngy;
FT-&gt;invert_y=1;

if (FT-&gt;smooth_text==1)
   {
    FT-&gt;ncol0_org=pls-&gt;ncol0;                                   /* save a copy of the original size of ncol0 */
    FT-&gt;ncol0_xtra=NCOLOURS-(pls-&gt;ncol1+pls-&gt;ncol0);            /* work out how many free slots we have */
    FT-&gt;ncol0_width=FT-&gt;ncol0_xtra/(pls-&gt;ncol0-1);              /* find out how many different shades of anti-aliasing we can do */
    if (FT-&gt;ncol0_width&gt;64) FT-&gt;ncol0_width=64;                 /* set a maximum number of shades */
    plscmap0n(FT-&gt;ncol0_org+(FT-&gt;ncol0_width*pls-&gt;ncol0));      /* redefine the size of cmap0 */
/* the level manipulations are to turn off the plP_state(PLSTATE_CMAP0)
 * call in plscmap0 which (a) leads to segfaults since the GD image is
 * not defined at this point and (b) would be inefficient in any case since
 * setcmap is always called later (see plD_bop_png) to update the driver
 * color palette to be consistent with cmap0. */
    {
       PLINT level_save;
       level_save = pls-&gt;level;
       pls-&gt;level = 0;
       pl_set_extended_cmap0(pls, FT-&gt;ncol0_width, FT-&gt;ncol0_org); /* call the function to add the extra cmap0 entries and calculate stuff */
       pls-&gt;level = level_save;
    }
   }

}
</example>
</para><para>FT-&gt;scale is a scaling factor to convert coordinates. This is used by
the <file>gd.c</file> and some other drivers to scale back a larger virtual page and this
eliminate the "hidden line removal bug". Set it to 1 if your device driver
doesn't use any scaling.</para><para>Some coordinate systems have zero on the bottom, others have zero on
the top. FreeType does it one way, and most everything else does it the
other. To make sure everything is working ok, we have to "flip" the
coordinates, and to do this we need to know how big in the Y dimension the
page is, and whether we have to invert the page or leave it alone.</para><para> <itemize markchar="•"><listitem><para>FT-&gt;ymax specifies the size of the page</para></listitem><listitem><para>FT-&gt;invert_y=1 tells us to invert the
y-coordinates, FT-&gt;invert_y=0 will not invert the coordinates.
</para></listitem></itemize></para><para>We also do some computational gymnastics to "expand" cmap0 if the user
wants anti-aliased text.  Basically, you have to work out how many spare
colours there are in the driver after cmap0 and cmap1 are done, then set a
few variables in FT to let the render know how many colours it's going to
have at its disposal, and call plscmap0n to resize cmap0.  The call to
<samp>pl_set_extended_cmap0</samp> does the remaining part of the
work.  Note it essential to protect that call by the
<samp>pls-&gt;level</samp> manipulations for the reasons stated. </para><node name="Add A Command to redraw text [interactive drivers only]" previous="Initialise FreeType" next="Add Function Prototypes" up="Adding FreeType Library Support to Bitmap Drivers"/><subsection>Add A Command to redraw text (interactive drivers only)</subsection><para>Plplot only caches drawing commands, not text plotting commands, so
for interactive devices which refresh their display by replaying the plot
buffer, a separate function has to be called to redraw the text.  plfreetype
knows when buffering is being used by a device driver, and will automatically
start caching text when necessary.  To redraw this cached text, a call to
<samp>pl_RemakeFreeType_text_from_buffer</samp> has to be added after the driver has called
<samp>plRemakePlot</samp>.  The following example is from <file>wingcc.c</file>.

<example>
                if (dev-&gt;waiting==1)
                {
                    plRemakePlot(pls);
                    #ifdef HAVE_FREETYPE
                    pl_RemakeFreeType_text_from_buffer(pls);
                    #endif
                 }
</example>
</para><node name="Add Function Prototypes" previous="Add A Command to redraw text [interactive drivers only]" next="Add Closing functions" up="Adding FreeType Library Support to Bitmap Drivers"/><subsection>Add Function Prototypes</subsection><para>Next, to the top of the drivers' source file add the prototype
definitions for the functions just written.

<example>
static void plD_pixel_gd (PLStream *pls, short x, short y);
static void init_freetype_lv1 (PLStream *pls);
static void init_freetype_lv2 (PLStream *pls);
</example>
</para><node name="Add Closing functions" previous="Add Function Prototypes" up="Adding FreeType Library Support to Bitmap Drivers"/><subsection>Add Closing functions</subsection><para>Finally, add a <samp>plD_FreeType_Destroy(pls)</samp> entry to
the device "tidy" function; this command deallocates memory allocated to the
FT entry in the stream, closes the FreeType library and any open fonts. It
is also a good idea to reset CMAP0 back to it's original size here if
anti-aliasing was done. For example, in the <file>gd.c</file>
driver, it looks like this:

<example>
void plD_tidy_png(PLStream *pls)
{
   fclose(pls-&gt;OutFile);

#ifdef HAVE_FREETYPE
   FT_Data *FT=(FT_Data *)pls-&gt;FT;
   plscmap0n(FT-&gt;ncol0_org);

   plD_FreeType_Destroy(pls);
#endif

   free_mem(pls-&gt;dev);
}

</example>
</para><node name="View Surfaces; [Sub-]Pages; Viewports and Windows" previous="Adding FreeType Library Support to Bitmap Drivers" next="Setting Line Attributes" up="Advanced Use of PLplot"/><section>View Surfaces, (Sub-)Pages, Viewports and Windows</section><para>There is a whole hierarchy of coordinate systems associated with
    any PLplot graph.  At the lowest level a device provides a view surface
    (coordinates in mm's) which can be a terminal screen or a sheet of paper
    in the output device.  <code>plinit</code> (<pxref node="&#10;      plinit; Initialize PLplot&#10;    " file=""/>) or <code>plstar</code> (<pxref node="&#10;      plstar; Initialization&#10;    " file=""/>) (or <code>plstart</code> (<pxref node="&#10;      plstart; Initialization&#10;    " file=""/>)) makes that
    device view surface accessible as a page or divided up into sub-pages
    (see <code>plssub</code> (<pxref node="&#10;      plssub; Set the number of subpages in x and y&#10;    " file=""/>)) which are accessed with <code>pladv</code> (<pxref node="pladv; Advance the [sub-]page" file=""/>).  Before a graph can be
    drawn for a subpage, the program must call appropriate routines in
    PLplot to define the viewport for the subpage and a window for the
    viewport. A viewport is a rectangular region of the
    <i>subpage</i> which is specified in normalized subpage
    coordinates or millimetres.  A window is a rectangular region of
    world-coordinate space which is mapped directly to its viewport. (When
    drawing a graph, the programmer usually wishes to specify the
    coordinates of the points to be plotted in terms of the values of the
    variables involved. These coordinates are called <i>world
    coordinates</i>, and may have any floating-point value
    representable by the computer.)</para><para>Although the usual choice is to have one viewport per subpage, and
    one window per viewport, each subpage can have more than one (possibly
    overlapping) viewport defined, and each viewport can have more than one
    window (more than one set of world coordinates) defined.</para><menu><menuentry node="Defining the Viewport"><menuentrytitle>Defining the Viewport</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Defining the Window"><menuentrytitle>Defining the Window</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Annotating the Viewport"><menuentrytitle>Annotating the Viewport</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Setting up a Standard Window"><menuentrytitle>Setting up a Standard Window</menuentrytitle><menuentrydescrip/></menuentry></menu><node name="Defining the Viewport" next="Defining the Window" up="View Surfaces; [Sub-]Pages; Viewports and Windows"/><subsection>Defining the Viewport</subsection><para> After defining the view surface and subpage with the appropriate
      call to <code>plinit</code> (<pxref node="&#10;      plinit; Initialize PLplot&#10;    " file=""/>) or <code>plstar</code> (<pxref node="&#10;      plstar; Initialization&#10;    " file=""/>) (or <code>plstart</code> (<pxref node="&#10;      plstart; Initialization&#10;    " file=""/>)) and a call to <code>pladv</code> (<pxref node="pladv; Advance the [sub-]page" file=""/>) it
      is necessary to define the portion of this subpage which is to be used
      for plotting the graph (the viewport).  All lines and symbols (except
      for labels drawn by <code>plbox</code> (<pxref node="plbox; Draw a box with axes; etc" file=""/>), <code>plmtex</code> (<pxref node="&#10;      plmtex; Write text relative to viewport boundaries&#10;    " file=""/>) and <code>pllab</code> (<pxref node="&#10;      pllab; Simple routine to write labels&#10;    " file=""/>)) are clipped at the
      viewport boundaries. </para><para> Viewports are created within the current subpage.  If the
      division of the output device into equally sized subpages is
      inappropriate, it is best to specify only a single subpage which
      occupies the entire output device (by using <code>plinit</code> (<pxref node="&#10;      plinit; Initialize PLplot&#10;    " file=""/>) or by setting
      <samp>nx = 1</samp> and <samp>ny = 1</samp> in <code>plstar</code> (<pxref node="&#10;      plstar; Initialization&#10;    " file=""/>)
      or <code>plstart</code> (<pxref node="&#10;      plstart; Initialization&#10;    " file=""/>)), and use one of the viewport specification subroutines
      below to place the plot in the desired position on the page. </para><para>
      There are four methods for specifying the viewport size, using the
      subroutines <code>plvpor</code> (<pxref node="&#10;      plvpor; Specify viewport using coordinates&#10;    " file=""/>), <code>plsvpa</code> (<pxref node="&#10;      plsvpa; Specify viewport in absolute coordinates&#10;    " file=""/>), <code>plvasp</code> (<pxref node="&#10;      plvasp; Specify viewport using aspect ratio only&#10;    " file=""/>), and <code>plvpas</code> (<pxref node="&#10;      plvpas; Specify viewport using coordinates and aspect ratio&#10;    " file=""/>) which are
      called like this:
    </para><para>
      <example>    plvpor(xmin, xmax, ymin, ymax);
    plsvpa(xmin, xmax, ymin, ymax);
    plvasp(aspect);
    plvpas(xmin, xmax, ymin, ymax, aspect);</example>
    </para><para>
      where in the case of <code>plvpor</code> (<pxref node="&#10;      plvpor; Specify viewport using coordinates&#10;    " file=""/>) and <code>plvpas</code> (<pxref node="&#10;      plvpas; Specify viewport using coordinates and aspect ratio&#10;    " file=""/>), the arguments are given
      in <i>normalized subpage coordinates</i> which are
      defined to run from 0.0 to 1.0 along each edge of the subpage.  Thus
      for example,
    </para><para>
      <example>    plvpor(0.0, 0.5, 0.5, 1.0);</example>
    </para><para>
      uses the top left quarter of the current subpage.
    </para><para>
      In order to get a graph of known physical size, the routine <code>plsvpa</code> (<pxref node="&#10;      plsvpa; Specify viewport in absolute coordinates&#10;    " file=""/>)
      defines the viewport in terms of absolute coordinates (millimeters)
      measured from the bottom left-hand corner of the current subpage.
      This routine should only be used when the size of the view surface is
      known, and a definite scaling is required.
    </para><para>
      The routine <code>plvasp</code> (<pxref node="&#10;      plvasp; Specify viewport using aspect ratio only&#10;    " file=""/>) gives the largest viewport with the given aspect
      ratio that fits in the current subpage (i.e. the ratio of the length
      of the y axis to that of the x axis is equal to
      <samp>aspect</samp>).  It also allocates space on the left and
      top of the viewport for labels.
    </para><para>
      The routine <code>plvpas</code> (<pxref node="&#10;      plvpas; Specify viewport using coordinates and aspect ratio&#10;    " file=""/>) gives the largest viewport with the given aspect
      ratio that fits in the specified region (specified with normalized
      subpage coordinates, as with <code>plvpor</code> (<pxref node="&#10;      plvpor; Specify viewport using coordinates&#10;    " file=""/>)).  This routine is functionally
      equivalent to <code>plvpor</code> (<pxref node="&#10;      plvpor; Specify viewport using coordinates&#10;    " file=""/>) when a natural aspect ratio is
      chosen (done by setting <samp>aspect</samp> to 0.0).  Unlike
      <code>plvasp</code> (<pxref node="&#10;      plvasp; Specify viewport using aspect ratio only&#10;    " file=""/>), this routine reserves no extra space at the edges for
      labels.
    </para><para>
      To help the user call <code>plsvpa</code> (<pxref node="&#10;      plsvpa; Specify viewport in absolute coordinates&#10;    " file=""/>) correctly, the routine <code>plgspa</code> (<pxref node="&#10;      plgspa; Get current subpage parameters&#10;    " file=""/>) is
      provided which returns the positions of the extremities of the
      current subpage measured in millimeters from the bottom left-hand
      corner of the device.  Thus, if to set up a viewport with a 10.0 mm
      margin around it within the current subpage, the following sequence
      of calls may be used:
    </para><para>
      <example>    plgspa(xmin, xmax, ymin, ymax);
    plsvpa(10.0, xmax-xmin-10.0, 10.0, ymax-ymin-10.0);</example>
    </para><para>
      A further routine <code>plvsta</code> (<pxref node="&#10;      plvsta; Select standard viewport&#10;    " file=""/>) is available which sets up a standard
      viewport within the current subpage with suitable margins on each
      side of the viewport.  This may be used for simple graphs, as it
      leaves enough room for axis labels and a title.  This standard
      viewport is that used by <code>plenv</code> (<pxref node="&#10;      plenv; Set up standard window and draw box&#10;    " file=""/>) (See <ref node="Setting up a Standard Window" file="">Setting up a Standard Window</ref>).
    </para><para>
      Another way to get a specified aspect ratio is via the routine
      <code>plsasp</code> [not!.. fix this], which sets the global
      aspect ratio and must be called prior to <code>plstar</code> (<pxref node="&#10;      plstar; Initialization&#10;    " file=""/>).  An aspect ratio
      of 0.0 corresponds to natural dimensions (i.e. fill
      the page); any positive value will give the specified aspect ratio.
      This scaling of plots is actually done in the driver, and so may not
      work for all output devices (note that <code>plrender</code>
      is capable of scaled aspect ratio plots to any device whether that
      device supports scaling or not).  In such scaled plots, absolute
      plotting is done in the scaled coordinate system.
    </para><node name="Defining the Window" previous="Defining the Viewport" next="Annotating the Viewport" up="View Surfaces; [Sub-]Pages; Viewports and Windows"/><subsection>Defining the Window</subsection><para>
      The window must be defined after the viewport in order to map the
      world coordinate rectangle into the viewport rectangle.  The routine
      <code>plwind</code> (<pxref node="&#10;      plwind; Specify world coordinates of viewport boundaries&#10;    " file=""/>) is used to specify the rectangle in world-coordinate space.
      For example, if we wish to plot a graph showing the collector current
      I_C as a function of the collector to emitter
      voltage V_CE for a transistor where 0 &lt;=
      I_C &lt;= 10.0 mA and 0 &lt;=
      V_CE &lt;= 12.0 V, we would call the
      function <code>plwind</code> (<pxref node="&#10;      plwind; Specify world coordinates of viewport boundaries&#10;    " file=""/>) as follows:
    </para><para>
      <example>    plwind(0.0, 12.0, 0.0, 10.0);</example>
    </para><para>
      Note that each of the arguments is a floating point number, and so
      the decimal points are required.  If the order of either the X limits
      or Y limits is reversed, the corresponding axis will point in the
      opposite sense, (i.e., right to left for X and top to bottom for Y).
      The window must be defined before any calls to the routines which
      actually draw the data points.  Note however that <code>plwind</code> (<pxref node="&#10;      plwind; Specify world coordinates of viewport boundaries&#10;    " file=""/>) may also
      be called to change the window at any time.  This will affect the
      appearance of objects drawn later in the program, and is useful for
      drawing two or more graphs with different axes on the same piece of
      paper.
    </para><node name="Annotating the Viewport" previous="Defining the Window" next="Setting up a Standard Window" up="View Surfaces; [Sub-]Pages; Viewports and Windows"/><subsection>Annotating the Viewport</subsection><para>
      The routine <code>plbox</code> (<pxref node="plbox; Draw a box with axes; etc" file=""/>) is used to specify whether a frame is drawn
      around the viewport and to control the positions of the axis
      subdivisions and numeric labels.  For our simple graph of the
      transistor characteristics, we may wish to draw a frame consisting of
      lines on all four sides of the viewport, and to place numeric labels
      along the bottom and left hand side.  We can also tell PLplot to
      choose a suitable tick interval and the number of subticks between
      the major divisions based upon the data range specified to <code>plwind</code> (<pxref node="&#10;      plwind; Specify world coordinates of viewport boundaries&#10;    " file=""/>).
      This is done using the following statement
    </para><para>
      <example>    plbox("bcnst", 0.0, 0, "bcnstv", 0.0, 0);</example>
    </para><para>
      The lengths of major and minor ticks on the axes are set up by the
      routines <code>plsmaj</code> (<pxref node="&#10;      plsmaj; Set length of major ticks&#10;    " file=""/>) and <code>plsmin</code> (<pxref node="&#10;      plsmin; Set length of minor ticks&#10;    " file=""/>).
    </para><para>
      Another routine <code>pllab</code> (<pxref node="&#10;      pllab; Simple routine to write labels&#10;    " file=""/>) provides for text labels for the bottom, left
      hand side and top of the viewport.  These labels are not clipped,
      even though they lie outside the viewport (but they are clipped at
      the subpage boundaries).  <code>pllab</code> (<pxref node="&#10;      pllab; Simple routine to write labels&#10;    " file=""/>) actually calls the more general
      routine <code>plmtex</code> (<pxref node="&#10;      plmtex; Write text relative to viewport boundaries&#10;    " file=""/>) which can be used for plotting labels at any point
      relative to the viewport.  For our example, we may use
    </para><para>
      <example>    pllab("V#dCE#u (Volts)", "I#dC#u (mA)", "TRANSISTOR CHARACTERISTICS");</example>
    </para><para>
      Note that <samp>#d</samp> and <samp>#u</samp> are escape
      sequences (see <ref node="Escape sequences in text" file="">Escape sequences in text</ref>) which allow
      subscripts and superscripts to be used in text.  They are described
      more fully later in this chapter.
    </para><para>
      The appearance of axis labels may be further altered by auxiliary
      calls to <code>plprec</code> (<pxref node="&#10;      plprec; Set precision in numeric labels&#10;    " file=""/>), <code>plschr</code> (<pxref node="&#10;      plschr; Set character size&#10;    " file=""/>), <code>plsxax</code> (<pxref node="&#10;      plsxax; Set x axis parameters&#10;    " file=""/>), <code>plsyax</code> (<pxref node="&#10;      plsyax; Set y axis parameters&#10;    " file=""/>), and <code>plszax</code> (<pxref node="&#10;      plszax; Set z axis parameters&#10;    " file=""/>).  The
      routine <code>plprec</code> (<pxref node="&#10;      plprec; Set precision in numeric labels&#10;    " file=""/>) is used to set the number of decimal places
      precision for axis labels, while <code>plschr</code> (<pxref node="&#10;      plschr; Set character size&#10;    " file=""/>) modifies the heights of
      characters used for the axis and graph labels.  Routines <code>plsxax</code> (<pxref node="&#10;      plsxax; Set x axis parameters&#10;    " file=""/>),
      <code>plsyax</code> (<pxref node="&#10;      plsyax; Set y axis parameters&#10;    " file=""/>), and <code>plszax</code> (<pxref node="&#10;      plszax; Set z axis parameters&#10;    " file=""/>) are used to modify the
      <samp>digmax</samp> setting for each axis, which affects how
      floating point labels are formatted.
    </para><para>
      The <samp>digmax</samp> variable represents the maximum field
      width for the numeric labels on an axis (ignored if less than one).
      If the numeric labels as generated by PLplot exceed this width, then
      PLplot automatically switches to floating point representation.  In
      this case the exponent will be placed at the top left for a vertical
      axis on the left, top right for a vertical axis on the right, and
      bottom right for a horizontal axis.
    </para><para>
      For example, let's suppose that we have set <samp>digmax =
      5</samp> via <code>plsyax</code> (<pxref node="&#10;      plsyax; Set y axis parameters&#10;    " file=""/>), and for our plot a label is generated at
      <samp>y = 0.0000478</samp>.  In this case the actual field
      width is longer than <samp>digmax</samp>, so PLplot switches to
      floating point.  In this representation, the label is printed as
      simply 4.78 with the 10^-5 exponent placed
      separately.
    </para><para>
      The determination of maximum length (i.e. <samp>digmax</samp>)
      for fixed point quantities is complicated by the fact that long fixed
      point representations look much worse than the same sized floating
      point representation.  Further, a fixed point number with magnitude
      much less than one will actually gain in precision when written as
      floating point.  There is some compensation for this effect built
      into PLplot, thus the internal representation for number of digits
      kept (<samp>digfix</samp>) may not always match the user's
      specification (via <samp>digmax</samp>).  However, it will
      always be true that <samp>digfix &lt;= digmax</samp>.  The
      PLplot defaults are set up such that good results are usually
      obtained without user intervention.
    </para><para>
      Finally, after the call to <code>plbox</code> (<pxref node="plbox; Draw a box with axes; etc" file=""/>), the user may call routines
      <code>plgxax</code> (<pxref node="&#10;      plgxax; Get x axis parameters&#10;    " file=""/>), <code>plgyax</code> (<pxref node="&#10;      plgyax; Get y axis parameters&#10;    " file=""/>), or <code>plgzax</code> (<pxref node="&#10;      plgzax; Get z axis parameters&#10;    " file=""/>) to obtain information about the
      window just drawn.  This can be helpful when deciding where to put
      captions.  For example, a typical usage would be to call <code>plgyax</code> (<pxref node="&#10;      plgyax; Get y axis parameters&#10;    " file=""/>) to
      get the value of <samp>digits</samp>, then offset the y axis
      caption by that amount (plus a bit more) so that the caption
      floats just to the outside of the numeric labels.
      Note that the <samp>digits</samp> value for each axis for the
      current plot is not correct until <i>after</i> the call
      to <code>plbox</code> (<pxref node="plbox; Draw a box with axes; etc" file=""/>) is complete.
    </para><node name="Setting up a Standard Window" previous="Annotating the Viewport" up="View Surfaces; [Sub-]Pages; Viewports and Windows"/><subsection>Setting up a Standard Window</subsection><para>
      Having to call <code>pladv</code> (<pxref node="pladv; Advance the [sub-]page" file=""/>), <code>plvpor</code> (<pxref node="&#10;      plvpor; Specify viewport using coordinates&#10;    " file=""/>), <code>plwind</code> (<pxref node="&#10;      plwind; Specify world coordinates of viewport boundaries&#10;    " file=""/>) and <code>plbox</code> (<pxref node="plbox; Draw a box with axes; etc" file=""/>) is excessively
      cumbersome for drawing simple graphs.  Subroutine <code>plenv</code> (<pxref node="&#10;      plenv; Set up standard window and draw box&#10;    " file=""/>) combines
      all four of these in one subroutine, using the standard viewport, and
      a limited subset of the capabilities of <code>plbox</code> (<pxref node="plbox; Draw a box with axes; etc" file=""/>).  For example, the
      graph described above could be initiated by the call:
    </para><para>
      <example>    plenv(0.0, 12.0, 0.0, 10.0, 0, 0);</example>
    </para><para>
      which is equivalent to the following series of calls:
    </para><para>
      <example>    pladv(0);
    plvsta();
    plwind(0.0, 12.0, 0.0, 10.0);
    plbox("bcnst", 0.0, 0, "bcnstv", 0.0, 0);</example>
    </para><node name="Setting Line Attributes" previous="View Surfaces; [Sub-]Pages; Viewports and Windows" next="Setting the Area Fill Pattern" up="Advanced Use of PLplot"/><section>Setting Line Attributes</section><para>
      The graph drawing routines may be freely mixed with those described
      in this section, allowing the user to control line color, width and
      styles.  The attributes set up by these routines apply modally, i.e,
      all subsequent objects (lines, characters and symbols) plotted until
      the next change in attributes are affected in the same way.  The only
      exception to this rule is that characters and symbols are not
      affected by a change in the line style, but are always drawn using a
      continuous line.
    </para><para>
      Line color is set using the routine <code>plcol0</code> (<pxref node="&#10;      plcol0; Set color; map0&#10;    " file=""/>).  The argument is ignored
      for devices which can only plot in one color, although some terminals
      support line erasure by plotting in color zero.
    </para><para>
      Line width is set using <code>plwid</code> (<pxref node="&#10;      plwid; Set pen width&#10;    " file=""/>).  This option is not supported by
      all devices.
    </para><para>
      Line style is set using the routine <code>plstyl</code> (<pxref node="&#10;      plstyl; Set line style&#10;    " file=""/>) or <code>pllsty</code> (<pxref node="&#10;      pllsty; Select line style&#10;    " file=""/>).  A broken
      line is specified in terms of a repeated pattern consisting of marks
      (pen down) and spaces (pen up).  The arguments to this routine are
      the number of elements in the line, followed by two pointers to
      integer arrays specifying the mark and space lengths in micrometers.
      Thus a line consisting of long and short dashes of lengths 4 mm
      and 2 mm, separated by spaces of length 1.5 mm is specified
      by:
    </para><para>
      <example>    mark[0] = 4000;
    mark[1] = 2000;
    space[0] = 1500;
    space[1] = 1500;
    plstyl(2, mark, space);</example>
    </para><para>
      To return to a continuous line, just call <code>plstyl</code> (<pxref node="&#10;      plstyl; Set line style&#10;    " file=""/>) with first
      argument set to zero.  You can use <code>pllsty</code> (<pxref node="&#10;      pllsty; Select line style&#10;    " file=""/>) to choose between 8
      different predefined styles.
    </para><node name="Setting the Area Fill Pattern" previous="Setting Line Attributes" next="Setting Color" up="Advanced Use of PLplot"/><section>Setting the Area Fill Pattern</section><para>
      The routine <code>plpat</code> (<pxref node="&#10;      plpat; Set area fill pattern&#10;    " file=""/>) can be used to set the area fill pattern.  The
      pattern consists of 1 or 2 sets of parallel lines with specified
      inclinations and spacings.  The arguments to this routine are the
      number of sets to use (1 or 2) followed by two pointers to integer
      arrays (of 1 or 2 elements) specifying the inclinations in tenths of
      a degree and the spacing in micrometers (the inclination should be
      between -900 and 900).  Thus to specify an area fill pattern
      consisting of horizontal lines spaced 2 mm apart use:
    </para><para>
      <example>    *inc = 0;
    *del = 2000;
    plpat(1, inc, del);</example>
    </para><para>
      To set up a symmetrical crosshatch pattern with lines directed 30
      degrees above and below the horizontal and spaced 1.5 mm apart
      use:
    </para><para>
      <example>    *inc = 300;
    *(inc+1) = -300;
    *del = 1500;
    *(del+1) = 1500;
    plpat(2, inc, del);</example>
    </para><para>
      The routine <code>plpsty</code> (<pxref node="&#10;      plpsty; Select area fill pattern&#10;    " file=""/>) can be used to select from 1 of 8 predefined
      patterns.
    </para><para>
      The area fill routines also use the current line style, width and
      colors to give a virtually infinite number of different patterns.
    </para><node name="Setting Color" previous="Setting the Area Fill Pattern" next="Setting Character Attributes" up="Advanced Use of PLplot"/><section>Setting Color</section><para> Normally, color is used for all drivers and devices that support
    it within PLplot subject to the condition that the user has the option
    of globally turning off the color (and subsequently turning it on again
    if so desired) using <code>plscolor</code> (<pxref node="&#10;      plscolor; Used to globally turn color output on/off&#10;    " file=""/>). </para><para> The PLplot color model utilizes two color maps which can be used
    interchangeably.  However, color map0 (discussed in <ref node="Color Map0" file="">Color Map0</ref>) has discrete colors with no particular order
    and is most suited to coloring the background, axes, lines, and labels,
    and color map1 (discussed in <ref node="Color Map1" file="">Color Map1</ref>) has
    continuously changing colors and is most suited to plots (see <ref node="Contour and Shade Plots" file="">Contour and Shade Plots</ref>) in which data values are represented by
    colors. </para><menu><menuentry node="Color Map0"><menuentrytitle>Color Map0</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Color Map1"><menuentrytitle>Color Map1</menuentrytitle><menuentrydescrip/></menuentry></menu><node name="Color Map0" next="Color Map1" up="Setting Color"/><subsection>Color Map0</subsection><para> Color map0 is most suited to coloring the background, axes,
    lines, and labels.  Generally, the default color map0 palette of 16
    colors is used. (<file>examples/c/x02c.c</file> illustrates
    these colors.) The default background color is taken from the index 0
    color which is black by default.  The default foreground color is red.
    </para><para> There are a number of options for changing the default red on
    black colors.  The user may set the index 0 background color using the
    command-line <samp>bg</samp> parameter or by calling <code>plscolbg</code> (<pxref node="&#10;      plscolbg; Set the background color&#10;by 8-bit RGB value&#10;    " file=""/>)
    (or <code>plscol0</code> (<pxref node="&#10;      plscol0;  Set a given color from color map0 by 8&#10;bit RGB value&#10;    " file=""/>) with a 0 index) <i>before</i> <code>plinit</code> (<pxref node="&#10;      plinit; Initialize PLplot&#10;    " file=""/>).
    During the course of the plot, the user can change the foreground color
    as often as desired using <code>plcol0</code> (<pxref node="&#10;      plcol0; Set color; map0&#10;    " file=""/>) to select the index of the desired
    color. </para><para> For more advanced use it is possible to define an arbitrary map0
    palette of colors. The user may set the number of colors in the map0
    palette using the command-line <samp>ncol0</samp> parameter or by
    calling <code>plscmap0n</code> (<pxref node="&#10;      plscmap0n; Set number of colors in color map0&#10;    " file=""/>).  <code>plscol0</code> (<pxref node="&#10;      plscol0;  Set a given color from color map0 by 8&#10;bit RGB value&#10;    " file=""/>) sets the RGB value of the given index
    which must be less than the maximum number of colors (which is set by
    default, by command line, by <code>plscmap0n</code> (<pxref node="&#10;      plscmap0n; Set number of colors in color map0&#10;    " file=""/>), or even by <code>plscmap0</code> (<pxref node="&#10;      plscmap0; Set color map0 colors by 8-bit RGB&#10;values&#10;    " file=""/>)).
    Alternatively, <code>plscmap0</code> (<pxref node="&#10;      plscmap0; Set color map0 colors by 8-bit RGB&#10;values&#10;    " file=""/>) sets up the entire map0 color palette. For
    all these ways of defining the map0 palette any number of colors are
    allowed in any order, but it is not guaranteed that the individual
    drivers will actually be able to use more than 16 colors. </para><node name="Color Map1" previous="Color Map0" up="Setting Color"/><subsection>Color Map1</subsection><para> Color map1 is most suited to plots (see <ref node="Contour and Shade Plots" file="">Contour and Shade Plots</ref>) in which data values are represented by
    colors. The data are scaled to the input map1 range of floating point
    numbers between 0. and 1. which in turn are mapped (using <code>plcol1</code> (<pxref node="&#10;      plcol1; Set color; map1&#10;    " file=""/>)) to
    colors using a default or user-specified map1 color transformation.  Thus,
    there are calls to <code>plcol1</code> (<pxref node="&#10;      plcol1; Set color; map1&#10;    " file=""/>) from within the code for <code>plshade</code> (<pxref node="&#10;      plshade;  Shade individual region on the basis of value&#10;    " file=""/>) (see
    <file>src/plshade.c</file>) and <code>plsurf3d</code> (<pxref node="&#10;      plsurf3d; Plot shaded 3-d surface plot&#10;    " file=""/>) (see
    <file>src/plot3d.c</file>) to give a continuous range of
    color corresponding to the data being plotted. In addition <code>plcol1</code> (<pxref node="&#10;      plcol1; Set color; map1&#10;    " file=""/>) can
    be used to specify the foreground color using the map1 continuous color
    palette (see the commented out section of
    <file>examples/c/x12c.c</file> which gives an example of this
    for a histogram), but normally <code>plcol0</code> (<pxref node="&#10;      plcol0; Set color; map0&#10;    " file=""/>) is a better tool for this job
    (see <ref node="Color Map0" file="">Color Map0</ref>) since discrete colors often give
    a better-looking result. </para><para> For more advanced use it is possible to define an arbitrary map1
    palette of colors. The user may set the number of colors in this palette
    using the command-line <samp>ncol1</samp> parameter or by calling
    <code>plscmap1n</code> (<pxref node="&#10;      plscmap1n; Set number of colors in color map1&#10;    " file=""/>).  Furthermore, <code>plscmap1l</code> (<pxref node="&#10;      plscmap1l; Set color map1 colors using a&#10;piece-wise linear relationship&#10;    " file=""/>) can be used to set the map1 color
    palette using linear interpolation between control points specified in
    either RGB or HLS space.</para><para> There is a one-to-one correspondence between RGB and HLS color
    spaces.  RGB space is characterized by three 8-bit unsigned integers
    corresponding to the intensity of the red, green, and blue colors. Thus,
    in hexidecimal notation with the 3 bytes concatanated together the RGB
    values of FF0000, FFFF00, 00FF00, 00FFFF, 0000FF, FF00FF, 000000, and
    FFFFFF correspond to red, yellow, green, cyan, blue, magenta, black, and
    white. </para><para> HLS (hue, lightness, and saturation) space is often conceptually
    easier to use than RGB space.  One useful way to visualize HLS space is
    as a volume made up by two cones with their bases joined at the
    equator.  A given RGB point corresponds to HLS point
    somewhere on or inside the double cones, and vice versa. The hue
    corresponds to the longitude of the point with 0, 60,
    120, 180, 240, and 300 degrees corresponding to red, yellow, green,
    cyan, blue, and magenta. The lightness corresponds to the distance along
    the axis of the figure of a perpendicular dropped from the HLS point to
    the axis. This values ranges from 0 at the south pole to
    1 at the north pole.  The saturation corresponds to the
    distance of the HLS point from the axis with the on-axis value being 0
    and the surface value being 1. Full saturation corresponds to full color
    while reducing the saturation (moving toward the axis of the HLS figure)
    mixes more gray into the color until at zero saturation on the axis of
    the figure you have only shades of gray with the variation of lightness
    along the axis corresponding to a gray scale. </para><para> Here are some C-code fragments which use <code>plscmap1l</code> (<pxref node="&#10;      plscmap1l; Set color map1 colors using a&#10;piece-wise linear relationship&#10;    " file=""/>) to set the
    map1 color palette. This first example illustrates how to set up a
    gray-scale pallette using linear interpolation in RGB space.

<example>    i[0] = 0.;
    i[1] = 1.;
    /* RGB are rescaled to the range from 0 to 1. for input to plscmap1l.*/
    r[0] = 0.;
    r[1] = 1.;
    g[0] = 0.;
    g[1] = 1.;
    b[0] = 0.;
    b[1] = 1.;
    plscmap1l(1, 2, i, r, g, b, NULL);</example>
    </para><para> This second example illustrates doing the same thing in HLS
    space.

<example>    i[0] = 0.;
    i[1] = 1.;
    /* Hue does not matter for zero saturation.*/
    h[0] = 0.;
    h[1] = 0.;
    /* Lightness varies through its full range.*/
    l[0] = 0.;
    l[1] = 1.;
    /* Saturation is zero for a gray scale.*/
    s[0] = 0.;
    s[1] = 0.;
    /* Note the first argument which specifies HLS space.*/
    plscmap1l(0, 2, i, h, l, s, NULL);</example>
    </para><para> This final example using <code>plscmap1l</code> (<pxref node="&#10;      plscmap1l; Set color map1 colors using a&#10;piece-wise linear relationship&#10;    " file=""/>) illustrates how the default
    map1 color pallette is set with just 4 control points (taken from
    <file>src/plctrl.c</file>).

<example>/*--------------------------------------------------------------------------*\
 * plcmap1_def()
 *
 * Initializes color map 1.
 *
 * The default initialization uses 4 control points in HLS space, the two
 * inner ones being very close to one of the vertices of the HLS double
 * cone.  The vertex used (black or white) is chosen to be the closer to
 * the background color.  If you don't like these settings you can always
 * initialize it yourself.
\*--------------------------------------------------------------------------*/

static void
plcmap1_def(void)
{
    PLFLT i[4], h[4], l[4], s[4], vertex = 0.;

/* Positions of control points */

    i[0] = 0;		/* left boundary */
    i[1] = 0.45;	/* just before center */
    i[2] = 0.55;	/* just after center */
    i[3] = 1;		/* right boundary */

/* For center control points, pick black or white, whichever is closer to bg */
/* Be carefult to pick just short of top or bottom else hue info is lost */

    if (plsc-&gt;cmap0 != NULL)
	vertex = ((float) plsc-&gt;cmap0[0].r +
		  (float) plsc-&gt;cmap0[0].g +
		  (float) plsc-&gt;cmap0[0].b) / 3. / 255.;

    if (vertex &lt; 0.5)
	vertex = 0.01;
    else
	vertex = 0.99;

/* Set hue */

    h[0] = 260;		/* low: blue-violet */
    h[1] = 260;		/* only change as we go over vertex */
    h[2] = 0;		/* high: red */
    h[3] = 0;		/* keep fixed */

/* Set lightness */

    l[0] = 0.5;		/* low */
    l[1] = vertex;	/* bg */
    l[2] = vertex;	/* bg */
    l[3] = 0.5;		/* high */

/* Set saturation -- keep at maximum */

    s[0] = 1;
    s[1] = 1;
    s[2] = 1;
    s[3] = 1;

    c_plscmap1l(0, 4, i, h, l, s, NULL);
}</example> 
</para><para> Finally, <code>plscmap1</code> (<pxref node="&#10;      plscmap1; Set color map1 colors using 8-bit RGB&#10;values&#10;    " file=""/>) is an additional method of setting the map1
    color palette directly using RGB space.  No interpolation is used with
    <code>plscmap1</code> (<pxref node="&#10;      plscmap1; Set color map1 colors using 8-bit RGB&#10;values&#10;    " file=""/>) so it is the programmer's responsibility to make sure that
    the colors vary smoothly.  Here is an example of the method taken from
    <file>examples/c/x08c.c</file> which sets (yet again) the
    gray-scale color pallette.

<example>    for (i=0;i&lt;n_col;i++)
        rr[i] = gg[i] = bb[i] = i*256/n_col;
    plscmap1(rr,gg,bb,n_col);</example> 
</para><node name="Setting Character Attributes" previous="Setting Color" next="Three Dimensional Surface Plots" up="Advanced Use of PLplot"/><section>Setting Character Attributes</section><para>
      Plplot uses two separate font systems to display characters. The
      traditional system uses Hershey fonts which are available for all
      device drivers, while the recently introduced unicode system is
      currently available only for the ps, psc, png, jpeg, and gif devices.
      For details on how to enable the unicode font system for additional
      device drivers using the FreeType library, see 
      <ref node="Adding FreeType Library Support to Bitmap Drivers" file="">Adding FreeType Library Support to Bitmap Drivers</ref>.
    </para><menu><menuentry node="Hershey fonts"><menuentrytitle>Hershey fonts</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Unicode fonts"><menuentrytitle>Unicode fonts</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="FCI"><menuentrytitle>FCI</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Escape sequences in text"><menuentrytitle>Escape sequences in text</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Character size adjustment"><menuentrytitle>Character size adjustment</menuentrytitle><menuentrydescrip/></menuentry></menu><node name="Hershey fonts" next="Unicode fonts" up="Setting Character Attributes"/><subsection>Hershey fonts</subsection><para>
      There are two Hershey font character sets included with PLplot.
      These are known
      as the standard and extended character sets.  The
      standard character set is a subset of the extended set.  It contains
      177 characters including the ascii characters in a normal style font,
      the Greek alphabet and several plotter symbols.  The extended
      character set contains almost 1000 characters, including four font
      styles, and several math, musical and plotter symbols.
    </para><para>
      The extended character set is loaded into memory automatically when
      <code>plstar</code> (<pxref node="&#10;      plstar; Initialization&#10;    " file=""/>) or <code>plstart</code> (<pxref node="&#10;      plstart; Initialization&#10;    " file=""/>) is called.  The standard character set is
      loaded by calling <code>plfontld</code> (<pxref node="&#10;      plfontld; Load character font&#10;    " file=""/>).  The extended character set requires
      about 50 KBytes of memory, versus about 5 KBytes for the standard
      set.  <code>plfontld</code> (<pxref node="&#10;      plfontld; Load character font&#10;    " file=""/>) can be used to switch between the extended and
      standard sets (one set is unloaded before the next is loaded).
      <code>plfontld</code> (<pxref node="&#10;      plfontld; Load character font&#10;    " file=""/>) can be called before <code>plstar</code> (<pxref node="&#10;      plstar; Initialization&#10;    " file=""/>).
    </para><para>
      When the extended character set is loaded there are four different
      font styles to choose from.  In this case, the routine <code>plfont</code> (<pxref node="&#10;      plfont; Set character font&#10;    " file=""/>) sets
      up the default Hershey font for all character strings.  It may be overridden
      for any portion of a string by using an escape sequence within the
      text, as described below.  This routine has no effect when the
      standard font set is loaded.  The default font (1) is simple and
      fastest to draw; the others are useful for presentation plots on a
      high-resolution device.
    </para><para>
      The font codes are interpreted as follows:

      <itemize markchar="•"><listitem><para>
	    <samp>font = 1</samp>: normal (sans-serif) font
	  </para></listitem><listitem><para>
	    <samp>font = 2</samp>: roman (serif) font
	  </para></listitem><listitem><para>
	    <samp>font = 3</samp>: italic font
	  </para></listitem><listitem><para>
	    <samp>font = 4</samp>: script font
	  </para></listitem></itemize>
    </para><node name="Unicode fonts" previous="Hershey fonts" next="FCI" up="Setting Character Attributes"/><subsection>Unicode fonts</subsection><para>
      The advantages of the unicode fonts over the more traditional PLplot
      Hershey fonts are the availability of many additional glyphs
      (including mathematical symbols and glyphs from other than
      western-European languages) and much better display of characters on
      computer screens using anti-aliasing and hinting.  Unicode fonts are
      obtained by specifying a command-line option of -drvopt text for
      the devices (currently ps, psc, png, jpeg, gif, gcw, and wingcc) 
      where it has been implemented.
    </para><para>
      For the ps and psc devices, there is a fixed relationship between the
      FCI (font characterization integer, see <ref node="FCI" file="">FCI</ref>) 
      and the actual Type 1
      fonts that are being used.  This fixed relationship is specified in
      the Type1Lookup array in include/plfci.h.  This array maps the
      font-family attributes of sans-serif, serif, monotype, script, and
      symbol to the standard postscript font families called Helvetica,
      Times-Roman, Courier, Times-Roman, and Symbol.  (There is no script
      font family amongst the 35 standard Type 1 postscript fonts so that is
      why we map the font-family attribute of script to Times-Roman.)
      Similarly, this array maps the font-style attributes of upright,
      italic or oblique and the font-weight attributes of medium or bold to
      the appropriate variety of the Helvetica, Times-Roman, Courier,
      and Symbol font families that are part of the 
      35 standard Type 1 postscript fonts.  These standard postscript fonts
      are normally installed on a user's system using the gsfonts package.
    </para><para>
      For the devices handled by the FreeType library (currently png, jpeg,
      and gif) there is a configurable relationship between the FCI (font
      characterization integer, see <ref node="FCI" file="">FCI</ref>) 
      and the TrueType fonts that are actually used.  
    </para><para>
      On Unix/Linux systems, the TrueType fonts corresponding to the 30 possible
      valid FCIs can be specified using ./configure options. (Use
      ./configure --help to see the possibilities and also the default
      values for the fonts.) These ./configure defaults for the 30
      possibilites are taken from fonts available from the ttf-freefont font
      package.  We recommend this font package because it has a rather
      complete set of glyphs for most unicode blocks.  (We also recommend
      the gucharmap application for determining other unicode font
      possibilities on your system that are available via the FreeType
      library.)
    </para><para>
      On Windows systems, the fixed default TrueType fonts are specified in the
      include/plfci.h file.  (NOT PROGRAMMED YET, so this statement
      will probably NEED REVISION.)
    </para><para>
      For all systems, the 30 possible TrueType fonts can be specified at run
      time using the following environment variables:
      <itemize markchar="•"><listitem><para>
	    PLPLOT_FREETYPE_SANS_FONT
	  </para></listitem><listitem><para>
	    PLPLOT_FREETYPE_SERIF_FONT
	  </para></listitem><listitem><para>
	    PLPLOT_FREETYPE_MONO_FONT
	  </para></listitem><listitem><para>
	    PLPLOT_FREETYPE_SCRIPT_FONT
	  </para></listitem><listitem><para>
	    PLPLOT_FREETYPE_SYMBOL_FONT
	  </para></listitem><listitem><para>
	    PLPLOT_FREETYPE_SANS_ITALIC_FONT
	  </para></listitem><listitem><para>
	    PLPLOT_FREETYPE_SERIF_ITALIC_FONT
	  </para></listitem><listitem><para>
	    PLPLOT_FREETYPE_MONO_ITALIC_FONT
	  </para></listitem><listitem><para>
	    PLPLOT_FREETYPE_SCRIPT_ITALIC_FONT
	  </para></listitem><listitem><para>
	    PLPLOT_FREETYPE_SYMBOL_ITALIC_FONT
	  </para></listitem><listitem><para>
	    PLPLOT_FREETYPE_SANS_OBLIQUE_FONT
	  </para></listitem><listitem><para>
	    PLPLOT_FREETYPE_SERIF_OBLIQUE_FONT
	  </para></listitem><listitem><para>
	    PLPLOT_FREETYPE_MONO_OBLIQUE_FONT
	  </para></listitem><listitem><para>
	    PLPLOT_FREETYPE_SCRIPT_OBLIQUE_FONT
	  </para></listitem><listitem><para>
	    PLPLOT_FREETYPE_SYMBOL_OBLIQUE_FONT
	  </para></listitem><listitem><para>
	    PLPLOT_FREETYPE_SANS_BOLD_FONT
	  </para></listitem><listitem><para>
	    PLPLOT_FREETYPE_SERIF_BOLD_FONT
	  </para></listitem><listitem><para>
	    PLPLOT_FREETYPE_MONO_BOLD_FONT
	  </para></listitem><listitem><para>
	    PLPLOT_FREETYPE_SCRIPT_BOLD_FONT
	  </para></listitem><listitem><para>
	    PLPLOT_FREETYPE_SYMBOL_BOLD_FONT
	  </para></listitem><listitem><para>
	    PLPLOT_FREETYPE_SANS_BOLD_ITALIC_FONT
	  </para></listitem><listitem><para>
	    PLPLOT_FREETYPE_SERIF_BOLD_ITALIC_FONT
	  </para></listitem><listitem><para>
	    PLPLOT_FREETYPE_MONO_BOLD_ITALIC_FONT
	  </para></listitem><listitem><para>
	    PLPLOT_FREETYPE_SCRIPT_BOLD_ITALIC_FONT
	  </para></listitem><listitem><para>
	    PLPLOT_FREETYPE_SYMBOL_BOLD_ITALIC_FONT
	  </para></listitem><listitem><para>
	    PLPLOT_FREETYPE_SANS_BOLD_OBLIQUE_FONT
	  </para></listitem><listitem><para>
	    PLPLOT_FREETYPE_SERIF_BOLD_OBLIQUE_FONT
	  </para></listitem><listitem><para>
	    PLPLOT_FREETYPE_MONO_BOLD_OBLIQUE_FONT
	  </para></listitem><listitem><para>
	    PLPLOT_FREETYPE_SCRIPT_BOLD_OBLIQUE_FONT
	  </para></listitem><listitem><para>
	    PLPLOT_FREETYPE_SYMBOL_BOLD_OBLIQUE_FONT
	  </para></listitem></itemize>
      On Unix/Linux systems if these environment variables are not specified
      with an absolute path starting with "/", then the absolute path is
      specified by the configured default (see ./configure --help) or at
      run time with the
      environment variable PLPLOT_FREETYPE_FONT_DIR.
    </para><node name="FCI" previous="Unicode fonts" next="Escape sequences in text" up="Setting Character Attributes"/><subsection>FCI</subsection><para>
      We specify the properties of unicode fonts with the FCI (font
      characterization integer).  The FCI is a 32-bit unsigned integer whose
      left-most hexadecimal digit is marked with an 0x1 to distinguish it
      from a unicode (UCS4) integer (which is also an unsigned 32-bit
      integer but with a maximum value of 0x0010ffff). Users obtain the current
      FCI by calling <code>plgfci</code> (<pxref node="&#10;      plgfci; Get FCI [font characterization integer]&#10;    " file=""/>) and store a new FCI to be used at the start
      of each subsequent string using <code>plsfci</code> (<pxref node="&#10;      plsfci; Set FCI [font characterization integer]&#10;    " file=""/>). Independent
      hexadecimal values within the FCI are characterized by the
      hexdigit and hexpower.  The hexpower is defined as the power of 16 or
      number of hexadecimal places to the left of the "decimal place" in the FCI 
      where the hexdigit is stored.
      The interpretation of the hexdigit and hexpower values in the FCI are
      given in <ref node="FCI interpretation" file="">FCI interpretation</ref>.
    </para><anchor node="FCI interpretation"/><para><strong>FCI interpretation</strong></para><multitable cols="7"><tbody><row><entry/><entry>hexdigit --&gt;</entry><entry>0</entry><entry>1</entry><entry>2</entry><entry>3</entry><entry>4</entry></row><row><entry>Font attribute</entry><entry>hexpower</entry><entry/><entry/><entry/><entry/><entry/></row><row><entry>font-family</entry><entry>0</entry><entry>sans-serif</entry><entry>serif</entry><entry>monospace</entry><entry>script</entry><entry>symbol</entry></row><row><entry>font-style</entry><entry>1</entry><entry>upright</entry><entry>italic</entry><entry>oblique</entry><entry/><entry/></row><row><entry>font-weight</entry><entry>2</entry><entry>medium</entry><entry>bold</entry><entry/><entry/><entry/></row></tbody></multitable><para>
      Note the maximum value of hexdigit is 7 and the maximum value of
      hexpower is 6 so there is substantial room for expansion of this
      scheme.  On the other hand, since each font attribute is independent
      of the rest, what is implemented now gives us a maximum of 30
      different font possibilities which is probably more than enough for
      most plotting purposes.
    </para><node name="Escape sequences in text" previous="FCI" next="Character size adjustment" up="Setting Character Attributes"/><subsection>Escape sequences in text</subsection><para>
      The routines which draw text all allow you to include escape
      sequences in the text to be plotted.  These are character sequences
      that are interpreted as instructions to change fonts, draw
      superscripts and subscripts, draw non-ASCII (e.g. Greek), and so on.
      All escape sequences start with a number symbol
      (<samp>#</samp>) by default.  Some language interfaces have
      the capability of changing this default, but we will assume
      (<samp>#</samp>) in the remaining documentation of the escape
      sequences.
    </para><para>
      The following escape sequences are defined:

      <itemize markchar="•"><listitem><para>
	    <samp>#u</samp>: move up to the superscript position
	    (ended with <samp>#d</samp>)
	  </para></listitem><listitem><para>
	    <samp>#d</samp>: move down to subscript position
	    (ended with <samp>#u</samp>)
	  </para></listitem><listitem><para>
	    <samp>#b</samp>: backspace (to allow overprinting)
	  </para></listitem><listitem><para>
	    <samp>##</samp>: number symbol
	  </para></listitem><listitem><para>
	    <samp>#+</samp>: toggle overline mode
	  </para></listitem><listitem><para>
	    <samp>#-</samp>: toggle underline mode
	  </para></listitem><listitem><para>
	    <samp>#gx</samp>: Greek letter corresponding to Roman
	    letter <samp>x</samp> (see below)
	  </para></listitem><listitem><para>
	    <samp>#fn</samp>: switch to normal (sans-serif) font
	  </para></listitem><listitem><para>
	    <samp>#fr</samp>: switch to Roman (serif) font
	  </para></listitem><listitem><para>
	    <samp>#fi</samp>: switch to italic font
	  </para></listitem><listitem><para>
	    <samp>#fs</samp>: switch to script font
	  </para></listitem><listitem><para>
	    <samp>#(nnn)</samp>: Hershey character nnn (1 to 4
	    decimal digits) 
	  </para></listitem><listitem><para>
	    <samp>#[nnn]</samp>: unicode character nnn (nnn can
	    be decimal or hexadecimal [e.g., starting with 0x]) (UNICODE ONLY).
	  </para></listitem><listitem><para>
	    <samp>&lt;0x1nnnnnnn&gt;</samp>: absolute FCI to be used to
	    change fonts in mid-string.  (nnnnnnn must be exactly 7
	    digits). (UNICODE ONLY).
	  </para></listitem><listitem><para>
	    <samp>&lt;0xmn&gt;</samp>: change just one attribute
	    of the FCI in mid-string where m is the hexdigit and n is
	    the hexpower.  If more than two digits are given (so long
	    as the eigth digit does not mark this as an absolute FCI, see
	    above) they
	    are ignored. (UNICODE ONLY).
	  </para></listitem><listitem><para>
	    <samp>&lt;FCI COMMAND STRING/&gt;</samp>: the FCI COMMAND
	    STRING is currently one of "sans-serif", "serif", "monospace",
	    "script", "symbol", "upright", "italic", "oblique" "medium",
	    or "bold" (without the surrounding quotes).  These FCI
	    COMMAND STRINGS change one attribute of the FCI according to
	    their name. (UNICODE ONLY).
	  </para></listitem></itemize>
    </para><para>
      Sections of text can have an underline or overline appended.  For
      example, the string S-freq is obtained by specifying
      <samp>"#+S#+(#-freq#-)"</samp>. 
    </para><para>
      Greek letters are obtained by <samp>#g</samp> followed by a
      Roman letter.  <ref node="Roman Characters Corresponding to Greek Characters" file="">Roman Characters Corresponding to Greek Characters</ref> shows how these letters map
      into Greek characters.
    </para><anchor node="Roman Characters Corresponding to Greek Characters"/><para><strong>Roman Characters Corresponding to Greek Characters</strong></para><multitable cols="13"><colspec width="2" colnum="1"/><tbody><row><entry>Roman</entry><entry>A</entry><entry>B</entry><entry>G</entry><entry>D</entry><entry>E</entry><entry>Z</entry><entry>Y</entry><entry>H</entry><entry>I</entry><entry>K</entry><entry>L</entry><entry>M</entry></row><row><entry>Greek</entry><entry>Alpha</entry><entry>Beta</entry><entry>Gamma</entry><entry>Delta</entry><entry>Epsilon</entry><entry>Zeta</entry><entry>Eta</entry><entry>Theta</entry><entry>Iota</entry><entry>Kappa</entry><entry>Lambda</entry><entry>Mu</entry></row></tbody></multitable><multitable cols="13"><colspec width="2" colnum="1"/><tbody><row><entry>Roman</entry><entry>N</entry><entry>C</entry><entry>O</entry><entry>P</entry><entry>R</entry><entry>S</entry><entry>T</entry><entry>U</entry><entry>F</entry><entry>X</entry><entry>Q</entry><entry>W</entry></row><row><entry>Greek</entry><entry>Nu</entry><entry>Xi</entry><entry>Omicron</entry><entry>Pi</entry><entry>Rho</entry><entry>Sigma</entry><entry>Tau</entry><entry>Upsilon</entry><entry>Phi</entry><entry>Chi</entry><entry>Psi</entry><entry>Omega</entry></row></tbody></multitable><multitable cols="13"><colspec width="2" colnum="1"/><tbody><row><entry>Roman</entry><entry>a</entry><entry>b</entry><entry>g</entry><entry>d</entry><entry>e</entry><entry>z</entry><entry>y</entry><entry>h</entry><entry>i</entry><entry>k</entry><entry>l</entry><entry>m</entry></row><row><entry>Greek</entry><entry>alpha</entry><entry>beta</entry><entry>gamma</entry><entry>delta</entry><entry>epsilon</entry><entry>zeta</entry><entry>eta</entry><entry>theta</entry><entry>iota</entry><entry>kappa</entry><entry>lambda</entry><entry>mu</entry></row></tbody></multitable><multitable cols="13"><colspec width="2" colnum="1"/><tbody><row><entry>Roman</entry><entry>n</entry><entry>c</entry><entry>o</entry><entry>p</entry><entry>r</entry><entry>s</entry><entry>t</entry><entry>u</entry><entry>f</entry><entry>x</entry><entry>q</entry><entry>w</entry></row><row><entry>Greek</entry><entry>nu</entry><entry>xi</entry><entry>omicron</entry><entry>pi</entry><entry>rho</entry><entry>sigma</entry><entry>tau</entry><entry>upsilon</entry><entry>phi</entry><entry>chi</entry><entry>psi</entry><entry>omega</entry></row></tbody></multitable><para>
      The escape sequences <samp>#fn</samp>, <samp>#fr</samp>,
      <samp>#fi</samp>, <samp>#fs</samp>, and 
      <samp>#(nnn)</samp> are designed for the four Hershey fonts, but
      an effort has been made to allow some limited forward compatibility so
      these escape sequences have a reasonable result when unicode
      fonts are being used.  However, for maximum flexibility when using
      unicode fonts, these 5 escape sequences should be replaced by using
      the 4 escape sequences <samp>#[nnn]</samp>,
      <samp>&lt;0x1nnnnnnn&gt;</samp>,
      <samp>&lt;0xmn&gt;</samp>, or <samp>&lt;FCI COMMAND
      STRING/&gt;</samp> as appropriate.
    </para><node name="Character size adjustment" previous="Escape sequences in text" up="Setting Character Attributes"/><subsection>Character size adjustment</subsection><para>
      The routine <code>plschr</code> (<pxref node="&#10;      plschr; Set character size&#10;    " file=""/>) is used to set up the size of subsequent
      characters drawn.  The actual height of a character is the product of
      the default character size and a scaling factor.  If no call is made
      to <code>plschr</code> (<pxref node="&#10;      plschr; Set character size&#10;    " file=""/>), the default character size is set up depending on the
      number of subpages defined in the call to <code>plstar</code> (<pxref node="&#10;      plstar; Initialization&#10;    " file=""/>) or <code>plstart</code> (<pxref node="&#10;      plstart; Initialization&#10;    " file=""/>), and
      the scale is set to 1.0.  Under normal circumstances, it is
      recommended that the user does not alter the default height, but
      simply use the scale parameter.  This can be done by calling <code>plschr</code> (<pxref node="&#10;      plschr; Set character size&#10;    " file=""/>)
      with <samp>def = 0.0</samp> and <samp>scale</samp> set to
      the desired multiple of the default height.  If the default height is
      to be changed, <samp>def</samp> is set to the new default
      height in millimeters, and the new character height is again set to
      <samp>def</samp> multiplied by <samp>scale</samp>.
    </para><para>
      The routine <code>plssym</code> (<pxref node="&#10;      plssym; Set symbol size&#10;    " file=""/>) sets up the size of all subsequent characters drawn
      by calls to <code>plpoin</code> (<pxref node="&#10;      plpoin; Plots a character at the specified points&#10;    " file=""/>) and <code>plsym</code> (<pxref node="&#10;      plsym; Plots a symbol at the specified points&#10;    " file=""/>).  It operates analogously to
      <code>plschr</code> (<pxref node="&#10;      plschr; Set character size&#10;    " file=""/>) as described above.
    </para><node name="Three Dimensional Surface Plots" previous="Setting Character Attributes" next="Contour and Shade Plots" up="Advanced Use of PLplot"/><section>Three Dimensional Surface Plots</section><para>
      PLplot includes routines that will represent a single-valued function
      of two variables as a surface.  In this section, we shall assume that
      the function to be plotted is <samp>Z[X][Y]</samp>, where
      <samp>Z</samp> represents the dependent variable and
      <samp>X</samp> and <samp>Y</samp> represent the
      independent variables.
    </para><para>
      As usual, we would like to refer to a three dimensional point
      <samp>(X, Y, Z)</samp> in terms of some meaningful
      user-specified coordinate system.  These are called
      <i>three-dimensional world coordinates</i>.  We need to
      specify the ranges of these coordinates, so that the entire surface
      is contained within the cuboid defined by <samp>xmin &lt; x &lt;
      xmax</samp>, <samp>ymin &lt; y &lt; ymax</samp>, and
      <samp>zmin &lt; z &lt; zmax</samp>.  Typically, we shall want
      to view the surface from a variety of angles, and to facilitate this,
      a two-stage mapping of the enclosing cuboid is performed.  Firstly,
      it is mapped into another cuboid called the <i>normalized
      box</i> whose size must also be specified by the user, and
      secondly this normalized box is viewed from a particular azimuth and
      elevation so that it can be projected onto the two-dimensional
      window.
    </para><para>
      This two-stage transformation process allows considerable flexibility
      in specifying how the surface is depicted.  The lengths of the sides
      of the normalized box are independent of the world coordinate ranges
      of each of the variables, making it possible to use
      reasonable viewing angles even if the ranges of the
      world coordinates on the axes are very different.  The size of the
      normalized box is determined essentially by the size of the
      two-dimensional window into which it is to be mapped.  The normalized
      box is centered about the origin in the <samp>x</samp> and
      <samp>y</samp> directions, but rests on the plane <samp>z =
      0</samp>.  It is viewed by an observer located at altitude
      <samp>alt</samp> and azimuth <samp>az</samp>, where both
      angles are measured in degrees.  The altitude should be restricted to
      the range zero to ninety degrees for proper operation, and represents
      the viewing angle above the xy plane.  The azimuth is defined so that
      when <samp>az = 0</samp>, the observer sees the xz plane face
      on, and as the angle is increased, the observer moves clockwise
      around the box as viewed from above the xy plane.  The azimuth can
      take on any value.
    </para><para>
      The first step in drawing a surface plot is to decide on the size of
      the two-dimensional window and the normalized box.  For example, we
      could choose the normalized box to have sides of length
    </para><para>
      <example>    basex = 2.0;
    basey = 4.0;
    height = 3.0;</example>
    </para><para>
      A reasonable range for the x coordinate of the two-dimensional window
      is -2.5 to +2.5, since the length of the diagonal across the base of
      the normalized box is
      sqrt(2^2+4^2) =
      2 sqrt(5), which fits into this coordinate range.  A reasonable
      range for the y coordinate of the two dimensional window in this case
      is -2.5 to +4, as the the projection of the normalized box lies in
      this range for the allowed range of viewing angles.
    </para><para>
      The routine <code>plwind</code> (<pxref node="&#10;      plwind; Specify world coordinates of viewport boundaries&#10;    " file=""/>) or <code>plenv</code> (<pxref node="&#10;      plenv; Set up standard window and draw box&#10;    " file=""/>) is used in the usual way to establish
      the size of the two-dimensional window.  The routine <code>plw3d</code> (<pxref node="&#10;      plw3d; Set up window for 3-d plotting&#10;    " file=""/>) must
      then be called to establish the range of the three dimensional world
      coordinates, the size of the normalized box and the viewing angles.
      After calling <code>plw3d</code> (<pxref node="&#10;      plw3d; Set up window for 3-d plotting&#10;    " file=""/>), the actual surface is drawn by a call to
      <code>plot3d</code> (<pxref node="&#10;      plot3d; Plot 3-d surface plot&#10;    " file=""/>).
    </para><para>
      For example, if the three-dimensional world-coordinate ranges are
      -10.0 &lt;= <samp>x</samp> &lt;= 10.0, -3.0 &lt;=
      <samp>y</samp> &lt;= +7.0, and 0.0 &lt;= <samp>z</samp>
      &lt;= 8.0, we could use the following statements:
    </para><para>
      <example>    xmin2d = -2.5;
    xmax2d =  2.5;
    ymin2d = -2.5;
    ymax2d =  4.0;
    plenv(xmin2d, xmax2d, ymin2d, ymax2d, 0, -2);
    basex = 2.0;
    basey = 4.0;
    height = 3.0;
    xmin = -10.0;
    xmax = 10.0;
    ymin = -3.0;
    ymax = 7.0;
    zmin = 0.0;
    zmax = 8.0;
    alt = 45.0;
    az = 30.0;
    side = 1;
    plw3d(basex, basey, height, xmin, xmax, ymin, ymax, zmin, zmax, alt, az);
    plot3d(x, y, z, nx, ny, opt, side);</example>
    </para><para>
      The values of the function are stored in a two-dimensional array
      <samp>z[][]</samp> where the array element
      <samp>z[i][j]</samp> contains the value of the function at the
      point x_i, y_j.  (The
      two-dimensional array <samp>z</samp> is a vectored array
      instead of a fixed size array.  <samp>z</samp> points to an
      array of pointers which each point to a row of the matrix.)  Note
      that the values of the independent variables
      x_i and y_j do not need
      to be equally spaced, but they must lie on a rectangular grid.  Thus
      two further arrays <samp>x[nx]</samp> and
      <samp>y[ny]</samp> are required as arguments to <code>plot3d</code> (<pxref node="&#10;      plot3d; Plot 3-d surface plot&#10;    " file=""/>) to
      specify the values of the independent variables.  The values in the
      arrays x and y must be strictly increasing with the index.  The
      argument <samp>opt</samp> specifies how the surface is
      outlined.  If <samp>opt = 1</samp>, a line is drawn
      representing z as a function of x for each value of y, if
      <samp>opt = 2</samp>, a line is drawn representing z as a
      function of y for each value of x, and if <samp>opt = 3</samp>,
      a net of lines is drawn.  The first two options may be preferable if
      one of the independent variables is to be regarded as a parameter,
      whilst the third is better for getting an overall picture of the
      surface.  If side is equal to one then sides are drawn on the figure
      so that the graph doesn't appear to float.
    </para><para>
      The routine <code>plmesh</code> (<pxref node="&#10;      plmesh; Plot surface mesh&#10;    " file=""/>) is similar to <code>plot3d</code> (<pxref node="&#10;      plot3d; Plot 3-d surface plot&#10;    " file=""/>), except that it is used
      for drawing mesh plots.  Mesh plots allow you to see both the top and
      bottom sides of a surface mesh, while 3D plots allow you to see the
      top side only (like looking at a solid object).  The side option is
      not available with <code>plmesh</code> (<pxref node="&#10;      plmesh; Plot surface mesh&#10;    " file=""/>).
    </para><para>
      Labeling a three-dimensional or mesh plot is somewhat more
      complicated than a two dimensional plot due to the need for skewing
      the characters in the label so that they are parallel to the
      coordinate axes.  The routine <code> plbox3</code> (<pxref node="&#10;      plbox3; Draw a box with axes; etc; in 3-d&#10;    " file=""/>) thus combines the functions of
      box drawing and labeling.
    </para><node name="Contour and Shade Plots" previous="Three Dimensional Surface Plots" up="Advanced Use of PLplot"/><section>Contour and Shade Plots</section><para>
      Several routines are available in PLplot which perform a contour or
      shade plot of data stored in a two-dimensional array.  The contourer
      uses a contour following algorithm so that it is possible to
      use non-continuous line styles.  Further, one may specify arbitrary
      coordinate mappings from array indices to world coordinates, such as
      for contours in a polar coordinate system.  In this case it is best
      to draw the distinction between a C and Fortran language caller, so
      these are handled in turn.
    </para><menu><menuentry node="Contour Plots from C"><menuentrytitle>Contour Plots from C</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Shade Plots from C"><menuentrytitle>Shade Plots from C</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Contour Plots from Fortran"><menuentrytitle>Contour Plots from Fortran</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Shade Plots from Fortran"><menuentrytitle>Shade Plots from Fortran</menuentrytitle><menuentrydescrip/></menuentry></menu><node name="Contour Plots from C" next="Shade Plots from C" up="Contour and Shade Plots"/><subsection>Contour Plots from C</subsection><para>
	<code>plcont</code> (<pxref node="&#10;      plcont; Contour plot&#10;    " file=""/>) is the routine callable from C for plotting contours.
	This routine has the form:
      </para><para>
	<quotation><para><t>
	    <b>plcont</b>
	  (<i>z</i>, <i>nx</i>, <i>ny</i>, <i>kx</i>, <i>lx</i>, <i>ky</i>, <i>ly</i>, <i>clevel</i>, <i>nlevel</i>, <i>pltr</i>, <i>pltr_data</i>);</t></para></quotation>
      </para><para>
	where <samp>z</samp> is the two-dimensional array of size
	<samp>nx</samp> by <samp>ny</samp> containing samples
	of the function to be contoured.  (<samp>z</samp> is a
	vectored two-dimensional array as described in the previous
	section.  It is <i>not</i> a fixed-size
	two-dimensional array.) The parameters <samp>kx</samp>,
	<samp>lx</samp>, <samp>ky</samp> and
	<samp>ly</samp> specify the portion of <samp>z</samp>
	that is to be considered.  The array <samp>clevel</samp> of
	length <samp>nlevel</samp> is a list of the desired contour
	levels.
      </para><para>
	The path of each contour is initially computed in terms of the
	values of the array indices which range from <samp>0</samp>
	to <samp>nx-1</samp> in the first index and from
	<samp>0</samp> to <samp>ny-1</samp> in the second
	index.  Before these can be drawn in the current window (see <ref node="Defining the Window" file="">Defining the Window</ref>), it is necessary to convert from these array
	indices into world coordinates.  This is done by passing a pointer
	<samp>pltr</samp> to a user-defined transformation function 
	to <code>plcont</code> (<pxref node="&#10;      plcont; Contour plot&#10;    " file=""/>).  For C use of <code>plcont</code> (<pxref node="&#10;      plcont; Contour plot&#10;    " file=""/>) (and <code>plshade</code> (<pxref node="&#10;      plshade;  Shade individual region on the basis of value&#10;    " file=""/>), see next subsection) 
	we have included directly in
	the PLplot library the following transformation routines:
	<code>pltr0</code> (<pxref node="&#10;      pltr0; Identity transformation for grid to world&#10;mapping&#10;    " file=""/>) (identity transformation or you can
	enter a NULL argument to get the same effect); <code>pltr1</code> (<pxref node="&#10;      pltr1; Linear interpolation for grid to world&#10;mapping using singly dimensioned coord arrays&#10;    " file=""/>)
	(linear interpolation in singly dimensioned coordinate arrays);
	and  <code>pltr2</code> (<pxref node="&#10;      pltr2; Linear interpolation for grid to world&#10;      mapping using doubly dimensioned coord arrays [column&#10;      dominant; as per normal C 2d arrays]&#10;    " file=""/>) (linear interpolation in doubly dimensioned coordinate
	arrays).  Examples of the use of these transformation 
	routines are given in <file>examples/c/x09c.c</file>,
	<file>examples/c/x14c.c</file>, and
	<file>examples/c/x16c.c</file>.  These same three examples
	also demonstrate a user-defined transformation function 
	<samp>mypltr</samp> which is capable of 
	arbitrary translation, rotation, and/or shear. By defining other
	transformation subroutines, it is possible to draw contours wrapped
	around polar grids etc.
      </para><node name="Shade Plots from C" previous="Contour Plots from C" next="Contour Plots from Fortran" up="Contour and Shade Plots"/><subsection>Shade Plots from C</subsection><para>
        NEEDS DOCUMENTATION
      </para><node name="Contour Plots from Fortran" previous="Shade Plots from C" next="Shade Plots from Fortran" up="Contour and Shade Plots"/><subsection>Contour Plots from Fortran</subsection><para>
	The routines mentioned above are not recommended for use directly
	from Fortran due to the need to pass a function pointer.  That is,
	the transformation function is written in C and can not generally
	be changed by the user.  The call for routine <code>plcontfortran</code> (<pxref node="&#10;      plcont; Contour plot; fixed linear mapping for&#10;fortran&#10;    " file=""/>) from
	Fortran is then:
      </para><para>
	<quotation><para><t>
	    call <b>plcont</b>
	  (<i>z</i>, <i>nx</i>, <i>ny</i>, <i>kx</i>, <i>lx</i>, <i>ky</i>, <i>ly</i>, <i>clevel</i>, <i>nlevel</i>);</t></para></quotation>
      </para><para>
When called from Fortran, this routine has the same effect as when invoked
from C.  The interpretation of all parameters (see <code>plcont</code> (<pxref node="&#10;      plcont; Contour plot&#10;    " file=""/>)) is also the
same except there is no transformation function supplied as the last
parameter.  Instead, a 6-element array specifying coefficients to use in the
transformation is supplied via the named common block
<samp>plplot</samp> (see code). Since this approach is somewhat
inflexible, the user is recommended to call either of <code>plcon0</code> (<pxref node="&#10;      plcon0; Contour plot; identity mapping for fortran&#10;    " file=""/>), <code>plcon1</code> (<pxref node="&#10;      plcon1; Contour plot; general 1-d mapping for&#10;fortran&#10;    " file=""/>), or
<code>plcon2</code> (<pxref node="&#10;      plcon2; Contour plot; general 2-d mapping for&#10;fortran&#10;    " file=""/>) instead.
      </para><para>
	The three routines recommended for use from Fortran are <code>plcon0</code> (<pxref node="&#10;      plcon0; Contour plot; identity mapping for fortran&#10;    " file=""/>),
	<code>plcon1</code> (<pxref node="&#10;      plcon1; Contour plot; general 1-d mapping for&#10;fortran&#10;    " file=""/>), and <code>plcon2</code> (<pxref node="&#10;      plcon2; Contour plot; general 2-d mapping for&#10;fortran&#10;    " file=""/>).  These routines are similar to existing
	commercial plot package contour plotters in that they offer
	successively higher complexity, with <code>plcon0</code> (<pxref node="&#10;      plcon0; Contour plot; identity mapping for fortran&#10;    " file=""/>) utilizing no
	transformation arrays, while those used by <code>plcon1</code> (<pxref node="&#10;      plcon1; Contour plot; general 1-d mapping for&#10;fortran&#10;    " file=""/>) and <code>plcon2</code> (<pxref node="&#10;      plcon2; Contour plot; general 2-d mapping for&#10;fortran&#10;    " file=""/>)
	are one and two dimensional, respectively.  The call syntax for
	each is
      </para><para>
	<quotation><para><t>
	    call <b>plcon0</b>
	  (<i>z</i>, <i>nx</i>, <i>ny</i>, <i>kx</i>, <i>lx</i>, <i>ky</i>, <i>ly</i>, <i>clevel</i>, <i>nlevel</i>);</t></para></quotation>
	
	<quotation><para><t>
	    call <b>plcon1</b>
	  (<i>z</i>, <i>nx</i>, <i>ny</i>, <i>kx</i>, <i>lx</i>, <i>ky</i>, <i>ly</i>, <i>clevel</i>, <i>nlevel</i>, <i>xg1</i>, <i>yg1</i>);</t></para></quotation>
	
	<quotation><para><t>
	    call <b>plcon2</b>
	  (<i>z</i>, <i>nx</i>, <i>ny</i>, <i>kx</i>, <i>lx</i>, <i>ky</i>, <i>ly</i>, <i>clevel</i>, <i>nlevel</i>, <i>xg2</i>, <i>yg2</i>);</t></para></quotation>
      </para><para>
	The <code>plcon0</code> (<pxref node="&#10;      plcon0; Contour plot; identity mapping for fortran&#10;    " file=""/>) routine is implemented via a call to <code>plcont</code> (<pxref node="&#10;      plcont; Contour plot&#10;    " file=""/>) with a
	very simple (identity) transformation function, while <code>plcon1</code> (<pxref node="&#10;      plcon1; Contour plot; general 1-d mapping for&#10;fortran&#10;    " file=""/>) and
	<code>plcon2</code> (<pxref node="&#10;      plcon2; Contour plot; general 2-d mapping for&#10;fortran&#10;    " file=""/>) use interpolating transformation functions as well as
	a call to
	<code>plcont</code> (<pxref node="&#10;      plcont; Contour plot&#10;    " file=""/>).
      </para><para>
	The transformation arrays are used by these routines to specify a
	mapping between the computational coordinate system and the
	physical one.  For example, the transformation to polar coordinates
	might look like:
      </para><para>
	<example>    do i = 1, NX
        do j = 1, NY
            xg(i, j) = r(i) * cos( theta(j) )
            yg(i, j) = r(i) * sin( theta(j) )
        enddo
    enddo</example>
      </para><para>
	assuming the user had already set up arrays <samp>r</samp>
	and <samp>theta</samp> to specify the (r, theta) values at
	the gridpoints in his system.  For this example, it is recommended
	that the user add an additional cell in theta such that
	<samp>xg(i, NY+1) = xg(i, 1)</samp> and <samp>yg(i, NY+1)
	= yg(i, 1)</samp> so that the contours show the proper periodic
	behavior in theta (see also example program 9).
      </para><para>
	The transformation function not only specifies the transformation
	at grid points, but also at intermediate locations, via linear
	interpolation.  For example, in the <samp>pltr1</samp>
	transformation function used by <code>plcon1</code> (<pxref node="&#10;      plcon1; Contour plot; general 1-d mapping for&#10;fortran&#10;    " file=""/>), the 1-d interpolation to
	get <samp>tx</samp> as a function of <samp>x</samp>
	looks like (in C):
      </para><para>
	<example>    ul = (PLINT)x;
    ur = ul + 1;
    du = x - ul;

    xl = *(xg+ul);
    xr = *(xg+ur);

    *tx = xl * (1-du)  +  xr * du;</example>
      </para><para>
	while in Fortran this might look like:
      </para><para>
	<example>    lxl = x
    lxr = lxl + 1
    dx = x - lxl

    xl = xg(lxl)
    xr = xg(lxr)

    tx = xl * (1-dx)  +  xr * dx</example>
      </para><node name="Shade Plots from Fortran" previous="Contour Plots from Fortran" up="Contour and Shade Plots"/><subsection>Shade Plots from Fortran</subsection><para>
        NEEDS DOCUMENTATION
      </para><node name="Deploying programs that use PLplot" previous="Advanced Use of PLplot" next="The PLplot Display Driver Family" up="Top"/><chapter>Deploying programs that use PLplot</chapter><para>
    This chapter provides some information on the issue of
    delivering programs that use PLplot: what files should be installed and
    where, what environment variables are involved and related matters.
  </para><para>
    The scenario is this: You have created one or more programs that run
    successfully on your development machine and now you need to install
    them on the machine of a user.
  </para><para>
    One solution is to provide him or her with the full development
    environment that you use, but that is in general only an option if your
    user is comfortable with making programs themselves. A more common
    situation is that your user just wants the executable programs and
    wants to get using them rightaway. We will focus on this particular
    solution, as there are a few non-trivial issues.
  </para><para>
    To be absolutely clear about what we are describing, here is a summary:
    <itemize markchar="•"><listitem><para>
          Your program must run on a machine that does not have PLplot
          installed from the sources.
        </para></listitem><listitem><para>
          There is no development environment that you can rely on.
        </para></listitem><listitem><para>
          The program should be installed in a self-contained directory
          structure (which <i>can</i> be
          <file>/usr/local</file> or <file>c:\program</file>
          files or whatever, but need not be so).
        </para></listitem></itemize>
  </para><para>
    Under Linux, the easiest way to install a binary version of PLplot on a
    user's machine is to use PLplot deb binary packages for the <uref url="http://www.debian.org">Debian</uref> distribution, and PLplot rpm
    binary packages for rpm-based distributions. (See the <uref url="http://plplot.sourceforge.net/resources/index.html">Resources
    area</uref> of the PLplot web site for locations of debs and rpms.)
    Build the application on the build machine using the results of the
    <samp>plplot-config --cflags --libs</samp> command, and copy
    the resulting executable(s) to the users' machines.
  </para><para>
    Under Unix (and also under Linux if you would prefer to use a newer
    version of PLplot than is available in the debs or rpms), a good way
    to deploy binary PLplot and applications that depend on that binary PLplot
    on users' machines is as follows:
    <itemize markchar="•"><listitem><para>
	  Use the <code>./configure</code> option
	  <samp>--prefix=/usr/local/plplot</samp> (or some other
	  unique but consistent directory that is available on the build
	  machine and all users' machines).
        </para></listitem><listitem><para>
	  Build and install as normal on the build machine.
        </para></listitem><listitem><para>
	  Copy the installed PLplot tree,
	  <file>/usr/local/plplot</file>, into a tarball.
        </para></listitem><listitem><para>
	  Unpack that tarball on all users' machines in the same location
	  <file>/usr/local/plplot</file>.
        </para></listitem><listitem><para>
	  Build the application(s) on the build machine using the results
	  of the <samp>plplot-config --cflags --libs</samp>
	  command, and copy the resulting executable(s) to the users'
	  machines.  Since the PLplot install location is consistent on all
	  machines, the application should work the same way on all
	  machines.
        </para></listitem></itemize>
  </para><para>
    On Windows, and also those rare Linux/Unix cases where you cannot install
    the PLplot install tree in a consistent location on users' machines, then
    there are some additional options you need to consider.
  </para><para>
    There are three situations depending on how you configure and
    build the PLplot libraries:
    <enumerate><listitem><para>
          You use the static versions of the PLplot libraries and devices
	  which are not dynamically loaded.
          <footnote>
              UNIX-like systems libraries can be static or shared, the first
              type becoming part of the program, the second existing as a
              separate file. On Windows the terms are respectively static
              and dynamic (the latter type is also known as DLL).
            </footnote>
        </para></listitem><listitem><para>
          You use the shared versions of the PLplot libraries and devices
	  which are not dynamically loaded.
        </para></listitem><listitem><para>
          You use the shared versions of the PLplot library and devices
	  which are dynamically loaded.  This combination is the default
	  option under Unix/Linux.
        </para></listitem></enumerate>
  </para><para>
    In the <i>first</i> case the program will contain all the
    code it needs to work, but to run successfully, it needs to find the
    font files, <file>plstnd5.fnt</file> and
    <file>plxtnd5.fnt</file>. The mechanism used in PLplot to find
    these files is fairly simple:
    <itemize markchar="•"><listitem><para>
          It looks at a number of built-in places, determined at the time
          the PLplot library itself was installed and built. For deployment
          these places are irrelevant in general.
        </para></listitem><listitem><para>
          It looks at the environment variables
          <code>PLPLOT_LIB</code> and <code>PLPLOT_HOME</code>.
          (Actually, this happens only, if the corresponding compiler
          macros <code>PLPLOT_LIB_ENV</code> and
          <code>PLPLOT_HOME_ENV</code> were defined at compile time.)
        </para></listitem><listitem><para>
          <i>(TODO: remark about Mac)</i>
        </para></listitem></itemize>
  </para><para>
    Note: This is also the place to put the geographical map files, if you
    happen to use them.
  </para><para>
    The environment variables should point to the directory holding the two
    font files or the one above (one variable is enough though):
    <itemize markchar="•"><listitem><para>
          <code>PLPLOT_LIB</code> should point to the directory
          actually holding these files
        </para></listitem><listitem><para>
          <code>PLPLOT_HOME</code> should point to the directory that
          holds a subdirectory <file>lib</file>
          which in turn holds these files.
        </para></listitem></itemize>
  </para><para>
    If it can find these, PLplot can do its job.
  </para><para>
    Note: This is the case for instance when you use the static PLplot
    library on Windows (see the directory
    <file>sys\win32\msdev\plplib</file>).
  </para><para>
    In the <i>second </i> case the font and map files are found
    as in the <i>first</i> case.  In addition, you also
    require another environment variable so the PLplot shared libraries can
    be found at run time by the run-time loader.  The details depend on the
    system you are working on, but here are some common platforms:
    <itemize markchar="•"><listitem><para>
          Most UNIX, BSD and Linux systems use an environment variable
          <code>LD_LIBRARY_PATH</code> which indicates 
          directories where shared libraries can be found. Some use
          <code>SHLIB_PATH</code>, like HPUX.
        </para></listitem><listitem><para>
          On Windows the PATH variable is used to find the DLLs, but
          beware: Windows uses a number of places to find the DLLs a
          program needs and the ordering seems to depend on some intricate
          details. It seems easiest and safest to put the DLLs in the same
          directory as your program.
        </para></listitem><listitem><para>
          On MacOSX, ... <i>TODO</i>
        </para></listitem></itemize>
  </para><para>
    In the <i>third</i> (default) case, the PLplot fonts and
    maps are found as in the <i>first</i> case, and the 
    shared libraries are found as in the <i>second</i> case,
    but in addition the separated dynamic devices have to be found as well.
  </para><para>
    When PLplot uses dynamic devices, it first builds up a list of them, by
    examining a directory which contains files describing those devices:
    the <file>*.rc</file> files. Each of these files indicates what
    the relevant properties for the device or devices. Then when the
    device is actually needed, the corresponding shared object (or plug-in
    or DLL depending on your terminology) is dynamically loaded.
  </para><para>
    The directory that contains all these files (the device descriptions as
    well as the actual libraries and the description files that libtool
    uses) is a directory determined at the time you configured
    PLplot which is typically something like
    <file>/usr/local/plplot/lib/plplot5.3.1/driversd</file>.  This
    directory must be pointed to by the <code>PLPLOT_DRV_DIR</code>
    environment variable. Again for deployment, only the environment
    variable is of real interest.
  </para><para>
    To summarise the case where you don't have a deb or rpm option, and
    you must use inconsistent install locations on your users' machines:
    <itemize markchar="•"><listitem><para>
          The following environment variables are important:
          <itemize markchar="•"><listitem><para>
                <code>PLPLOT_HOME</code> or
                <code>PLPLOT_LIB</code> to indicate the position of
                font files (and also of the various geographic maps)
              </para></listitem><listitem><para>
                <code>LD_LIBRARY_PATH</code>,
                <code>SHLIB_PATH</code> or <code>PATH</code> to
                find the dynamic/shared libraries
              </para></listitem><listitem><para>
                <code>PLPLOT_DRV_DIR</code> to find the device
                descriptions
              </para></listitem></itemize>
        </para></listitem><listitem><para>
          The following files being part of PLplot must be distributed
          along with your program:
          <itemize markchar="•"><listitem><para>
                The font files (<file>plstnd5.fnt</file> and
                <file>plxtnd5.fnt</file>) and, possibly, if you use
                them, the geographic map files.
              </para></listitem><listitem><para>
                The PLplot shared libraries
              </para></listitem><listitem><para>
                The device description files and the device shared object files
              </para></listitem></itemize>
        </para></listitem></itemize>
  </para><para>
    All the environment variables, except
    <code>LD_LIBRARY_PATH</code> and equivalents, can be set within
    the program (by using a small configuration file or by determining the
    position of the files relative to the program's location). They just
    have be set before PLplot is initialised.
  </para><node name="The PLplot Display Driver Family" previous="Deploying programs that use PLplot" next="The PLplot Output Driver Family" up="Top"/><chapter>The PLplot Display Driver Family</chapter><para>
  Drivers that provide screen displays are described in this chapter.  
  Each of the drivers has a list of options, and these may be set as 
  outlined in <ref node="Command Line Arguments" file="">Command Line Arguments</ref>.
</para><menu><menuentry node="The Xwin Driver [X-Windows]"><menuentrytitle>The Xwin Driver (X-Windows)</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="The GCW Driver [Gnome 2]"><menuentrytitle>The GCW Driver (Gnome 2)</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="The Tk Driver"><menuentrytitle>The Tk Driver</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="The AquaTerm Driver [Mac OS X]"><menuentrytitle>The AquaTerm Driver (Mac OS X)</menuentrytitle><menuentrydescrip/></menuentry></menu><node name="The Xwin Driver [X-Windows]" next="The GCW Driver [Gnome 2]" up="The PLplot Display Driver Family"/><section>The Xwin Driver (X-Windows)</section><para> 
    The Xwin driver draws plots in an X-window.  Although some of the
    newer features are not supported, it remains the reference driver
    for PLplot.
  </para><para>
    Plots are displayed one page at a time.  The pager is advanced by 
    pressing the Enter key, and may only be advanced in the foreward
    direction.
  </para><para>
    Anti-aliasing is not supported, and the Xwin driver is not 
    unicode-enabled.
  </para><para>
    The available driver options are:
    <itemize markchar="•"><listitem><para>
        sync: Synchronized X server operation (0|1)
      </para></listitem><listitem><para>
        nobuffered: Sets unbuffered operation (0|1)
      </para></listitem><listitem><para>
        noinitcolors: Sets cmap0 allocation (0|1)
      </para></listitem><listitem><para>
        defvis: Use the Default Visual (0|1)
      </para></listitem><listitem><para>
          usepth: Use pthreads (0|1)
        </para></listitem></itemize>
  </para><node name="The GCW Driver [Gnome 2]" previous="The Xwin Driver [X-Windows]" next="The Tk Driver" up="The PLplot Display Driver Family"/><section>The GCW Driver (Gnome 2)</section><para> 
    The GCW driver draws plots into a tabbed Gnome window.  The driver's
    features and user interface are described in 
    <ref node="GCW Driver Basics" file="">GCW Driver Basics</ref>.  A specialized API allows 
    interaction with the driver, and this is described in 
    <ref node="GCW Driver API" file="">GCW Driver API</ref>.
  </para><menu><menuentry node="GCW Driver Basics"><menuentrytitle>GCW Driver Basics</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="GCW Driver API"><menuentrytitle>GCW Driver API</menuentrytitle><menuentrydescrip/></menuentry></menu><node name="GCW Driver Basics" next="GCW Driver API" up="The GCW Driver [Gnome 2]"/><subsection>GCW Driver Basics</subsection><para>
      The GCW driver plots each page into an individual tab within
      a Gnome window.  The user interface built into the window allows 
      a variety of actions.  In particular, pages can be saved to files
      with extensions .ps, .psc, .png, .jpg, and .gif, which correspond 
      to PLplot output driver devices described in 
      <ref node="The PLplot Output Driver Family" file="">The PLplot Output Driver Family</ref>.
    </para><para>
      The GCW driver supports anti-aliasing and is unicode enabled.
    </para><para>
      There are a variety of hot keys that may be used in the user interface:
      <itemize markchar="•"><listitem><para>Arrows : Change page</para></listitem><listitem><para>+ : Zooms in</para></listitem><listitem><para>- : Zooms out</para></listitem><listitem><para>= : Zooms to 100%</para></listitem><listitem><para>q : Quits</para></listitem></itemize>
    </para><para>
      The available driver options (used with the
      <code>-drvopt</code> command-line argument) are:
      <itemize markchar="•"><listitem><para>
          text: Use TrueType fonts (0|1); default 1
	</para></listitem><listitem><para>
	  pixmap: Use pixmap for plotting lines and shades (0|1); 
	  default 1
	</para></listitem><listitem><para>
	  hrshsym: Use Hershey symbol set (0|1); default 0
	</para></listitem></itemize>
    </para><para>
      The <code>text</code> option toggles between TrueType and
      Hershey fonts.  The Hershey fonts provide a reference implementation
      for text representation in PLplot.
    </para><para>
      The <code>hrshsym</code> option is used to indicate that
      symbols should be drawn using the Hershey fonts.  This is
      useful when plots need to be saved to PostScript files, because
      the Type I fonts used by the PS and PSC devices do not support all
      Unicode symbols.
    </para><para>
      Most of the command-line arguments described in
      <ref node="Command Line Arguments" file="">Command Line Arguments</ref> are also supported.  Some key arguments
      for use with the GCW driver are:
      <itemize markchar="•"><listitem><para>
	  geometry geom:  Sets page size, in pixels (e.g. -geometry 400x300)
	</para></listitem><listitem><para>
	  nopixmap: Disables pixmap usage for plotting lines and shades
	</para></listitem><listitem><para>
	  portrait: Sets portrait mode (both orientation and aspect ratio)
	</para></listitem></itemize>
    </para><para>
      The <code>nopixmap</code> option disables the use of
      the internal pixmap for drawing lines and shades, which will 
      normally appear somewhat pixelated.  The 
      <code>nopixmap</code> option directs the driver to use 
      anti-aliased vector graphics instead, resulting in higher quality
      plots but rendered at a slower speed.  This option does not affect 
      the quality of plots saved from the GCW user interface.  Note that
      the TrueType fonts are always anti-aliased.
    </para><node name="GCW Driver API" previous="GCW Driver Basics" up="The GCW Driver [Gnome 2]"/><subsection>GCW Driver API</subsection><para>
      The GCW driver provides an additional API that allows for a higher
      degree of control by the user.  The C API is described below, and
      bindings to other languages are described in
      *** NEEDS DOCUMENTATION ***.
    </para><para>
      The function prototypes are defined in <file>gcw.h</file>.
      Programs that need access to this API must be linked against the 
      libplplotgnome2d library rather than libplplotd.  This is most easily 
      accomplished using pkg-config; i.e.,

      <example>
        gcc x01c.c -o x01c `pkg-config --cflags --libs plplotd-gnome2`
      </example>

      You may need to remind pkg-config where to look for the 
      plplotd-gnome2 file installed by PLplot; e.g.,

      <example>
        gcc x01c.c -o x01c `PKG_CONFIG_PATH=/usr/local/lib/pkgconfig pkg-config --cflags --libs plplotd-gnome2`
      </example>
    </para><menu><menuentry node="gcw_use_text; Sets font usage_"><menuentrytitle>gcw_use_text: Sets font usage.</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="gcw_use_pixmapSets pixmap usage_"><menuentrytitle>gcw_use_pixmapSets pixmap usage.</menuentrytitle><menuentrydescrip/></menuentry></menu><node name="gcw_use_text; Sets font usage_" next="gcw_use_pixmapSets pixmap usage_" up="GCW Driver API"/><subsubsection>gcw_use_text: Sets font usage.</subsubsection><para>
        <quotation><para><t><b>void gcw_use_text</b>(<i>use_text</i>);</t></para></quotation>
      </para><para>
        Sets whether TrueType text or Hershey fonts are used.
      </para><varlist><varlistentry><term>
            <code>use_text</code> (<samp>PLINT</samp>, input)
          </term><listitem><para>
            1 for TrueType fonts (default), 0 for Hershey fonts.
          </para></listitem></varlistentry></varlist><node name="gcw_use_pixmapSets pixmap usage_" previous="gcw_use_text; Sets font usage_" up="GCW Driver API"/><subsubsection>gcw_use_pixmapSets pixmap usage.</subsubsection><para>
        <quotation><para><t><b>void gcw_use_pixmap</b>(<i>use_pixmap</i>);</t></para></quotation>
      </para><para>
        Sets whether lines and shades are drawn to a pixmap,
        or instead as vector graphics.
      </para><para>
        Lines and shade drawn to the pixmap may appear pixelated.
        Vector graphics are fully anti-aliased, but are rendered at a 
        slower speed.
      </para><varlist><varlistentry><term>
            <code>use_pixmap</code> 
            (<samp>PLINT</samp>, input)
          </term><listitem><para>
            1 to use pixmap (default), 0 for vector graphics instead.
          </para></listitem></varlistentry></varlist><node name="The Tk Driver" previous="The GCW Driver [Gnome 2]" next="The AquaTerm Driver [Mac OS X]" up="The PLplot Display Driver Family"/><section>The Tk Driver</section><para> 
      is the prototype of a whole new interaction paradigm.  See next
      chapter.
    </para><node name="The AquaTerm Driver [Mac OS X]" previous="The Tk Driver" up="The PLplot Display Driver Family"/><section>The AquaTerm Driver (Mac OS X)</section><para> 
      The AquaTerm driver is a Mac OS X specific driver that is used with 
      the AquaTerm Graphics Terminal. It is unicode enabled. Text, lines
      and shades are anti-aliased.
    </para><para>
      There are no options...
    </para><node name="The PLplot Output Driver Family" previous="The PLplot Display Driver Family" next="C Language" up="Top"/><chapter>The PLplot Output Driver Family</chapter><para>
    Drivers which produce output files are described in this chapter.  
    Each of the drivers has a list of options, and these may be set as 
    outlined in <ref node="Command Line Arguments" file="">Command Line Arguments</ref>.
  </para><menu><menuentry node="The Postscript Driver"><menuentrytitle>The Postscript Driver</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="The GD Driver"><menuentrytitle>The GD Driver</menuentrytitle><menuentrydescrip/></menuentry></menu><node name="The Postscript Driver" next="The GD Driver" up="The PLplot Output Driver Family"/><section>The Postscript Driver</section><para> 
      The Postscript driver produces publication-quality postscript
      output.  The driver provides two devices: the ps device for 
      black-and-white plots, and the psc device for color plots.
    </para><para>
      This driver is unicode enabled, and PostScript Type I fonts are used.
      Type I fonts do not have all of the available unicode symbols
      represented.  For this reason, Hershey fonts are used for drawing 
      symbols by default, unless specified otherwise using the driver options.
    </para><para>
      The available driver options are:
      <itemize markchar="•"><listitem><para>
          text: Use Postscript text (0|1); default 1
        </para></listitem><listitem><para>
          hrshsym: Use Hershey fonts for symbols (0|1); default 1
        </para></listitem></itemize>
    </para><node name="The GD Driver" previous="The Postscript Driver" up="The PLplot Output Driver Family"/><section>The GD Driver</section><para> 
      The GD driver produces png, jpeg, and gif images, using devices by 
      the same name.  The GD driver is unicode enabled.  Text is 
      anti-aliased, but lines and shades are not.
    </para><para>
      The available driver options are:
      <itemize markchar="•"><listitem><para>
          optimise: Optimise PNG palette when possible
        </para></listitem><listitem><para>
          def_black15: Define idx 15 as black. If the background is 
          "whiteish" (from "-bg" option), force index 15 (traditionally 
           white) to be "black"
        </para></listitem><listitem><para>
          swp_red15: Swap index 1 (usually red) and 1 (usually white); 
          always done after "black15"; quite useful for quick changes to
          web pages
        </para></listitem><listitem><para>8bit: Palette (8 bit) mode</para></listitem><listitem><para>24bit: Truecolor (24 bit) mode</para></listitem><listitem><para>text: Use driver text (FreeType)</para></listitem><listitem><para>
          smooth: Turn text smoothing on (1) or off (0)
        </para></listitem></itemize>
    </para><node name="C Language" previous="The PLplot Output Driver Family" next="Fortran Language" up="Top"/><chapter>C Language</chapter><para>
(OLD, NEEDS DOCUMENTATION UPDATING)
The argument types given in this manual (PLFLT and PLINT) are typedefs for
the actual argument type.  A PLINT is actually a type
<samp>long</samp> and should not be changed.  A PLFLT can be either a
<samp>float</samp> or <samp>double</samp>; this choice is made
when the package is installed and on a Unix system (for example) may result
in a PLplot library named <file>libplplot.a</file> in single
precision and <file>libplplotd.a</file> in double precision.
  </para><para>
These and other constants used by PLplot are defined in the main header file
<file>plplot.h</file>, which must be included by the user program.  This file also
contains all of the function prototypes, machine dependent defines, and
redefinition of the C-language bindings that conflict with the Fortran names
(more on this later).  <file>plplot.h</file> obtains its values for PLFLT, PLINT,
and PLARGS (a macro for conditionally generating prototype argument lists)
from FLOAT (typedef), INT (typedef), and PROTO (macro), respectively.
The latter are defined in the file
<file>chdr.h</file>.  The user is encouraged to use FLOAT, INT, and PROTO in
his/her own code, and modify <file>chdr.h</file> according to taste.  It is not
actually necessary to declare variables as FLOAT and INT except when they
are pointers, as automatic conversion to the right type will otherwise occur
(if using a Standard C compiler; else K&amp;R style automatic promotion will
occur).  The only code in <file>plplot.h</file> that directly depends on these
settings is as follows:
<example>
#include "plplot/chdr.h"

/* change from chdr.h conventions to plplot ones */

typedef FLOAT PLFLT;
typedef INT   PLINT;
#define PLARGS(a) PROTO(a)
</example>
  </para><para>
PLplot is capable of being compiled with Standard C (ANSI) mode on or off.
This is toggled via the macro PLSTDC, and set automatically if __STDC__
is defined.  If PLSTDC is defined, all functions are prototyped as allowed
under Standard C, and arguments passed exactly as specified in the
prototype.  If PLSTDC is not defined, however, function prototypes are
turned off and K&amp;R automatic argument promotion will occur, e.g.
<samp> float &amp;rarr; double, int &amp;rarr; long</samp>.
There is no middle ground!  A PLplot
library built with PLSTDC defined will not work (in general) with a program
built with PLSTDC undefined, and vice versa.  It is possible in principle to
build a library that will work under both Standard C and K&amp;R compilers
simultaneously (i.e.  by duplicating the K&amp;R promotion with the Standard C
prototype), but this seems to violate the spirit of the C standard and can
be confusing.  Eventually we will drop support for non-standard C compilers
but for now have adopted this compromise.
  </para><para>
In summary, PLplot will work using either a Standard or non-standard C
compiler, provided that you :
<itemize markchar="•"><listitem><para>
Include the PLplot main header file <file>plplot.h</file>.
</para></listitem><listitem><para>
Make sure all pointer arguments are of the correct type
(the compiler should warn you if you forget, so don't worry, be happy).
</para></listitem><listitem><para>
Do not link a code compiled with PLSTDC defined to a PLplot library
compiled with PLSTDC undefined, or vice versa.
</para></listitem><listitem><para>
Use prototypes whenever possible to reduce type errors.
</para></listitem></itemize>
  </para><para>
Note that some Standard C compilers will give warnings when converting a
constant function argument to whatever is required by the prototype.  These
warnings can be ignored.
  </para><para>
The one additional complicating factor concerns the use of stub routines to
interface with Fortran (see the following section for more explanation).  On
some systems, the Fortran and C namespaces are set up to clobber each other.
More reasonable (from our viewpoint) is to agree on a standard map between
namespaces, such as the appending of an underscore to Fortran routine names
as is common on many Unix-like systems.  The only case where the shared
Fortran/C namespaces do any good is when passing a pointer to a like data
type, which represents only a small fraction of the cases that need to
be handled (which includes constant values passed on the stack, strings, and
two-dimensional arrays).
  </para><para>
There are several ways to deal with this situation, but the least messy from
a user's perspective is to redefine those PLplot C function names which
conflict with the Fortran-interface stub routines.  The actual function
names are the same as those described in this document, but with a
c_
prepended.  These macro definitions appear in the
<file>plplot.h</file> header file
and are otherwise harmless.  Therefore you can (and should) forget that most
of the names are being redefined to avoid the conflict and simply adhere to
the bindings as described in this manual.  Codes written under old versions
of PLplot (previous to 5.0) will require a recompile, however.
  </para><para>
For more information on calling PLplot from C, please see the example C
programs (<file>x01c.c</file> through <file>x19c.c</file>)
distributed with PLplot.
  </para><node name="Fortran Language" previous="C Language" next="A C++ Interface for PLplot" up="Top"/><chapter>Fortran Language</chapter><para>
As discussed in the preceding section, PLplot's integer representation is a
PLINT and its floating point representation is a PLFLT.  To the
Fortran user, this most commonly translates to a type
<samp>integer</samp> and
type <samp>real</samp>, respectively.  This is somewhat system dependent (and up to
the installer of the package) so you should check the release notes to be
sure, or just try it and see what happens.
  </para><para>
Because the PLplot kernel is written in C, standard C syntax is used in the
description of each PLplot function.  Thus to understand this manual it is
helpful to know a little about C, but fortunately the translation is very
easy and can be summarized here.  As an example, the routine 
<code>plline</code> (<pxref node="&#10;      plline; Draw a line&#10;    " file=""/>) call from C would look like:
<example>
	plline(n,x,y);
</example>
while from Fortran it would look like:
<example>
	call plline(n,x,y)
</example>
typically with <samp>n</samp> declared as type
<samp>integer</samp> and <samp>x</samp>, <samp>y</samp>
declared as type <samp>real</samp> (arrays in this case).  
Each C language type
used in the text translates roughly as follows:
	<multitable cols="2"><colspec width="1" colnum="1"/><colspec width="1" colnum="2"/><tbody><row><entry>PLFLT</entry><entry>real</entry></row><row><entry>PLINT</entry><entry>integer</entry></row><row><entry>char *</entry><entry>character</entry></row><row><entry>PLFLT *</entry><entry>real or real array</entry></row><row><entry>PLFLT **</entry><entry>real array</entry></row><row><entry><samp>"string"</samp></entry><entry><samp>'string'</samp></entry></row><row><entry>array[0]</entry><entry>array(1)</entry></row></tbody></multitable>
In C there are two ways to pass a variable --- by value (the default) or by
reference (pointer), whereas only the latter is used by Fortran.
Therefore when you see references in the text to <i>either</i> an ordinary
argument or a pointer argument (e.g.  <samp>*data</samp>), you simply use an
ordinary Fortran variable or array name.
  </para><para>
The PLplot library comes with a set of Fortran interface routines that
allow the exact same call syntax (usually) regardless of whether calling
from C or Fortran.  In some cases, this means the subroutine name <i>
exceeds 8 characters in length</i>.  Nearly every Fortran compiler
available
today allows subroutine names longer than 8 characters, so this should not
be a problem (although if it ever is, in principle a truncated name could
be defined for that platform).
  </para><para>
These stub routines handle transforming the data
from the normal Fortran representation to that typically used in C.  This
includes:
<itemize markchar="•"><listitem><para>
Variables passed by value instead of by reference.
  </para><para>
Fortran passes all subroutine arguments by reference, i.e., a pointer to the
argument value is pushed on the stack.  In C all values, except for arrays
(including char arrays), are passed by value, i.e., the argument value
itself is pushed on the stack.  The stub routine converts the Fortran call
by reference to a call by value.  As an example, here is how the plpoin stub
routine works.  In your Fortran program you might have a call to plpoin that
looks something like
<example>
      call plpoin(6,x,y,9)
</example>
where x and y are arrays with 6 elements and you want to plot symbol 9.
As strange as it seems (at least to C programmers) the constants 6 and
9 are passed by reference.   This will actually call the following C
stub routine (included in entirety)
<example>
#include "plplot/plstubs.h"

void 
PLPOIN(n, x, y, code)
PLINT *n, *code;
PLFLT *x, *y;
{
    c_plpoin(*n, x, y, *code);
}
</example>
All this stub routine does is convert the number of points
(<samp>*n</samp> and the
symbol <samp>*code</samp> to call by value (i.e.  pushes their value on the stack)
and then calls the C plpoin library routine.
</para></listitem><listitem><para>
Get mapping between Fortran and C namespace right (system dependent).
  </para><para>
The external symbols (i.e. function and subroutine names) as you see them
in your program often appear differently to the linker.  For example, the
Fortran routine names may be converted to uppercase or lowercase, and/or
have an underscore appended or prepended.  This translation is handled
entirely via redefinition of the stub routine names, which are macros.
There are several options for compiling PLplot that simplify getting the
name translation right (NEEDS DOCUMENTATION IF THESE STILL EXIST).  In any
case, once the name translation is established during installation, name
translation is completely transparent to the user.
</para></listitem><listitem><para>
Translation of character string format from Fortran to C.
  </para><para>
Fortran character strings are passed differently than other quantities, in
that a string descriptor is pushed on the stack along with the string
address.  C doesn't want the descriptor, it wants a NULL terminated string.
For routines that handle strings two stub routines are necessary, one
written in Fortran and one written in C.  Your Fortran program calls the
Fortran stub routine first.  This stub converts the character string to a
null terminated integer array and then calls the C stub routine.  The C
stub routine converts the integer array (type <samp>long</samp>) to the usual C
string representation (which may be different, depending on whether your
machine uses a big endian or little endian byte ordering; in any case the
way it is done in PLplot is portable).  See the <samp>plmtex</samp> stubs for an
example of this. 
  </para><para>
Note that the portion of a Fortran character string that exceeds 299
characters will not be plotted by the text routines (<samp>plmtex</samp>
and <samp>plptex</samp>). 
</para></listitem><listitem><para>
Multidimensional array arguments are changed from row-dominant to
column-dominant ordering through use of a temporary array.
  </para><para>
In Fortran, arrays are always stored so that the first index increases most
rapidly as one steps through memory.  This is called
row-dominant
storage.  In C, on the other hand, the first index increases 
<i>least</i>
rapidly, i.e. column-dominant ordering.  Thus, two dimensional arrays
(e.g.  as passed to the contour or surface plotting routines) passed into
PLplot must be transposed in order to get the proper two-dimensional
relationship to the world coordinates.  This is handled in the C stub
routines by dynamic memory allocation of a temporary array.  This is then set
equal to the transpose of the passed in array and passed to the appropriate
PLplot routine.  The overhead associated with this is normally not important
but could be a factor if you are using very large 2d arrays.
</para></listitem></itemize>
  </para><para>
This all seems a little messy, but is very user friendly.  Fortran and C
programmers can use the same basic interface to the library, which is a
powerful plus for this method.  The fact that stub routines are being used
is completely transparent to the Fortran programmer.
  </para><para>
For more information on calling PLplot from Fortran, please see the
example Fortran programs (<file>x01f.f</file> through
<file>x16f.f</file>) distributed
with PLplot.
  </para><node name="A C++ Interface for PLplot" previous="Fortran Language" next="Using PLplot from Tcl" up="Top"/><chapter>A C++ Interface for PLplot</chapter><para>
PLplot has long had C and Fortran bindings, presenting a fairly
conventional API to the applications programmer.  Recently (1994
onwards) PLplot has been growing interfaces (language bindings) to a
variety of other languages.  In this chapter we discuss the PLplot C++
support provided in the PLplot distribution.  Of course many other
approaches are possible, perhaps even in use by PLplot users around
the world.  The purpose of this chapter then is to explain the
rationale and intended usage for the bundled C++ language support.
    </para><menu><menuentry node="Motivation for the C++ Interface"><menuentrytitle>Motivation for the C++ Interface</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Design of the PLplot C++ Interface"><menuentrytitle>Design of the PLplot C++ Interface</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Specializing the PLplot C++ Interface"><menuentrytitle>Specializing the PLplot C++ Interface</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Status of the C++ Interface"><menuentrytitle>Status of the C++ Interface</menuentrytitle><menuentrydescrip/></menuentry></menu><node name="Motivation for the C++ Interface" next="Design of the PLplot C++ Interface" up="A C++ Interface for PLplot"/><section>Motivation for the C++ Interface</section><para>
PLplot has a fairly complex C API.  There are lots of functions, and
several facilities have multiple entry points with similar names but
different argument lists.  (Think contouring, shading).  Often these
differing argument lists are to accommodate a variety of data storage
paradigms, one of which you are expected to be using!
    </para><para>
Especially in the case of the 2-d API's for contouring and shading,
sophisticated C++ users may feel a special sense of exasperation with
the data layout prescriptions, since they are extremely primitive,
pointer rich, and prone to a wide class of memory leaks and other
sorts of programming errors.  Many C++ users know good and well that
better ways exist (templated matrix classes, etc), but historically
have not been able to use these more sophisticated techniques if the
contained data ever needed to get plotted.
    </para><para>
Besides the 2-d API functions, there is also the multiple output
stream capability of PLplot.  Anyone who knows C++ well, and who has
used multiple output streams in PLplot, has probably noticed striking
similarities between the PLplot <samp>PLStream</samp> pointer and the C++ 
<samp>this</samp> pointer.  Although multiple output streams have not been 
widely used in PLplot applications in the past, the availability of
the plframe Tk widget, and the extended wish concept, is making it
much more attractive to use multiple output streams.
    </para><para>
Unfortunately, if you do write a Tk extended wish application, and
endow your interface with multiple plframes, the event driven
character of X applications makes it difficult to ensure that PLplot
output shows up in the right plframe window.  If a plot is generated
to one plframe, the PLplot <samp>PLStream</samp> pointer is directed to that
stream.  If a user then pushes a Tk button which should generate a
plot to a different plframe, the plot goes to the old plframe instead!
Schemes for controlling this can be imagined, but the logic can be
complex, especially in the face of the ability to /also/ make plots to
the same plframe from either Tcl or C++.
    </para><para>
Beyond this, the C API is downright "ugly" for a significant number of
the functions, particularly those which return values by accepting
pointers to variables in their argument lists, and then changing them
in that way.  Sophisticated C++ users generally take considerable
pride in banishing the offensive bare pointer from their code, and
consider it disgusting to have to insert &amp;'s just in order to make a
call to an API function.
    </para><para>
In order to address these issues (and more), I have begun constructing
a C++ interface to PLplot.  The purpose of this missive is to describe
its architecture and usage.
    </para><node name="Design of the PLplot C++ Interface" previous="Motivation for the C++ Interface" next="Specializing the PLplot C++ Interface" up="A C++ Interface for PLplot"/><section>Design of the PLplot C++ Interface</section><menu><menuentry node="Stream/Object Identity"><menuentrytitle>Stream/Object Identity</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Namespace Management"><menuentrytitle>Namespace Management</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Abstraction of Data Layout"><menuentrytitle>Abstraction of Data Layout</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Collapsing the API"><menuentrytitle>Collapsing the API</menuentrytitle><menuentrydescrip/></menuentry></menu><node name="Stream/Object Identity" next="Namespace Management" up="Design of the PLplot C++ Interface"/><subsection>Stream/Object Identity</subsection><para>
A C++ class named <samp>plstream</samp> has been introduced.  It's central
purpose is provide a specific, object based encapsulation of the
concept of a PLplot output stream.  Any output produced using a
<samp>plstream</samp> object, will go to the PLplot output stream associated with
that object, regardless of what stream may have been active before.  
    </para><para>
In order to write a multiple output stream PLplot application, a C++
program can declare <samp>plstream</samp> objects, and invoke drawing methods on
those objects, without regard to ordering considerations or other
coherency considerations.  Although this has obvious simplification
benefit even for simple programs, the full benefit is most easily
appreciated in the context of Tk extended wish applications in which a
<samp>plstream</samp> can be associated with each plframe.
    </para><node name="Namespace Management" previous="Stream/Object Identity" next="Abstraction of Data Layout" up="Design of the PLplot C++ Interface"/><subsection>Namespace Management</subsection><para>
The PLplot C API is composed of a set of drawing functions, all
prefixed with "pl", in an effort to prevent namespace collision.
However, the prefix "pl" is gratuitous, and in particular is
unnecessary in a C++ context.  The <samp>plstream</samp> class mirrors most
of the PLplot C API, but does so by dropping the "pl" prefix.  The
<samp>plstream</samp> class thus serves to collect the PLplot drawing
functions into a scope in which collisions with other similarly named
functions is not a concern.  So, where a C programmer might write:
</para><example>
        plsstrm( 1 );
	plenv( ... );
	plline( ... );
</example><para>
The C++ programmer can write:
</para><example>
	plstream p( ... );
	p.env( ... );
	p.line( ... );
</example><para>
Is that an important benefit?  The utility varies with the number of
output streams in use in the program.
    </para><para>
plmkstrm() is replaced by object declaration.  plsstrm() is replaced by
method invocation on the desired output stream object.  plgstrm() is
rendered irrelevant.
    </para><para>
The skeptic may say, "But you have to type the same number of
characters!  You've replaced 'pl' with 'p.', except it could be worse
for a longer object name."  True.  BUT, in this new scheme, most plots
will not be generated by invoking methods on a specific stream object,
but rather by deriving from <samp>plstream</samp>, and invoking methods of
"this" object.  See the section on derivation below.
    </para><node name="Abstraction of Data Layout" previous="Namespace Management" next="Collapsing the API" up="Design of the PLplot C++ Interface"/><subsection>Abstraction of Data Layout</subsection><para>
The <samp>plstream</samp> class will provide an abstract interface to the
2-d drawing functions.  Instead of forcing the C++ user to organize
data in one of a small set of generally braindead data layouts with
poor memory management properties, potentially forcing the C++ user to
not use a superior method, or to copy data computed in one layout
format to another for plotting (with consequent bug production), the
<samp>plstream</samp> 2-d plotting functions will accept an abstract layout
specification.  The only thing which is important to the 2-d drawing
functions is that the data be "indexable".  They should not care about
data layout.
    </para><para>
Consequently, an abstract class, "Contourable_Data" is provided.  This
class provides a pure virtual method which accepts indexes, and is to
be made to produce a function value for the user's 2-d data field.  It
is of no concern to PLplot how the user does this.  Any mapping
between index and data which the user wishes to use, may be used.
    </para><para>
This methodology allows the C++ user to compute data using whatever
storage mechanism he wants.  Then, by deriving a class from PLplot's
Contourable_Data abstract class, he can provide a mapping to his own
data layout.
    </para><para>
Note that this does /not/ mean that the C++ user's internal data
layout must be derived from PLplot's Contourable_Data class.  Suppose
for example that the user data is stored in a C++ "matrix" class.
To make this data contourable, the user may define a class which
specializes the indexing concept of the PLplot Contourable_Data class
to his matrix class.  For example:
</para><example>
class Matrix { ... };
class Contourable_Matrix : public Contourable_Data {
    Matrix&amp; m;
  public:
    Contourable_Matrix( Matrix&amp; _m ) : m(_m) {}
    PLFLT  operator()( int i, int j ) const { return m(i,j); }
};

plstream p( ... );
Matrix m;
// Code to fill m with data
Contourable_Matrix cm(m);
p.shade( cm, ... );
</example><para>
In this way the C++ user is completely freed from the tyranny of
moronic data layout constraints imposed by PLplot's C or Fortran API.
    </para><node name="Collapsing the API" previous="Abstraction of Data Layout" up="Design of the PLplot C++ Interface"/><subsection>Collapsing the API</subsection><para>
Use of abstraction as in C) above will allow a single method in
<samp>plstream</samp> to perform the services of multiple functions in the C API.
In those cases where multiple functions were provided with different
data layout specifications, but similar functionality, these can all
be collapsed into one, through the use of the abstract interface
technique described above.

Moreover, function name overloading can be used to simplify the
namespace for those cases where multiple functions were used to get
variations on a basic capability.  For example, a single name such as
contour or shade can be used for multiple methods taking different
argument sets, so that for example, one can make simple plots of
rectangular data sets, or more complex generalized coordinate
mappings.
    </para><node name="Specializing the PLplot C++ Interface" previous="Design of the PLplot C++ Interface" next="Status of the C++ Interface" up="A C++ Interface for PLplot"/><section>Specializing the PLplot C++ Interface</section><para>
The <samp>plstream</samp> class is an ideal candidate for derivation.  By
inheriting from <samp>plstream</samp>, the user can construct a new class
which is automatically endowed with the ability to plot to a specific
PLplot output stream in a coherent manner without having to worry
about interplay with other <samp>plstream</samp> (or derived type) objects.
Moreover, new, higher level, plotting functionality can be constructed
to provide even more simplicity and ease of use than the PLplot API.
    </para><para>
The PLplot maintainers (Geoff and Maurice) expect to introduce a class
plxstream in the future which provides superior support for
constructing graphics with multiple plots per page, easier
specification of plot adornments, etc.  This should significantly ease
one aspect of PLplot usage which we regard as being clumsy at this
time.
    </para><para>
Beyond that, users may find it useful to derive from
<samp>plstream</samp>
(or later plxstream whenever it finally makes its appearance) for the
purpose of making "application specific" output streams.  For example,
a C++ program will normally have a variety of objects which constitute
the fundamental entities in the code.  These could all be made to be
"atomically plotted" by providing suitable methods.  For example:
    </para><example>
class Cat { ... };
class Dog { ... };
class Bear { ... };
class Fish { ... };

class zoostream : public plstream {
  public:
    void plot( const Cat&amp; c ) { ... }
    void plot( const Dog&amp; d ) { ... }
    void plot( const Bear&amp; b ) { ... }
    void plot( const Fish&amp; f ) { ... }
};
</example><para>
Presumably the PLplot user community can think of even more
imaginative uses...  :-).
    </para><node name="Status of the C++ Interface" previous="Specializing the PLplot C++ Interface" up="A C++ Interface for PLplot"/><section>Status of the C++ Interface</section><para>
The class <samp>plstream</samp> (and the other abstraction classes in
<file>plstream.h</file>) provided in PLplot 4.99j (alpha) are to be
considered as works in progress.  By the standards outlined above, the
work has barely begun.  At this time, <samp>plstream</samp> is mostly a one
to one mirror of the C API, which is to say, it is still far from the
goals of simplification and abstraction outlined above.  As such, it
can be expected to change radically over the course of time.  (We
don't quote schedules--how long have you been waiting for 5.0?  :-).
    </para><para>
In any event, we would welcome improvement submissions along the lines
of those above, but we would strongly discourage people from using
<samp>plstream</samp> if they are expecting it to be rock solid.  It
<i>will</i>
be changing, to become more like the design goals elucidated above.
    </para><para>
So, if you like the ideas described above, and are willing to accept
the burden of "upgrading" your code as the class <samp>plstream</samp>
evolves, then feel free to use it.  Just don't whine when I fix some
of the methods to take references instead of pointers, when I
eliminate some of the redundant methods to use the collapsed form,
etc.
    </para><node name="Using PLplot from Tcl" previous="A C++ Interface for PLplot" next="Building an Extended WISH" up="Top"/><chapter>Using PLplot from Tcl</chapter><para>
PLplot has historically had C and Fortran language bindings.  PLplot
version 5.0 introduces a plethora of new programming options including
C++ (described earlier) and several script language bindings.  The Tcl
interface to PLplot (which the PLplot maintainers regard as the
primary script language binding) is described in this chapter,
with further discussion of Tcl related issues following in additional
chapters.  But Tcl is certainly not the only script language option.
Bindings to Perl, Python, and Scheme (which is actually another
compiled language, but still has some of the flavor of a VHLL) are in
various stages of completion, and are described in separate chapters.
Use the one that suits you best--or try them all!
</para><menu><menuentry node="Motivation for the Tcl Interface to PLplot"><menuentrytitle>Motivation for the Tcl Interface to PLplot</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Overview of the Tcl Language Binding"><menuentrytitle>Overview of the Tcl Language Binding</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="The PLplot Tcl Matrix Extension"><menuentrytitle>The PLplot Tcl Matrix Extension</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Contouring and Shading from Tcl"><menuentrytitle>Contouring and Shading from Tcl</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Understanding the Performance Characteristics of Tcl"><menuentrytitle>Understanding the Performance Characteristics of Tcl</menuentrytitle><menuentrydescrip/></menuentry></menu><node name="Motivation for the Tcl Interface to PLplot" next="Overview of the Tcl Language Binding" up="Using PLplot from Tcl"/><section>Motivation for the Tcl Interface to PLplot</section><para>
The recent emergence of several high quality VHLL script languages
such as Tcl, Perl, Python and arguably even some Lisp variants, is
having a profound effect upon the art of computer programming.  Tasks
which have traditionally been handled by C or Fortran, are beginning
to be seen in a new light.  With relatively fast processors now widely
available, many programming jobs are no longer bound by execution
time, but by human time.  Rapidity of initial development and
continued maintenance, for a surprisingly wide class of applications,
is far more important than execution time.  Result: in a very short
period of time, say from 1993 to 1995, script languages have exploded
onto the scene, becoming essential tools for any serious programmer.
</para><para>
Moreover, the entire concept of speed of execution needs revising
in the face of the gains made in computer hardware in recent years.
Saying that script language processing is slower than compiled
language processing may be undeniable and simultaneously irrelevant.
If the script language processing is fast enough, then it is fast
enough.  Increasingly, computational researchers are finding that
script based tools are indeed fast enough.  And if their run time is
fast enough, and their development and maintenance time is much much
better, then why indeed should they not be used?
</para><para>
Even in a field with several high visibility players, Tcl has
distinguished itself as a leading contender.  There are many reasons
for this, but perhaps the most important, at least as it relates to
the PLplot user community, is that Tcl was designed to be extensible
and embeddable.  The whole purpose of Tcl, as it name (Tool Command
Language) indicates, is to be a command language for other tools.  In
other words, the fact that Tcl is capable of being a standalone shell
is interesting, even useful, but nonetheless incidental.  The real
attraction of Tcl is that it can be the shell language for
<i>your</i>
code.  Tcl can easily be embedded into your code, endowing it
immediately with a full featured, consistent and well documented
script programming language, providing all the core features you need
in a programming language: variables, procedures, control structures,
error trapping and recovery, tracing, etc.  But that is only the
beginning!  After that, you can easily extend Tcl by adding commands
to the core language, which invoke the capabilities of your tool.  It
is in this sense that Tcl is a tool command language.  It is a command
language which you can augment to provide access to the facilities of
your tool.
</para><para>
But Tcl is more than just an embeddable, extensible script language
for personal use.  Tcl is an industry, an internet phenomenon.  There
are currently at least two high quality books, with more on the way.
There is an industry of service providers and educators.  Furthermore,
literally hundreds of Tcl extensions exist, and are readily available
over the net.  Perhaps the most notable extension, Tk, provides a
fantastic interface to X Windows widget programming, permitting the
construction of Motif like user interfaces, with none of the hassles
of actually using Motif.  Some of these extensions endow Tcl with
object oriented facilities philosophically similar to C++ or other
object oriented languages.  Other extensions provide script level
access to system services.  Others provide a script interface to
sockets, RPC, and other network programming protocols.  The list goes
on and on.  Dive into the Tcl archive, and see what it has for you!
</para><para>
So, the answer to the question Why do we want a Tcl interface to
PLplot? is very simple.  Because we we are using Tcl anyway, as
the command language for our project, and would like to be able to do
plotting in the command language just as we do so many other things.
</para><para>
But there is more than just the aesthetics of integration to consider.
There are also significant pragmatic considerations.  If you generate
your PLplot output via function calls from a compiled language, then
in order to add new diagnostics to your code, or to refine or
embellish existing ones, you have to edit the source, recompile,
relink, and rerun the code.  If many iterations are required to get
the plot right, significant time can be wasted.  This can be
especially true in the case of C++ code making heavy use of templates,
for which many C++ compilers will have program link times measured in
minutes rather than seconds, even for trivial program changes.
</para><para>
In contrast, if the diagnostic plot is generated from Tcl, the
development cycle looks more like: start the shell (command line or
windowing), source a Tcl script, issue the command to generate the
plot, notice a bug, edit the Tcl script, resource the script, and
regenerate the plot.   Notice that compiling, linking, and restarting
the program, have all been dropped from the development cycle.  The
time savings from such a development cycle can be amazing!
</para><node name="Overview of the Tcl Language Binding" previous="Motivation for the Tcl Interface to PLplot" next="The PLplot Tcl Matrix Extension" up="Using PLplot from Tcl"/><section>Overview of the Tcl Language Binding</section><para>
Each of the PLplot calls available to the C or Fortran programmer are
also available from Tcl, with the same name and generally the same
arguments.  Thus for instance, whereas in C you can write:

</para><example>
plenv( 0., 1., 0., 1., 0, 0 );
pllab( "(x)", "(y)", "The title of the graph" );
</example><para>
you can now write in Tcl:
</para><example>
plenv 0 1 0 1 0 0
pllab "(x)" "(y)" "The title of the graph"
</example><para>
All the normal Tcl rules apply, there is nothing special about the
PLplot extension commands.  So, you could write the above as:
</para><example>
set xmin 0; set xmax 1; set ymin 0; set ymax 1
set just 0; set axis 0
set xlab (x)
set ylab (y)
set title "The title of the graph"
plenv $xmin $xmax $ymin $ymax $just $axis
pllab $xlab $ylab $title
</example><para>
for example.  Not that there is any reason to be loquacious for its
own sake, of course.  The point is that you might have things like the
plot bounds or axis labels stored in Tcl variables for some other
reason (tied to a Tk entry widget maybe, or provided as the result of
one of your application specific Tcl extension commands, etc), and
just want to use standard Tcl substitution to make the PLplot calls.
</para><para>
Go ahead and try it!  Enter <samp>pltcl</samp> to start up the PLplot
extended Tcl shell, and type (or paste) in the commands.  Or put them
in a file and source it.  By this point it should be clear how
incredibly easy it is to use the PLplot Tcl language binding.
</para><para>
In order to accommodate the ubiquitous requirement for matrix oriented
data in scientific applications, and in the PLplot API in particular,
PLplot 5.0 includes a Tcl extension for manipulating matrices in Tcl.
This Tcl Matrix Extension provides a straightforward and direct means
of representing one and two dimensional matrices in Tcl.  The Tcl
Matrix Extension is described in detail in the next section, but we
mention its existence now just so that we can show how the PLplot Tcl
API works.  Many of the PLplot Tcl API functions accept Tcl matrices
as arguments.  For instance, in C you might write:
</para><example>
float x[100], y[100];

/* code to initialize x and y */

plline( 100, x, y );
</example><para>
In Tcl you can write:
</para><example>
matrix x f 100
matrix y f 100

# code to initialize x and y

plline 100 x y
</example><para>
Some of the PLplot C function calls use pointer arguments to allow
retrieval of PLplot settings.  These are implemented in Tcl by
changing the value of the variable whose name you provide.  For
example:
</para><example>
pltcl&gt; plgxax
wrong # args: should be "plgxax digmax digits  "
pltcl&gt; set digmax 0
0
pltcl&gt; set digits 0
0
pltcl&gt; plgxax digmax digits
pltcl&gt; puts "digmax=$digmax digits=$digits"
digmax=4 digits=0
</example><para>
This example shows that each PLplot Tcl command is designed to issue
an error if you invoke it incorrectly, which in this case was used to
remind us of the correct arguments.  We then create two Tcl variables
to hold the results.  Then we invoke the PLplot <samp>plgxax</samp> function
to obtain the label formatting information for the x axis.  And
finally we print the results.
</para><para>
People familiar with Tcl culture may wonder why the <samp>plg*</samp> series
functions don't just pack their results into the standard Tcl result
string.  The reason is that the user would then have to extract the
desired field with either <samp>lindex</samp> or
<samp>regexp</samp>, which seems
messy.  So instead, we designed the PLplot Tcl API to look and feel as
much like the C API as could reasonably be managed.
</para><para>
In general then, you can assume that each C function is provided in
Tcl with the same name and same arguments (and one or two dimensional
arrays in C are replaced by Tcl matrices).  There are only a few
exceptions to this rule, generally resulting from the complexity of
the argument types which are passed to some functions in the C API.
Those exceptional functions are described below, all others work in
the obvious way (analogous to the examples above).  
</para><para>
See the Tcl example programs for extensive demonstrations of the usage
of the PLplot Tcl API.  To run the Tcl demos:
</para><example>
% pltcl
pltcl&gt; source tcldemos.tcl
pltcl&gt; 1
pltcl&gt; 2
</example><para>
Alternatively, you can run <samp>plserver</samp> and source
<file>tkdemos.tcl</file>.
</para><para>
In any event, the Tcl demos provide very good coverage of the Tcl API,
and consequently serve as excellent examples of usage.  For the most
part they draw the same plots as their C counterpart.  Moreover, many
of them were constructed by literally inserting the C code into the
Tcl source file, and performing fairly mechanical transformations on
the source.  This should provide encouragement to anyone used to using
PLplot through one of the compiled interfaces, that they can easily
and rapidly become productive with PLplot in Tcl.
</para><node name="The PLplot Tcl Matrix Extension" previous="Overview of the Tcl Language Binding" next="Contouring and Shading from Tcl" up="Using PLplot from Tcl"/><section>The PLplot Tcl Matrix Extension</section><para>
Tcl does many things well, but handling collections of numbers is not
one of them.   You could make lists, but for data sets of sizes
relevant to scientific graphics which is the primary domain of
applicability for PLplot, the extraction time is excessive and
burdensome.  You could use Tcl arrays, but the storage overhead is
astronomical and the lookup time, while better than list manipulation,
is still prohibitive.  
</para><para>
To cope with this, a Tcl Matrix extension was created for the
purpose of making it feasible to work with large collections of
numbers in Tcl, in a way which is storage efficient, reasonably 
efficient for accesses from Tcl, and reasonably compatible with
practices used in compiled code.
</para><menu><menuentry node="Using Tcl Matrices from Tcl"><menuentrytitle>Using Tcl Matrices from Tcl</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Using Tcl Matrices from C"><menuentrytitle>Using Tcl Matrices from C</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Using Tcl Matrices from C++"><menuentrytitle>Using Tcl Matrices from C++</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Extending the Tcl Matrix facility"><menuentrytitle>Extending the Tcl Matrix facility</menuentrytitle><menuentrydescrip/></menuentry></menu><node name="Using Tcl Matrices from Tcl" next="Using Tcl Matrices from C" up="The PLplot Tcl Matrix Extension"/><subsection>Using Tcl Matrices from Tcl</subsection><para>
Much like the Tk widget creation commands, the Tcl <samp>matrix</samp>
command considers its first argument to be the name of a new command
to be created, and the rest of the arguments to be modifiers.  After
the name, the next argument can be <samp>float</samp> or
<samp>int</samp> or
contractions thereof.  Next follow a variable number of size arguments
which determine the size of the matrix in each of its dimensions.  For
example: 
</para><example>
matrix x f 100
matrix y i 64 64
</example><para>
constructs two matrices.  <samp>x</samp> is a float matrix, with one
dimension and 100 elements.  <samp>y</samp> is an integer matrix, and has 2
dimensions each of size 64.
</para><para>
Additionally, an initializer may be specified, with a syntax familiar
from C.  For example:
</para><example>
matrix x f 4 = { 1.5, 2.5, 3.5, 4.5 }
</example><para>
A Tcl matrix is a command, and as longtime Tcl users know, Tcl
commands are globally accessible.  The PLplot Tcl Matrix extension
attempts to lessen the impact of this by registering a variable in the
local scope, and tracing it for insets, and deleting the actual
matrix command when the variable goes out of scope.  In this way, a
Tcl matrix appears to work sort of like a variable.  It is, however,
just an illusion, so you have to keep this in mind.  In particular,
you may want the matrix to outlive the scope in which it was created.
For example, you may want to create a matrix, load it with data, and
then pass it off to a Tk megawidget for display in a spreadsheet like
form.  The proc which launches the Tk megawidget will complete, but
the megawidget, and the associated Tcl matrix are supposed to hang
around until they are explicitly destroyed.  To achieve this effect,
create the Tcl matrix with the <samp>-persist</samp> flag.  If present
(can be anywhere on the line), the matrix is not automatically deleted
when the scope of the current proc (method) ends.  Instead, you must
explicitly clean up by using either the 'delete' matrix command or renaming
the matrix command name to {}.  Now works correctly from within [incr Tcl].
</para><para>
As mentioned above, the result of creating a matrix is that a new
command of the given name is added to the interpreter.  You can then
evaluate the command, providing indices as arguments, to extract the
data.  For example:
</para><example>
pltcl&gt; matrix x f = {1.5, 2.5, 3.5, 4.5}
insufficient dimensions given for Matrix operator "x"
pltcl&gt; matrix x f 4 = {1.5, 2.5, 3.5, 4.5}
pltcl&gt; x 0
1.500000
pltcl&gt; x 1
2.500000
pltcl&gt; x 3
4.500000
pltcl&gt; x *
1.500000 2.500000 3.500000 4.500000
pltcl&gt; puts "x\[1\]=[x 1]"
x[1]=2.500000
pltcl&gt; puts "x\[*\] = :[x *]:"
x[*] = :1.500000 2.500000 3.500000 4.500000:
pltcl&gt; foreach v [x *] { puts $v }
1.500000
2.500000
3.500000
4.500000
pltcl&gt; for {set i 0} {$i &lt; 4} {incr i} {
           if {[x $i] &lt; 3} {puts [x $i]} }
1.500000
2.500000
</example><para>
Note from the above that the output of evaluating a matrix indexing
operation is suitable for use in condition processing, list
processing, etc.
</para><para>
You can assign to matrix locations in a similar way:
</para><example>
pltcl&gt; x 2 = 7
pltcl&gt; puts ":[x *]:"
:1.500000 2.500000 7.000000 4.500000:
pltcl&gt; x * = 3
pltcl&gt; puts ":[x *]:"
</example><para>
Note that the * provides a means of obtaining an index range, and that
it must be separated from the = by a space.  Future versions of the
Tcl Matrix extension may allow alternative ways of specifying index
ranges and may assign the obvious meaning to an expression of the
form:
</para><example>
x *= 3
</example><para>
However this has not been implemented yet...
</para><para>
In any event, the <samp>matrix</samp> command also supports an
<samp>info</samp>
subcommand which reports the number of elements in each dimension:
</para><example>
pltcl&gt; x info
4 
pltcl&gt; matrix y i 8 10
pltcl&gt; y info
8 10 
</example><node name="Using Tcl Matrices from C" previous="Using Tcl Matrices from Tcl" next="Using Tcl Matrices from C++" up="The PLplot Tcl Matrix Extension"/><subsection>Using Tcl Matrices from C</subsection><para>
Normally you will create a matrix in Tcl, and then want to pass it to
C in order to have the data filled in, or existing data to be used in
a computation, etc.  To do this, pass the name of the matrix command
as an argument to your C Tcl command procedure.  The C code should
include <file>tclMatrix.h</file>, which has a definition for the
<samp>tclMatrix</samp> structure.  You fetch a pointer to the
<samp>tclMatrix</samp> structure using the
<samp>Tcl_GetMatrixPtr</samp> function.
</para><para>
For example, in Tcl:
</para><example>
matrix x f 100
wacky x
</example><para>
and in C:
</para><example>
int wackyCmd( ClientData clientData, Tcl_Interp *interp,
              int argc, char *argv[] )
{
    tclMatrix *w;

    w = Tcl_GetMatrixPtr( interp, argv[1] );
    ...
</example><para>
To learn about what else you can do with the matrix once inside
compiled code, read <file>tclMatrix.h</file> to learn the definition of the
<samp>tclMatrix</samp> structure, and see the examples in files like
<file>tclAPI.c</file> which show many various uses of the Tcl matrix.
</para><node name="Using Tcl Matrices from C++" previous="Using Tcl Matrices from C" next="Extending the Tcl Matrix facility" up="The PLplot Tcl Matrix Extension"/><subsection>Using Tcl Matrices from C++</subsection><para>
Using a Tcl matrix from C++ is very much like using it from C, except
that <file>tclMatrix.h</file> contains some C++ wrapper classes which are
somewhat more convenient than using the indexing macros which one has
to use in C.  For example, here is a tiny snippet from one of the
authors codes in which Tcl matrices are passed in from Tcl to a C++
routine which is supposed to fill them in with values from some
matrices used in the compiled side of the code:
</para><example>
...
if (item == "vertex_coords") {
    tclMatrix *matxg = Tcl_GetMatrixPtr( interp, argv[1] );
    tclMatrix *matyg = Tcl_GetMatrixPtr( interp, argv[2] );

    Mat2&lt;float&gt; xg(ncu, ncv), yg(ncu, ncv);
    cg-&gt;Get_Vertex_Coords( xg, yg );

    TclMatFloat txg( matxg ), tyg( matyg );

    for( i=0; i &lt; ncu; i++ )
        for( j=0; j &lt; ncv; j++ ) {
            txg(i,j) = xg(i,j);
            tyg(i,j) = yg(i,j);
        }
</example><para>
There are other things you can do too, see the definitions of the
<samp>TclMatFloat</samp> and <samp>TclMatInt</samp> classes in
<file>tclMatrix.h</file>. 
</para><node name="Extending the Tcl Matrix facility" previous="Using Tcl Matrices from C++" up="The PLplot Tcl Matrix Extension"/><subsection>Extending the Tcl Matrix facility</subsection><para>
The Tcl matrix facility provides creation, indexing, and information
gathering facilities.  However, considering the scientifically
inclined PLplot user base, it is clear that some users will demand
more.  Consequently there is a mechanism for augmenting the Tcl matrix
facility with your own, user defined, extension subcommands.  Consider
<file>xtk04.c</file>.  In this extended wish, we want to be able to
determine the minimum and maximum values stored in a matrix.  Doing
this in Tcl would involve nested loops, which in Tcl would be
prohibitively slow.  We could register a Tcl extension command to do
it, but since the only sensible data for such a command would be a
Tcl matrix, it seems nice to provide this facility as an actual
subcommand of the matrix.  However, the PLplot maintainers cannot
foresee every need, so a mechanism is provided to register subcommands
for use with matrix objects.
</para><para>
The way to register matrix extension subcommands is to call
<samp>Tcl_MatrixInstallXtnsn</samp>: 
</para><example>
typedef int (*tclMatrixXtnsnProc) ( tclMatrix *pm, Tcl_Interp *interp,
                                    int argc, char *argv[] );

int Tcl_MatrixInstallXtnsn( char *cmd, tclMatrixXtnsnProc proc );
</example><para>
In other words, make a function for handling the matrix extension
subcommand, with the same function signature (prototype) as
<samp>tclMatrixXtnsnProc</samp>, and register the subcommand name along with
the function pointer.  For example, xtk04.c has:
</para><example>
int mat_max( tclMatrix *pm, Tcl_Interp *interp,
             int argc, char *argv[] )
{
    float max = pm-&gt;fdata[0];
    int i;
    for( i=1; i &lt; pm-&gt;len; i++ )
        if (pm-&gt;fdata[i] &gt; max)
            max = pm-&gt;fdata[i];

    sprintf( interp-&gt;result, "%f", max );
    return TCL_OK;
}

int mat_min( tclMatrix *pm, Tcl_Interp *interp,
             int argc, char *argv[] )
{
    float min = pm-&gt;fdata[0];
    int i;
    for( i=1; i &lt; pm-&gt;len; i++ )
        if (pm-&gt;fdata[i] &lt; min)
            min = pm-&gt;fdata[i];

    sprintf( interp-&gt;result, "%f", min );
    return TCL_OK;
}
</example><para>
Then, inside the application initialization function
(<samp>Tcl_AppInit()</samp> to long time Tcl users):
</para><example>
Tcl_MatrixInstallXtnsn( "max", mat_max );
Tcl_MatrixInstallXtnsn( "min", mat_min );
</example><para>
Then we can do things like:
</para><example>
dino 65: xtk04
% matrix x f 4 = {1, 2, 3, 1.5}
% x min
1.000000
% x max
3.000000
</example><para>
Your imagination is your only limit for what you can do with this.
You could add an FFT subcommand, matrix math, BLAS, whatever.  
</para><node name="Contouring and Shading from Tcl" previous="The PLplot Tcl Matrix Extension" next="Understanding the Performance Characteristics of Tcl" up="Using PLplot from Tcl"/><section>Contouring and Shading from Tcl</section><para>
Contouring and shading has traditionally been one of the
messier things to do in PLplot.  The C API has many parameters, with
complex setup and tear down properties.  Of special concern is that
some of the parameters do not have a natural representation in script
languages like Tcl.  In this section we describe how the Tcl
interface to these facilities is provided, and how to use it.
</para><menu><menuentry node="Drawing a Contour Plot from Tcl"><menuentrytitle>Drawing a Contour Plot from Tcl</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Drawing a Shaded Plot from Tcl"><menuentrytitle>Drawing a Shaded Plot from Tcl</menuentrytitle><menuentrydescrip/></menuentry></menu><node name="Drawing a Contour Plot from Tcl" next="Drawing a Shaded Plot from Tcl" up="Contouring and Shading from Tcl"/><subsection>Drawing a Contour Plot from Tcl</subsection><para>
By way of reference, the primary C function call for contouring is:
</para><example>
void plcont( PLFLT **f, PLINT nx, PLINT ny, PLINT kx, PLINT lx,
             PLINT ky, PLINT ly, PLFLT *clevel, PLINT nlevel,
             void (*pltr) (PLFLT, PLFLT, PLFLT *, PLFLT *, PLPointer),
             PLPointer pltr_data);
</example><para>
</para><para>
This is a fairly complex argument list, and so for this function (and
for plshade, described below) we dispense with trying to exactly
mirror the C API, and just concentrate on capturing the functionality
within a Tcl context.  To begin with, the data is provided through a
2-d Tcl matrix.  The Tcl matrix carries along its size information
with it, so <samp>nx</samp> and <samp>ny</samp> are no longer needed.  The
<samp>kx</samp>, <samp>lx</samp>, <samp>ky</samp> and
<samp>ly</samp> variables are
potentially still  useful for plotting a subdomain of the full data
set, so they may be specified in the natural way, but we make this
optional since they are frequently not used to convey anything more
than what could be inferred from <samp>nx</samp> and
<samp>ny</samp>.  However, to
simplify processing, they must be supplied or omitted as a set (all of
them, or none of them).  <samp>clevel</samp> is supplied as a 1-d Tcl
matrix, and so <samp>nlevel</samp> can be omitted.  
</para><para>
Finally, we have no way to support function pointers from Tcl, so
instead we provide token based support for accessing the three
coordinate transformation routines which are provided by PLplot, and
which many PLplot users use.  There are thus three courses of action:
<itemize markchar="•"><listitem><para>
  Provide no pltr specification.  In this case, <samp>pltr0</samp> is
  used by default.
  </para></listitem><listitem><para>
  Specify <samp>pltr1 x y</samp> where x and y are 1-d Tcl matrices.
  In this case <samp>pltr1</samp> will be used, and the 1-d arrays which it
  needs will be supplied from the Tcl matrices <samp>x</samp> and
  <samp>y</samp>.
  </para></listitem><listitem><para>
  Specify <samp>pltr2 x y</samp> where x and y are 2-d Tcl matrices.
  In this case <samp>pltr2</samp> will be used, and the 2-d arrays which it
  needs will be supplied from the Tcl matrices <samp>x</samp> and
  <samp>y</samp>.
  </para></listitem></itemize>

</para><para>
Now, there can be no question that this is both more concise and less
powerful than what you could get in C.  The loss of the ability to
provide a user specified transformation function is regrettable.  If
you really do need that functionality, you will have to implement your
own Tcl extension command to do pretty much the same thing as the
provided Tcl extension command <samp>plcont</samp> (which is in
<file>tclAPI.c</file> in function <samp>plcontCmd()</samp>), except specify the C
transformation function of your choice.
</para><para>
However, that having been said, we recognize that one common use for
this capability is to provide a special version of <samp>pltr2</samp> which
knows how to implement a periodic boundary condition, so that polar
plots, for example, can be implemented cleanly.  That is, if you want
to draw contours of a polar data set defined on a 64 x 64 grid,
ensuring that contour lines would actually go all the way around the
origin rather than breaking off like a silly pacman figure, then you
had basically two choices in C.  You could copy the data to a 65 x 64
grid, and replicate one row of data into the spare slot, and then plot
the larger data set (taking care to replicate the coordinate arrays
you passed to pltr2 in the same way), <i>or</i> you could make a
special version of <samp>pltr2</samp> which would understand that one of the
coordinates was wrapped, and perform transformations accordingly
without actually making you replicate the data.
</para><para>
Since the former option is ugly in general, and hard to do in Tcl in
particular, and since the second option is even more difficult to do
in Tcl (requiring you do make a special Tcl extension command as
described above), we provide special, explicit support for this common
activity.  This is provided through the use of a new, optional
parameter <samp>wrap</samp> which may be specified as the last parameter to
the Tcl command, only if you are using <samp>pltr2</samp>.  Supplying
<samp>1</samp> will wrap in the first coordinate, <samp>2</samp> will wrap in the
second coordinate.
</para><para>
The resultant Tcl command is:
</para><example>
plcont f [kx lx ky ly] clev [pltr x y] [wrap]
</example><para>
Note that the brackets here are used to signify optional arguments,
<i>not</i> to represent Tcl command substitution!
</para><para>
The Tcl demo <file>x09.tcl</file> provides examples of all the capabilities
of this interface to contouring from Tcl.  Note in particular,
<samp>x09_polar</samp> which does a polar contour without doing anything
complicated in the way of setup, and without getting a pacman as the
output. 
</para><node name="Drawing a Shaded Plot from Tcl" previous="Drawing a Contour Plot from Tcl" up="Contouring and Shading from Tcl"/><subsection>Drawing a Shaded Plot from Tcl</subsection><para>
The Tcl interface to shading works very much like the one for
contouring.  The command is:
</para><example>
plshade z xmin xmax ymin ymax \
    sh_min sh_max sh_cmap sh_color sh_width \
    min_col min_wid max_col max_wid \
    rect [pltr x y] [wrap]
</example><para>
where <samp>nx</samp> and <samp>ny</samp> were dropped since they are inferred
from the Tcl matrix <samp>z</samp>, <samp>defined</samp> was dropped since it
isn't supported anyway, and <samp>plfill</samp> was dropped since it was the
only valid choice anyway.  The <samp>pltr</samp> spec and
<samp>wrap</samp> work
exactly as described for the Tcl <samp>plcont</samp> described above.
</para><para>
The Tcl demo <file>x16.tcl</file> contains extensive demonstrations of use,
including a shaded polar plot which connects in the desirable way
without requiring special data preparation, again just like for
<samp>plcont</samp> described previously.
</para><node name="Understanding the Performance Characteristics of Tcl" previous="Contouring and Shading from Tcl" up="Using PLplot from Tcl"/><section>Understanding the Performance Characteristics of Tcl</section><para>
Newcomers to Tcl, and detractors (read, proponents of other
paradigms) often do not have a clear (newcomers) or truthful
(detractors) perspective on Tcl performance.  In this section we try
to convey a little orientation which may be helpful in working with
the PLplot Tcl interface.
</para><para>
Tcl is slow!  Yeah, so what?
</para><para>
Debates of this form frequently completely miss the point.  Yes, Tcl
is definitely slow.  It is fundamentally a string processing language,
is interpreted, and must perform substitutions and so forth on a
continual basis.  All of that takes time.  Think milliseconds instead
of microseconds for comparing Tcl code to equivalent C code.  On the
other hand, this does not have to be problematic, even for time
critical (interactive) applications, if the division of labor is done
correctly.  Even in an interactive program, you can use Tcl fairly
extensively for high level control type operations, as long as you do
the real work in a compiled Tcl command procedure.  If the high level
control code is slow, so what?  So it takes 100 milliseconds over the
life the process, as compared to the 100 microseconds it could have
taken if it were in C.  Big deal.  On an absolute time scale, measured
in units meaningful to humans, it's just not a lot of time.
</para><para>
The problem comes when you try to do too much in Tcl.  For instance,
an interactive process should not be trying to evaluate a
mathematical expression inside a doubly nested loop structure, if
performance is going to be a concern.
</para><para>
Case in point:  Compare x16.tcl to x16c.c.  The code looks very
similar, and the output looks very similar.  What is not so similar is
the execution time.  The Tcl code, which sets up the data entirely in
Tcl, takes a while to do so.  On the other hand, the actual plotting
of the data proceeds at a rate which is effectively indistinguishable
from that of the compiled example.  On human time scales, the
difference is not meaningful.  Conclusion:  If the computation of the
data arrays could be moved to compiled code, the two programs would
have performance close enough to identical that it really wouldn't be
an issue.  We left the Tcl demos coded in Tcl for two reasons.  First
because they provide some examples and tests of the use of the Tcl
Matrix extension, and secondly because they allow the Tcl demos to be
coded entirely in Tcl, without requiring special customized extended
shells for each one of them.  They are not, however, a good example of
you should do things in practice.
</para><para>
Now look at <file>tk04</file> and <file>xtk04.c</file>, you will see
that if the data is computed in compiled code, and shuffled into the
Tcl matrix and then plotted from Tcl, the performance is fine.  Almost
all the time is spent in plshade, in compiled code.  The time taken to
do the small amount of Tcl processing involved with plotting is
dwarfed by the time spent doing the actual drawing in C.  So using Tcl
cost almost nothing in this case.
</para><para>
So, the point is, do your heavy numerics in a compiled language, and
feel free to use Tcl for the plotting, if you want to.  You can of
course mix it up so that some plotting is done from Tcl and some from
a compiled language.  
</para><node name="Building an Extended WISH" previous="Using PLplot from Tcl" next="Embedding Plots in Graphical User Interfaces" up="Top"/><chapter>Building an Extended WISH</chapter><para>
    Beginning with PLplot 5.0, a new and powerful paradigm for interaction
    with PLplot is introduced.  This new paradigm consists of an
    integration of PLplot with a powerful scripting language (Tcl), and
    extensions to that language to support X Windows interface development
    (Tk) and object oriented programming ([incr Tcl]).  Taken together,
    these four software systems (Tcl/Tk/itcl/PLplot) comprise a powerful
    environment for the rapid prototyping and development of sophisticated,
    flexible, X Windows applications with access to the PLplot API.  Yet
    that is only the beginning---Tcl was born to be extended.  The true
    power of this paradigm is achieved when you add your own, powerful,
    application specific extensions to the above quartet, thus creating an
    environment for the development of wholly new applications with only a
    few keystrokes of shell programming ...
  </para><menu><menuentry node="Introduction to Tcl"><menuentrytitle>Introduction to Tcl</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Introduction to Tk"><menuentrytitle>Introduction to Tk</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Introduction to [incr Tcl]"><menuentrytitle>Introduction to [incr Tcl]</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="PLplot Extensions to Tcl"><menuentrytitle>PLplot Extensions to Tcl</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Custom Extensions to Tcl"><menuentrytitle>Custom Extensions to Tcl</menuentrytitle><menuentrydescrip/></menuentry></menu><node name="Introduction to Tcl" next="Introduction to Tk" up="Building an Extended WISH"/><section>Introduction to Tcl</section><para>
      The Tool Command Language, or just Tcl (pronounced
      tickle) is an embeddable script language which can be
      used to control a wide variety of applications.  Designed by John
      Ousterhout of UC Berkeley, Tcl is freely available under the standard
      Berkeley copyright.  Tcl and Tk (described below) are extensively
      documented in a new book published by Addison Wesley, entitled
      Tcl and the Tk toolkit by John Ousterhout.  This book
      is a must have for those interested in developing powerful extensible
      applications with high quality X Windows user interfaces.  The
      discussion in this chapter cannot hope to approach the level of
      introduction provided by that book.  Rather we will concentrate on
      trying to convey some of the excitement, and show the nuts and bolts
      of using Tcl and some extensions to provide a powerful and flexible
      interface to the PLplot library within your application.
    </para><menu><menuentry node="Motivation for Tcl"><menuentrytitle>Motivation for Tcl</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Capabilities of Tcl"><menuentrytitle>Capabilities of Tcl</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Acquiring Tcl"><menuentrytitle>Acquiring Tcl</menuentrytitle><menuentrydescrip/></menuentry></menu><node name="Motivation for Tcl" next="Capabilities of Tcl" up="Introduction to Tcl"/><subsection>Motivation for Tcl</subsection><para>
	The central observation which led Ousterhout to create Tcl was the
	realization that many applications require the use of some sort of
	a special purpose, application specific, embedded macro
	language.  Application programmers cobble these tiny
	languages into their codes in order to provide flexibility
	and some modicum of high level control.  But the end result is
	frequently a quirky and fragile language.  And each application has
	a different tiny language associated with it.  The
	idea behind Tcl, then, was to create a single core
	language which could be easily embedded into a wide variety
	of applications.  Further, it should be easily extensible so that
	individual applications can easily provide application specific
	capabilities available in the macro language itself, while still
	providing a robust, uniform syntax across a variety of
	applications.  To say that Tcl satisfies these requirements would
	be a spectacular understatement.
      </para><node name="Capabilities of Tcl" previous="Motivation for Tcl" next="Acquiring Tcl" up="Introduction to Tcl"/><subsection>Capabilities of Tcl</subsection><para>
	The mechanics of using Tcl are very straightforward.  Basically you
	just have to include the file <file>tcl.h</file>, issue
	some API calls to create a Tcl interpreter, and then evaluate a
	script file or perform other operations supported by the Tcl API.
	Then just link against <file>libtcl.a</file> and off you
	go.
      </para><para>
	Having done this, you have essentially created a shell.  That is, your
	program can now execute shell scripts in the Tcl language.  Tcl
	provides support for basic control flow, variable substitution file
	i/o and subroutines.  In addition to the builtin Tcl commands, you can
	define your own subroutines as Tcl procedures which effectively
	become new keywords.
      </para><para>
	But the real power of this approach is to add new commands to the
	interpreter which are realized by compiled C code in your
	application.  Tcl provides a straightforward API call which allows
	you to register a function in your code to be called whenever the
	interpreter comes across a specific keyword of your choosing in
	the shell scripts it executes.
      </para><para>
	This facility allows you with tremendous ease, to endow your
	application with a powerful, robust and full featured macro
	language, trivially extend that macro language with new keywords
	which trigger execution of compiled application specific commands,
	and thereby raise the level of interaction with your code to one of
	essentially shell programming via script editing.
      </para><node name="Acquiring Tcl" previous="Capabilities of Tcl" up="Introduction to Tcl"/><subsection>Acquiring Tcl</subsection><para>
	There are several important sources of info and code for Tcl.
	Definitely get the book mentioned above.  The Tcl and Tk toolkits
	are distributed by anonymous <code>ftp</code> at <uref url="ftp://sprite.berkeley.edu/tcl"><file>sprite.berkeley.edu:/tcl</file></uref>.
	There are several files in there corresponding to Tcl, Tk, and
	various forms of documentation.  At the time of this writing, the
	current versions of Tcl and Tk are 7.3 and 3.6 respectively.
	Retrieve those files, and install using the instructions provided
	therein.
      </para><para>
	The other major anonymous <code>ftp</code> site for Tcl is
	<uref url="ftp://harbor.ecn.purdue.edu/pub/tcl"><file>harbor.ecn.purdue.edu:/pub/tcl</file></uref>.
	Harbor contains a mirror of <samp>sprite</samp> as well as
	innumerable extensions, Tcl/Tk packages, tutorials, documentation,
	etc.  The level of excitement in the Tcl community is
	extraordinarily high, and this is reflected by the great plethora
	of available, high quality, packages and extensions available for
	use with Tcl and Tk.  Explore---there is definitely something
	for everyone.
      </para><para>
	Additionally there is a newsgroup, <samp>comp.lang.tcl</samp>
	which is well read, and an excellent place for people to get
	oriented, find help, etc.  Highly recommended.
      </para><para> In any event, in order to use the Tk driver in PLplot, you will
	need Tcl-8.2 and Tk-8.2 (or higher versions). Additionally, in order
	to use the extended WISH paradigm (described below) you will need
	iTcl-3.1 (or a higher version).
      </para><para>
	However, you will quite likely find Tcl/Tk to be very addictive,
	and the great plethora of add-ons available at
	<samp>harbor</samp> will undoubtedly attract no small amount
	of your attention.  It has been our experience that all of these
	extensions fit together very well.  You will find that there are
	large sectors of the Tcl user community which create so-called
	MegaWishes which combine many of the available
	extensions into a single, heavily embellished, shell interpreter.
	The benefits of this approach will become apparent as you gain
	experience with Tcl and Tk.
      </para><node name="Introduction to Tk" previous="Introduction to Tcl" next="Introduction to [incr Tcl]" up="Building an Extended WISH"/><section>Introduction to Tk</section><para>
      As mentioned above, Tcl is designed to be extensible.  The first and
      most basic Tcl extension is Tk, an X11 toolkit.  Tk provides the same
      basic facilities that you may be familiar with from other X11
      toolkits such as Athena and Motif, except that they are provided in
      the context of the Tcl language.  There are C bindings too, but these
      are seldom needed---the vast majority of useful Tk applications
      can be coded using Tcl scripts.
    </para><para>
      If it has not become obvious already, it is worth noting at this
      point that Tcl is one example of a family of languages known
      generally as Very High Level Languages, or VHLL's.
      Essentially a VHLL raises the level of programming to a very high
      level, allowing very short token streams to accomplish as much as
      would be required by many scores of the more primitive actions
      available in a basic HLL.  Consider, for example, the basic
      Hello World! application written in Tcl/Tk.
    </para><para>
      <example>
#!/usr/local/bin/wish -f

button .hello -text "Hello World!"  -command "destroy ."
pack .hello</example>
    </para><para>
      That's it!  That's all there is to it.  If you have ever programmed X
      using a traditional toolkit such as Athena or Motif, you can
      appreciate how amazingly much more convenient this is.  If not, you
      can either take our word for it that this is 20 times less code than
      you would need to use a standard toolkit, or you can go write the
      same program in one of the usual toolkits and see for yourself...
    </para><para>
      We cannot hope to provide a thorough introduction to Tk programming
      in this section.  Instead, we will just say that immensely complex
      applications can be constructed merely by programming in exactly the
      way shown in the above script.  By writing more complex scripts, and
      by utilizing the additional widgets provided by Tk, one can create
      beautiful, extensive user interfaces.  Moreover, this can be done in
      a tiny fraction of the time it takes to do the same work in a
      conventional toolkit.  Literally minutes versus days.
    </para><para>
      Tk provides widgets for labels, buttons, radio buttons, frames with
      or without borders, menubars, pull downs, toplevels, canvases, edit
      boxes, scroll bars, etc.
    </para><para>
      A look at the interface provided by the PLplot Tk driver
      should help give you a better idea of what you can do with this
      paradigm.  Also check out some of the contributed Tcl/Tk packages
      available at harbor.  There are high quality Tk interfaces to a great
      many familiar Unix utilities ranging from mail to info, to SQL, to
      news, etc.  The list is endless and growing fast...
    </para><node name="Introduction to [incr Tcl]" previous="Introduction to Tk" next="PLplot Extensions to Tcl" up="Building an Extended WISH"/><section>Introduction to [incr Tcl]</section><para>
      Another extremely powerful and popular extension to Tcl is [incr
      Tcl].  [incr Tcl] is to Tcl what C++ is to C.  The analogy is very
      extensive.  Itcl provides an object oriented extension to Tcl
      supporting clustering of procedures and data into what is called an
      <samp>itcl_class</samp>.  An <samp>itcl_class</samp> can
      have methods as well as instance data.  And they support inheritance.
      Essentially if you know how C++ relates to C, and if you know Tcl,
      then you understand the programming model provided by Itcl.
    </para><para>
      In particular, you can use Itcl to implement new widgets which are
      composed of more basic Tk widgets.  A file selector is an example.
      Using Tk, one can build up a very nice file selector comprised of
      more basic Tk widgets such as entries, listboxes, scrollbars, etc.
    </para><para>
      But what if you need two file selectors?  You have to do it all
      again.  Or what if you need two different kinds of file selectors,
      you get to do it again and add some incremental code.
    </para><para>
      This is exactly the sort of thing object orientation is intended to
      assist.  Using Itcl you can create an <samp>itcl_class
	FileSelector</samp> and then you can instantiate them freely as
      easily as:
    </para><para>
      <example>
    FileSelector .fs1
    .fs1 -dir . -find "*.cc"</example>
    </para><para>
      and so forth.
    </para><para>
      These high level widgets composed of smaller Tk widgets, are known as
      megawidgets.  There is a developing subculture of the
      Tcl/Tk community for designing and implementing megawidgets, and
      [incr Tcl] is the most popular enabling technology.
    </para><para>
      In particular, it is the enabling technology which is employed for
      the construction of the PLplot Tcl extensions, described below.
    </para><node name="PLplot Extensions to Tcl" previous="Introduction to [incr Tcl]" next="Custom Extensions to Tcl" up="Building an Extended WISH"/><section>PLplot Extensions to Tcl</section><para>
      Following the paradigm described above, PLplot provides extensions to
      Tcl as well, designed to allow the use of PLplot from Tcl/Tk
      programs.  Essentially the idea here is to allow PLplot programmers
      to achieve two goals:
    </para><itemize markchar="•"><listitem><para>
	  To access PLplot facilities from their own extended WISH and/or
	  Tcl/Tk user interface scripts.
	</para></listitem><listitem><para>
	  To have PLplot display its output in a window integrated
	  directly into the rest of their Tcl/Tk interface.
	</para></listitem></itemize><para>
      For instance, prior to PLplot 5.0, if a programmer wanted to use
      PLplot in a Tcl/Tk application, the best he could manage was to call
      the PLplot C API from compiled C code, and get the output via the
      Xwin driver, which would display in it's own toplevel window.  In
      other words, there was no integration, and the result was pretty
      sloppy.
    </para><para>
      With PLplot 5.0, there is now a supported Tcl interface to PLplot
      functionality.  This is provided through a family of
      PLplot megawidgets implemented in [incr Tcl].  Using this interface,
      a programmer can get a PLplot window/widget into a Tk interface as
      easily as:
    </para><para>
      <example>
PLWin .plw
pack .plw</example>
    </para><para>
      Actually, there's the update/init business---need to clear that up.
    </para><para>
      The <samp>PLWin</samp> class then mirrors much of the PLplot C
      API, so that a user can generate plots in the PLplot widget entirely
      from Tcl.  This is demonstrated in the <file>tk02</file>
      demo,
    </para><node name="Custom Extensions to Tcl" previous="PLplot Extensions to Tcl" up="Building an Extended WISH"/><section>Custom Extensions to Tcl</section><para>
      By this point, you should have a pretty decent understanding of the
      underlying philosophy of Tcl and Tk, and the whole concept of
      extensions, of which [incr Tcl] and PLplot are examples.  These alone
      are enough to allow the rapid prototyping and development of
      powerful, flexible graphical applications.  Normally the programmer
      simply writes a shell script to be executed by the Tk windowing
      shell, <code>wish</code>.  It is in vogue for each Tcl/Tk
      extension package to build it's own extended WISH.
      There are many examples of this, and indeed even PLplot's
      <code>plserver</code> program, described in an earlier chapter,
      could just as easily have been called <code>plwish</code>.
    </para><para>
      In any event, as exciting and useful as these standalone, extended
      windowing shells may be, they are ultimately only the beginning of
      what you can do.  The real benefit of this approach is realized when
      you make your own extended WISH, comprised of Tcl, Tk,
      any of the standard extensions you like, and finally embellished with
      a smattering of application specific extensions designed to support
      your own application domain.  In this section we give a detailed
      introduction to the process of constructing your own WISH.  After
      that, you're on your own...
    </para><menu><menuentry node="WISH Construction"><menuentrytitle>WISH Construction</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="WISH Linking"><menuentrytitle>WISH Linking</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="WISH Programming"><menuentrytitle>WISH Programming</menuentrytitle><menuentrydescrip/></menuentry></menu><node name="WISH Construction" next="WISH Linking" up="Custom Extensions to Tcl"/><subsection>WISH Construction</subsection><para>
	The standard way to make your own WISH, as supported by the Tcl/Tk
	system, is to take a boilerplate file,
	<file>tkAppInit.c</file>, edit to reflect the Tcl/Tk
	extensions you will be requiring, add some commands to the
	interpreter, and link it all together.
      </para><para>
	Here for example is the important part of the
	<file>tk02</file> demo, extracted from the file
	<file>xtk02.c</file>, which is effectively the extended
	WISH definition file for the <file>tk02</file> demo.
	Comments and other miscellany are omitted.
      </para><para>
	<example>
#include "tk.h"
#include "itcl.h"

/* ... */

int   myplotCmd        (ClientData, Tcl_Interp *, int, char **);

int
Tcl_AppInit(interp)
    Tcl_Interp *interp;		/* Interpreter for application. */
{
int   plFrameCmd        (ClientData, Tcl_Interp *, int, char **);

    Tk_Window main;

    main = Tk_MainWindow(interp);

    /*
     * Call the init procedures for included packages.  Each call should
     * look like this:
     *
     * if (Mod_Init(interp) == TCL_ERROR) {
     *     return TCL_ERROR;
     * }
     *
     * where "Mod" is the name of the module.
     */

    if (Tcl_Init(interp) == TCL_ERROR) {
        return TCL_ERROR;
    }
    if (Tk_Init(interp) == TCL_ERROR) {
        return TCL_ERROR;
    }
    if (Itcl_Init(interp) == TCL_ERROR) {
        return TCL_ERROR;
    }
    if (Pltk_Init(interp) == TCL_ERROR) {
        return TCL_ERROR;
    }

    /*
     * Call Tcl_CreateCommand for application-specific commands, if
     * they weren't already created by the init procedures called above.
     */

    Tcl_CreateCommand(interp, "myplot", myplotCmd,
                      (ClientData) main, (void (*)(ClientData)) NULL);


    /*
     * Specify a user-specific startup file to invoke if the
     * application is run interactively.  Typically the startup
     * file is "~/.apprc" where "app" is the name of the application.
     * If this line is deleted then no user-specific startup file
     * will be run under any conditions.
     */

    tcl_RcFileName = "~/.wishrc";
    return TCL_OK;
}

/* ... myPlotCmd, etc ... */</example>
      </para><para>
	The calls to <samp>Tcl_Init()</samp> and
	<samp>Tk_Init()</samp> are in every WISH.  To make an
	extended WISH, you add calls to the initialization routines for any
	extension packages you want to use, in this [incr Tcl]
	(<samp>Itcl_Init()</samp>) and PLplot
	(<samp>Pltk_Init()</samp>).  Finally you add keywords to the
	interpreter, associating them with functions in your code using
	<samp>Tcl_CreateCommand()</samp> as shown.
      </para><para>
	In particular, PLplot has a number of [incr Tcl] classes in its Tcl
	library.  If you want to be able to use those in your WISH, you
	need to include the initialization of [incr Tcl].
      </para><node name="WISH Linking" previous="WISH Construction" next="WISH Programming" up="Custom Extensions to Tcl"/><subsection>WISH Linking</subsection><para>
	Having constructed your <samp>Tcl_AppInit()</samp> function,
	you now merely need to link this file with your own private files
	to provide the code for any functions you registered via
	<samp>Tcl_CreateCommand()</samp> (and any they depend on),
	against the Tcl, Tk and extension libraries you are using.
      </para><para>
	<example>
cc -c tkAppInit.c
cc -c mycommands.c
cc -o my_wish tkAppInit.o mycommands.o 
           -lplplotftk -ltcl -ltk -litcl -lX11 -lm</example>
      </para><para>      
	Add any needed <samp>-L</samp> options as needed.
      </para><para>
	Voila!  You have made a wish.
      </para><node name="WISH Programming" previous="WISH Linking" up="Custom Extensions to Tcl"/><subsection>WISH Programming</subsection><para>
	Now you are ready to put the genie to work.  The basic plan here is
	to write shell scripts which use your new application specific
	windowing shell as their interpreter, to implement X Windows user
	interfaces to control and utilize the facilities made available in
	your extensions.
      </para><para>
	Effectively this just comes down to writing Tcl/Tk code, embellished
	as appropriate with calls to the extension commands you registered.
	Additionally, since this wish includes the PLplot extensions, you
	can instantiate any of the PLplot family of [incr Tcl] classes, and
	invoke methods on those objects to effect the drawing of graphs.
	Similarly, you may have your extension commands (which are coded in
	C) call the PLplot C programmers API to draw into the widget.  In
	this way you can have the best of both worlds.  Use compiled C code
	when the computational demands require the speed of compiled code,
	or use Tcl when your programming convenience is more important than
	raw speed.
      </para><node name="Embedding Plots in Graphical User Interfaces" previous="Building an Extended WISH" next="Using PLplot from Perl" up="Top"/><chapter>Embedding Plots in Graphical User Interfaces</chapter><para>
This chapter describes how to embed plots in graphical user interfaces.
</para><menu><menuentry node="The PlplotCanvas Widget for Gnome/GTK Applications"><menuentrytitle>The PlplotCanvas Widget for Gnome/GTK Applications</menuentrytitle><menuentrydescrip/></menuentry></menu><node name="The PlplotCanvas Widget for Gnome/GTK Applications" up="Embedding Plots in Graphical User Interfaces"/><section>The PlplotCanvas Widget for Gnome/GTK Applications</section><para>
    Plots can be embedded into Gnome/GTK applications by using the
    PlplotCanvas widget.  Information on the GTK toolkit is provided
    at http://www.gtk.org/.  PlplotCanvas is a subclass of the GnomeCanvas
    (see http://developer.gnome.org/doc/API/2.0/libgnomecanvas/index.html), 
    and so includes all of its functionality.  The specialized C API for 
    PlplotCanvas is described in
    <ref node="PlplotCanvas API" file="">PlplotCanvas API</ref>, and bindings to other languages
    are described in *** NEEDS DOCUMENTATION ***.
  </para><menu><menuentry node="PlplotCanvas Basics"><menuentrytitle>PlplotCanvas Basics</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="PlplotCanvas API"><menuentrytitle>PlplotCanvas API</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="PlplotCanvas Examples"><menuentrytitle>PlplotCanvas Examples</menuentrytitle><menuentrydescrip/></menuentry></menu><node name="PlplotCanvas Basics" next="PlplotCanvas API" up="The PlplotCanvas Widget for Gnome/GTK Applications"/><subsection>PlplotCanvas Basics</subsection><para>
      The method declarations and data structures are defined in 
      <file>plplotcanvas.h</file>.  Programs using the PlplotCanvas
      widget must be linked against the 
      <file>libplplotgnome2d</file> library 
      rather than <file>libplplotd</file>.  This is most easily 
      accomplished using pkg-config; i.e.,

      <example>
        gcc plplotcanvas_demo.c -o plplotcanvas_demo `pkg-config --cflags --libs plplotd-gnome2`
      </example>

      You may need to remind pkg-config where to look for the 
      <file>plplotd-gnome2.pc</file> file installed by PLplot; e.g.,

      <example>
        gcc plplotcanvas_demo.c -o plplotcanvas_demo `PKG_CONFIG_PATH=/usr/local/lib/pkgconfig pkg-config --cflags --libs plplotd-gnome2`
      </example>
    </para><para>
      A specialized API is provided for PlplotCanvas and is described in
      <ref node="PlplotCanvas API" file="">PlplotCanvas API</ref>.  The API provides methods
      to create and manipulate PlplotCanvas widgets, in addition to
      object-oriented analogues for each of the PLplot functions.
    </para><para>
      Example programs are provided that demonstrate the use of the 
      PlplotCanvas widget in <ref node="PlplotCanvas Examples" file="">PlplotCanvas Examples</ref>.
    </para><node name="PlplotCanvas API" previous="PlplotCanvas Basics" next="PlplotCanvas Examples" up="The PlplotCanvas Widget for Gnome/GTK Applications"/><subsection>PlplotCanvas API</subsection><para>
      The PlplotCanvas methods are as follows.  Because PlplotCanvas is a
      GTK widget, GLib types (gint, gdouble, gboolean, etc) are sometimes 
      used rather than PLplot types (PLINT, PLFLT, etc).  See 
      http://developer.gnome.org/doc/API/2.0/glib/index.html for more 
      information on GLib and GLib types.
    </para><menu><menuentry node="&#10;        plplot_canvas_new; Creates a new PlplotCanvas_&#10;      "><menuentrytitle>
        plplot_canvas_new: Creates a new PlplotCanvas.
      </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;        plplot_canvas_plfunc; PLplot function analogues_&#10;      "><menuentrytitle>
        plplot_canvas_plfunc: PLplot function analogues.
      </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;        plplot_canvas_dispose; Disposes the canvas_&#10;      "><menuentrytitle>
        plplot_canvas_dispose: Disposes the canvas.
      </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;        plplot_canvas_set_size; Sets the canvas size_&#10;      "><menuentrytitle>
        plplot_canvas_set_size: Sets the canvas size.
      </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;        plplot_canvas_use_text; Sets text handling_&#10;      "><menuentrytitle>
        plplot_canvas_use_text: Sets text handling.
      </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;        plplot_canvas_use_pixmap; Sets pixmap usage_&#10;      "><menuentrytitle>
        plplot_canvas_use_pixmap: Sets pixmap usage.
      </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;        plplot_canvas_use_persistence; Sets persistence&#10;        of subsequent drawing operations_&#10;      "><menuentrytitle>
        plplot_canvas_use_persistence: Sets persistence
        of subsequent drawing operations.
      </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;        plplot_canvas_get_stream_number; Retrieves the&#10;&#9;PLplot stream number_&#10;      "><menuentrytitle>
        plplot_canvas_get_stream_number: Retrieves the
	PLplot stream number.
      </menuentrytitle><menuentrydescrip/></menuentry></menu><node name="&#10;        plplot_canvas_new; Creates a new PlplotCanvas_&#10;      " next="&#10;        plplot_canvas_plfunc; PLplot function analogues_&#10;      " up="PlplotCanvas API"/><subsubsection>
        plplot_canvas_new: Creates a new PlplotCanvas.
      </subsubsection><para>
        <quotation><para><t><b>
            PlplotCanvas* plplot_canvas_new
          </b>(<i>void</i>);</t></para></quotation>
      </para><para>
        Returns a pointer to a new PlplotCanvas widget.  Methods that
	apply to a PlplotCanvas are given next.
      </para><varlist><varlistentry><term>
            <code>void</code> 
          </term><listitem><para>
            There are no arguments for this method.
          </para></listitem></varlistentry></varlist><node name="&#10;        plplot_canvas_plfunc; PLplot function analogues_&#10;      " previous="&#10;        plplot_canvas_new; Creates a new PlplotCanvas_&#10;      " next="&#10;        plplot_canvas_dispose; Disposes the canvas_&#10;      " up="PlplotCanvas API"/><subsubsection>
        plplot_canvas_plfunc: PLplot function analogues.
      </subsubsection><para>
        <quotation><para><t><b>void plplot_canvas_plfunc</b>(<i>canvas</i>, <i>...</i>);</t></para></quotation>
      </para><para>
        The PLplot functions have analogue methods named like
	<code>plplot_canvas_plfunc</code>.  For example, the 
        PLplot function <code>plline</code> (<pxref node="&#10;      plline; Draw a line&#10;    " file=""/>) maps to 
        <code>plplot_canvas_plline</code>.  The 
        <code>plplot_canvas_plfunc</code> methods
	should be used rather than the standard PLplot API when the
	PlplotCanvas is used.
      </para><para>
        Lines drawn to the canvas are not shown until the page is
        advanced using <code>plplot_canvas_pladv</code>.  The 
        plot will remain on the canvas until the next page advance.
      </para><para>
        The PLplot <code>plinit</code> (<pxref node="&#10;      plinit; Initialize PLplot&#10;    " file=""/>) and <code>plgstrm</code> (<pxref node="&#10;      plgstrm; Get current stream number&#10;    " file=""/>) functions are not used with 
        PlplotCanvas because the <code>plplot_canvas_new</code>
        function does the necessary initialization and returns an 
        object with a unique stream number.
      </para><varlist><varlistentry><term>
            <code>canvas</code> 
            (<samp>PlplotCanvas*</samp>, input)
          </term><listitem><para>The canvas on which to operate.</para></listitem></varlistentry><varlistentry><term>
            <code>...</code> 
          </term><listitem><para>
            The list of arguments from the PLplot function analogue.  The
	    same types used in the PLplot function are used here.
          </para></listitem></varlistentry></varlist><node name="&#10;        plplot_canvas_dispose; Disposes the canvas_&#10;      " previous="&#10;        plplot_canvas_plfunc; PLplot function analogues_&#10;      " next="&#10;        plplot_canvas_set_size; Sets the canvas size_&#10;      " up="PlplotCanvas API"/><subsubsection>
        plplot_canvas_dispose: Disposes the canvas.
      </subsubsection><para>
        <quotation><para><t><b>void plplot_canvas_dispose</b>(<i>canvas</i>);</t></para></quotation>
      </para><para>
        Disposes the Canvas.
      </para><varlist><varlistentry><term>
            <code>canvas</code> 
            (<samp>PlplotCanvas*</samp>, input)
          </term><listitem><para>The canvas to dispose.</para></listitem></varlistentry></varlist><node name="&#10;        plplot_canvas_set_size; Sets the canvas size_&#10;      " previous="&#10;        plplot_canvas_dispose; Disposes the canvas_&#10;      " next="&#10;        plplot_canvas_use_text; Sets text handling_&#10;      " up="PlplotCanvas API"/><subsubsection>
        plplot_canvas_set_size: Sets the canvas size.
      </subsubsection><para>
        <quotation><para><t><b>
            void plplot_canvas_set_size
          </b>(<i>canvas</i>, <i>width</i>, <i>height</i>);</t></para></quotation>
      </para><para>
        Sets the PlplotCanvas widget width and height.
      </para><varlist><varlistentry><term>
            <code>canvas</code> 
            (<samp>PlplotCanvas*</samp>, input)
          </term><listitem><para>The PlplotCanvas to size.</para></listitem></varlistentry><varlistentry><term>
            <code>width</code> (<samp>gint</samp>, input)
          </term><listitem><para>The width, in pixels.</para></listitem></varlistentry><varlistentry><term>
            <code>height</code> (<samp>gint</samp>, input)
          </term><listitem><para>The height, in pixels.</para></listitem></varlistentry></varlist><node name="&#10;        plplot_canvas_use_text; Sets text handling_&#10;      " previous="&#10;        plplot_canvas_set_size; Sets the canvas size_&#10;      " next="&#10;        plplot_canvas_use_pixmap; Sets pixmap usage_&#10;      " up="PlplotCanvas API"/><subsubsection>
        plplot_canvas_use_text: Sets text handling.
      </subsubsection><para>
        <quotation><para><t><b>void plplot_canvas_use_text</b>(<i>canvas</i>, <i>use_text</i>);</t></para></quotation>
      </para><para>
        Sets whether TrueType text or Hershey fonts are used by the
	PlplotCanvas widget.
      </para><varlist><varlistentry><term>
            <code>canvas</code> 
            (<samp>PlplotCanvas*</samp>, input)
          </term><listitem><para>The PlplotCanvas to set.</para></listitem></varlistentry><varlistentry><term>
            <code>use_text</code> 
            (<samp>gboolean</samp>, input)
          </term><listitem><para>
            TRUE for TrueType fonts (default), FALSE for Hershey fonts.
          </para></listitem></varlistentry></varlist><node name="&#10;        plplot_canvas_use_pixmap; Sets pixmap usage_&#10;      " previous="&#10;        plplot_canvas_use_text; Sets text handling_&#10;      " next="&#10;        plplot_canvas_use_persistence; Sets persistence&#10;        of subsequent drawing operations_&#10;      " up="PlplotCanvas API"/><subsubsection>
        plplot_canvas_use_pixmap: Sets pixmap usage.
      </subsubsection><para>
        <quotation><para><t><b>void plplot_canvas_use_pixmap</b>(<i>canvas</i>, <i>use_pixmap</i>);</t></para></quotation>
      </para><para>
        Sets whether lines and shades are drawn to a pixmap,
        or instead as vector graphics.
      </para><para>
        Lines and shade drawn to the pixmap are not anti-aliased, and so may
        appear pixelated.  Vector graphics are fully anti-aliased, but are
        rendered at a slower speed.
      </para><varlist><varlistentry><term>
            <code>canvas</code> 
            (<samp>PlplotCanvas*</samp>, input)
          </term><listitem><para>The PlplotCanvas to set.</para></listitem></varlistentry><varlistentry><term>
            <code>use_pixmap</code> 
            (<samp>gboolean</samp>, input)
          </term><listitem><para>
            TRUE to use pixmap (default), FALSE for vector graphics instead.
          </para></listitem></varlistentry></varlist><node name="&#10;        plplot_canvas_use_persistence; Sets persistence&#10;        of subsequent drawing operations_&#10;      " previous="&#10;        plplot_canvas_use_pixmap; Sets pixmap usage_&#10;      " next="&#10;        plplot_canvas_get_stream_number; Retrieves the&#10;&#9;PLplot stream number_&#10;      " up="PlplotCanvas API"/><subsubsection>
        plplot_canvas_use_persistence: Sets persistence
        of subsequent drawing operations.
      </subsubsection><para>
        <quotation><para><t><b>
            void plplot_canvas_use_persistence
          </b>(<i>canvas</i>, <i>use_persistence</i>);</t></para></quotation>
      </para><para>
        Sets whether the subsequent drawing commands are persistent,
	or refreshed when the PLplot page is advanced.  This feature
	is useful for plot animations, because the axes can be persistent
	rather than redrawn for each frame.
      </para><para>
        Note that lines that are persistent are always anti-aliased and
        drawn at the front.
      </para><varlist><varlistentry><term>
            <code>canvas</code> 
            (<samp>PlplotCanvas*</samp>, input)
          </term><listitem><para>The PlplotCanvas to set.</para></listitem></varlistentry><varlistentry><term>
            <code>use_persistence</code> 
            (<samp>gboolean</samp>, input)
          </term><listitem><para>
            TRUE for persistence, FALSE for erasing at new page (default).
          </para></listitem></varlistentry></varlist><node name="&#10;        plplot_canvas_get_stream_number; Retrieves the&#10;&#9;PLplot stream number_&#10;      " previous="&#10;        plplot_canvas_use_persistence; Sets persistence&#10;        of subsequent drawing operations_&#10;      " up="PlplotCanvas API"/><subsubsection>
        plplot_canvas_get_stream_number: Retrieves the
	PLplot stream number.
      </subsubsection><para>
        <quotation><para><t><b>
            PLINT plplot_canvas_get_stream_number
          </b>(<i>canvas</i>);</t></para></quotation>
      </para><para>
        Returns the stream number for the given Canvas.  Although the 
	concept of streams that exists in the standard PLplot API is not
	used here, the stream number provides a unique ID number for
	the given PlplotCanvas widget.
      </para><varlist><varlistentry><term>
            <code>canvas</code>
            (<samp>PlplotCanvas*</samp>, input)
          </term><listitem><para>
            The canvas to retrieve the stream number from.
          </para></listitem></varlistentry></varlist><node name="PlplotCanvas Examples" previous="PlplotCanvas API" up="The PlplotCanvas Widget for Gnome/GTK Applications"/><subsection>PlplotCanvas Examples</subsection><para>

      Two example programs are provided that demonstrate the use of the
      PlplotCanvas widget.  They are:

      <itemize markchar="•"><listitem><para>
          plplotcanvas_demo: Demonstrates the basic usage of the 
          PlplotCanvas to embed a plot in a Gnome application.
        </para></listitem><listitem><para>
          plplotcanvas_animation: Demonstrates advanced multi-threaded 
          dual-stream usage of the PlplotCanvas.
        </para></listitem></itemize>
    </para><para>
      The code from plplotcanvas_demo.c is given below, and is explained
      in what follows.
    </para><example>

#include &lt;plplotcanvas.h&gt;
#include &lt;gtk/gtk.h&gt;

/* The width and height of the plplot canvas widget */
#define WIDTH 1000 /* 500 */
#define HEIGHT 600 /* 300 */

/* Delete event callback */
gint delete_event( GtkWidget *widget,GdkEvent *event,gpointer data ) {
  return FALSE;
}

/* Destroy event calback */
void destroy(GtkWidget *widget,gpointer data) {
  gtk_main_quit ();
}


int main(int argc,char *argv[] )
{

  PlplotCanvas* canvas;
  GtkWidget *window;

  /* Parse the options */
  plparseopts(&amp;argc, argv, PL_PARSE_FULL);

  /* The data to plot */
  double x[11] = {0,1,2,3,4,5,6,7,8,9,10};
  double y[11] = {0,0.1,0.4,0.9,1.6,2.6,3.6,4.9,6.4,8.1,10};

  /* Initialize gtk and the glib type system */
  gtk_init(&amp;argc, &amp;argv);
  g_type_init();

  /* Create the canvas and set its size; during the creation process,
   * the gcw driver is loaded into plplot, and plinit() is invoked.
   */
  canvas=plplot_canvas_new(TRUE);
  plplot_canvas_set_size(canvas,WIDTH,HEIGHT);

  /* Create a new window and stuff the canvas into it */
  window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
  gtk_container_set_border_width(GTK_CONTAINER(window),10);
  gtk_container_add(GTK_CONTAINER(window),GTK_WIDGET(canvas));

  /* Connect the signal handlers to the window decorations */
  g_signal_connect(G_OBJECT(window),"delete_event",
		   G_CALLBACK(delete_event),NULL);
  g_signal_connect(G_OBJECT(window),"destroy",G_CALLBACK(destroy),NULL);

  /* Display everything */
  gtk_widget_show_all(window);

  /* Draw on the canvas with Plplot */
  plplot_canvas_pladv(canvas,0); /* Advance to first page */
  plplot_canvas_plcol0(canvas,15); /* Set color to black */
  plplot_canvas_plwid(canvas,2); /* Set the pen width */
  plplot_canvas_plvsta(canvas); /* Set the viewport */
  plplot_canvas_plwind(canvas,0.,10.,0.,10.); /* Set the window */
  plplot_canvas_plbox(canvas,"bcnst",0.,0,"bcnstv",0.,0); /* Set the box */
  plplot_canvas_pllab(canvas,"x-axis","y-axis","A Simple Plot"); /* Draw some labels */

  /* Draw the line */
  plplot_canvas_plcol0(canvas,1); /* Set the pen color */
  plplot_canvas_plline(canvas,11,x,y);

  /* Advancing the page finalizes this plot */
  plplot_canvas_pladv(canvas,0);

  /* Start the gtk main loop */
  gtk_main();
}
</example><para>
      So, what's going on here?  After the preliminaries, the GTK and the 
      GLib type system are initialized by calls to 
      <code>gtk_init</code> and <code>g_type_init</code>.  
      A PlplotCanvas is created using 
      <code>plplot_canvas_new</code>, and it's size is set using 
      <code>plplot_canvas_set_size</code>.  
    </para><para>
      Next, a window is created (<code>gtk_window_new</code>), 
      the border is set (<code>gtk_set_border_width</code>), 
      and the canvas is stuffed into the window 
      (<code>gtk_container_add</code>).  
    </para><para>
      Callback functions are installed using 
      <code>g_signal_connect</code> so that the window 
      decorations respond. The window is set to display everything using
      <code>gtk_widget_show_all</code>.
    </para><para>
      Now come the PLplot analogue commands.  First, the page using is
      advanced using <code>plplot_canvas_pladv</code>.  The pen 
      color and width are set with <code>plplot_canvas_plcol0</code> 
      and <code>plplot_canvas_plwid</code>,respectively.  The PLplot
      viewport, window, box and labels are created using 
      <code>plplot_canvas_plvpor</code>, 
      <code>plplot_canvas_plwind</code>, 
      <code>plplot_canvas_plbox</code> and 
      <code>plplot_canvas_pllab</code>, respectively.  A line is 
      drawn on the canvas using <code>plplot_canvas_plline</code>, 
      the page is advanced with <code>plplot_canvas_pladv</code>.
    </para><para>
      Finally, the GTK main loop is entered using 
      <code>gtk_main</code>, where it resides until the program
      is exited.
    </para><node name="Using PLplot from Perl" previous="Embedding Plots in Graphical User Interfaces" next="Using PLplot from Python" up="Top"/><chapter>Using PLplot from Perl</chapter><para>
    There are no proper bindings for the Perl language delivered with the
    PLplot sources.  However, a PLplot interface has been added to the Perl
    Data Language (PDL) since version 2.4.0.  If the PLplot library is
    installed in the system, it is automatically detected by the PDL
    configuration script, such that PLplot support for PDL should work out
    of the box.  For further informations see the <uref url="http://pdl.perl.org">PDL homepage</uref>.  Here is an usage
    example:
  </para><para>
      <example>
use PDL;
use PDL::Graphics::PLplot;

$x = pdl (0..5);
$y = $x ** 2;

plsdev ("xwin");
plinit ();
plcol0 (1);

plenv (-0.5, 5.5, -1, 26, 0, 0);
plline ($x, $y);

plend ();
    </example>
  </para><para>
    There is also a Perl PLplot interface on <uref url="http://www.cpan.org">CPAN</uref> which is not dependent on PDL.
    The Perl module is called <uref url="http://search.cpan.org/%7Etjenness/">Graphics::PLplot</uref> and is
    appropriate for small data arrays.  The API is very similar to the C
    API except that if the number of elements in an array is required by
    the C function the perl interface calculates it automatically.  Also,
    return values are returned and not supplied as arguments.  Here is the
    PDL example above translated to Graphics::PLplot:
  </para><para>
      <example>
use Graphics::PLplot qw/ :all /;

@x = (0..5);
@y = map {$_ * $_} @x;

plsdev ("xwin");
plinit ();
plcol0 (1);

plenv (-0.5, 5.5, -1, 26, 0, 0);
plline (\@x, \@y);

plend ();
      </example>
    </para><node name="Using PLplot from Python" previous="Using PLplot from Perl" next="Bibliography" up="Top"/><chapter>Using PLplot from Python</chapter><para>
  NEEDS DOCUMENTATION, but here is the short story.  We currently (February,
2001) have
switched to dynamic loading of plplot following the generic method given
in the python documentation.  Most (???) of the PLplot common API
has been implemented.  (For a complete list see plmodules.c and plmodules2.c).
With this dynamic method all the xw??.py examples
work fine and should be consulted for the best way to use PLplot from python.
You may have to set PYTHONPATH to the path where plmodule.so is located
(or eventually installed).  For more information see examples/python/README
</para><para>
pytkdemo and the x??.py examples it loads use the plframe widget.  Thus,
this method does not currently work under
dynamic loading.  They have only worked in the past using the static method
with much hacking and rebuilding of python itself.  We plan to try dynamic
loading of all of PLplot (not just the plmodule.c and plmodule2.c wrappers)
including plframe (or a python-variant of this widget) into python at some
future date to see whether it is possible to get pytkdemo and the
x??.py examples working
under dynamic loading, but only the individual stand-alone xw??.py demos
work at the moment.
</para><node name="Bibliography" previous="Using PLplot from Python" next="The Common API for PLplot" up="Top"/><chapter>Bibliography</chapter><para>
These articles are descriptions of PLplot itself or else scientific
publications whose figures were generated with PLplot.
</para><menu><menuentry node="References"><menuentrytitle>References</menuentrytitle><menuentrydescrip/></menuentry></menu><node name="References" up="Bibliography"/><section>References</section><para>
  
      Furnish G.,
      Das Graphikpaket PLplot (in German)
(http://www.linux-magazin.de/ausgabe/1996/12/Plplot/plplot.html),
  
  
      <i>Linux Magazin</i>,
      1996 December
  
</para><para>
  
      Furnish G.,
      Horton W.,
      Kishimoto Y.,
      LeBrun M.,
      Tajima T.,
      Global Gyrokinetic Simulation of Tokamak
Transport,
  
  
      <i>Physics of Plasmas</i>,
      6,
      1,
      1999
  
</para><para>
  
      Irwin A.W.,
      Fukushima T.,
      A Numerical Time Ephemeris of the Earth,
  
  
      <i>Astronomy and Astrophysics</i>,
      348,
      642,
      1999
  
</para><para>
  
      LeBrun M.J.,
      Tajima T.,
      Gray M.,
      Furnish G.,
      Horton W.,
      Toroidal Effects on Drift-Wave Turbulence,
  
  
      <i>Physics of Fluids</i>,
      B5,
      752,
      1993
  
</para><node name="The Common API for PLplot" previous="Bibliography" next="The Specialized C API for PLplot" up="Top"/><chapter>The Common API for PLplot</chapter><para>
  The purpose of this chapter is to document the API for every C function in
  PLplot that should have a counterpart in other PLplot language bindings such as
  Fortran.  These common API routines have a special
  c_ prefix name assigned to them in <file>plplot.h</file>.
  This common API between the various languages constitutes the
  most important part of the PLplot API that programmers need to know.
  Additional PLplot API specialized for each language binding is documented
  in <ref node="The Specialized C API for PLplot" file="">The Specialized C API for PLplot</ref> and subsequent chapters.
  </para><para>
All common API functions of the current CVS HEAD are listed here with their
arguments except for obsolete/deprecated API which is listed in <ref node="Obsolete/Deprecated API for PLplot" file="">Obsolete/Deprecated API for PLplot</ref>.
All functions have a short description, and all parameters are documented.
  </para><menu><menuentry node="pl_setcontlabelformat; Set&#10;format of numerical label for contours"><menuentrytitle>pl_setcontlabelformat: Set
format of numerical label for contours</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="pl_setcontlabelparam; Set parameters of&#10;contour labelling other than format of numerical label"><menuentrytitle>pl_setcontlabelparam: Set parameters of
contour labelling other than format of numerical label</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="pladv; Advance the [sub-]page"><menuentrytitle>pladv: Advance the (sub-)page</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plaxes; Draw a box with axes; etc_ with arbitrary&#10;origin&#10;    "><menuentrytitle>
      plaxes: Draw a box with axes, etc. with arbitrary
origin
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plbin; Plot a histogram from binned data&#10;    "><menuentrytitle>
      plbin: Plot a histogram from binned data
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="plbop; Begin a new page"><menuentrytitle>plbop: Begin a new page</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="plbox; Draw a box with axes; etc"><menuentrytitle>plbox: Draw a box with axes, etc</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plbox3; Draw a box with axes; etc; in 3-d&#10;    "><menuentrytitle>
      plbox3: Draw a box with axes, etc, in 3-d
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plcalc_world; Calculate world coordinates and&#10;corresponding window index from relative device coordinates&#10;    "><menuentrytitle>
      plcalc_world: Calculate world coordinates and
corresponding window index from relative device coordinates
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plclear; Clear current [sub]page&#10;    "><menuentrytitle>
      plclear: Clear current (sub)page
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plcol0; Set color; map0&#10;    "><menuentrytitle>
      plcol0: Set color, map0
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plcol1; Set color; map1&#10;    "><menuentrytitle>
      plcol1: Set color, map1
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plcont; Contour plot&#10;    "><menuentrytitle>
      plcont: Contour plot
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plcpstrm; Copy state parameters from the&#10;reference stream to the current stream&#10;    "><menuentrytitle>
      plcpstrm: Copy state parameters from the
reference stream to the current stream
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plend; End plotting session&#10;    "><menuentrytitle>
      plend: End plotting session
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plend1; End plotting session for current stream&#10;    "><menuentrytitle>
      plend1: End plotting session for current stream
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plenv0; Same as plenv but if in multiplot&#10;      mode does not advance the subpage; instead clears it_&#10;    "><menuentrytitle>
      plenv0: Same as <code>plenv</code> but if in multiplot
      mode does not advance the subpage, instead clears it.
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plenv; Set up standard window and draw box&#10;    "><menuentrytitle>
      plenv: Set up standard window and draw box
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      pleop; Eject current page&#10;    "><menuentrytitle>
      pleop: Eject current page
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plerrx; Draw x error bar&#10;    "><menuentrytitle>
      plerrx: Draw x error bar
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plerry; Draw y error bar&#10;    "><menuentrytitle>
      plerry: Draw y error bar
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plfamadv; Advance to the next family file on the&#10;next new page&#10;    "><menuentrytitle>
      plfamadv: Advance to the next family file on the
next new page
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plfill; Draw filled polygon&#10;    "><menuentrytitle>
      plfill: Draw filled polygon
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plfill3; Draw filled polygon in 3D&#10;    "><menuentrytitle>
      plfill3: Draw filled polygon in 3D
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plflush; Flushes the output stream&#10;    "><menuentrytitle>
      plflush: Flushes the output stream
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plfont; Set character font&#10;    "><menuentrytitle>
      plfont: Set character font
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plfontld; Load character font&#10;    "><menuentrytitle>
      plfontld: Load character font
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgchr; Get character default height and current&#10;[scaled] height&#10;    "><menuentrytitle>
      plgchr: Get character default height and current
(scaled) height
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgcol0; Returns 8-bit RGB values for given color&#10;from color map0&#10;    "><menuentrytitle>
      plgcol0: Returns 8-bit RGB values for given color
from color map0
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgcolbg;  Returns the background color&#10;[cmap0[0]] by 8-bit RGB value&#10;    "><menuentrytitle>
      plgcolbg:  Returns the background color
(cmap0[0]) by 8-bit RGB value
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgcompression; Get the current&#10;      device-compression setting&#10;    "><menuentrytitle>
      plgcompression: Get the current
      device-compression setting
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgdev; Get the current device [keyword] name&#10;    "><menuentrytitle>
      plgdev: Get the current device (keyword) name
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgdidev; Get parameters that define current&#10;      device-space window&#10;    "><menuentrytitle>
      plgdidev: Get parameters that define current
      device-space window
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgdiori; Get plot orientation&#10;    "><menuentrytitle>
      plgdiori: Get plot orientation
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgdiplt; Get parameters that define current&#10;      plot-space window&#10;    "><menuentrytitle>
      plgdiplt: Get parameters that define current
      plot-space window
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgfam; Get family file parameters&#10;    "><menuentrytitle>
      plgfam: Get family file parameters
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgfci; Get FCI [font characterization integer]&#10;    "><menuentrytitle>
      plgfci: Get FCI (font characterization integer)
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgfnam; Get output file name&#10;    "><menuentrytitle>
      plgfnam: Get output file name
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plglevel; Get the [current] run level&#10;    "><menuentrytitle>
      plglevel: Get the (current) run level
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgpage; Get page parameters&#10;    "><menuentrytitle>
      plgpage: Get page parameters
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgra; Switch to graphics screen&#10;    "><menuentrytitle>
      plgra: Switch to graphics screen
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgriddata; Grid data from irregularly sampled&#10;      data&#10;    "><menuentrytitle>
      plgriddata: Grid data from irregularly sampled
      data
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgspa; Get current subpage parameters&#10;    "><menuentrytitle>
      plgspa: Get current subpage parameters
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgstrm; Get current stream number&#10;    "><menuentrytitle>
      plgstrm: Get current stream number
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgver; Get the current library version number&#10;    "><menuentrytitle>
      plgver: Get the current library version number
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgvpd; Get viewport limits in normalized&#10;device coordinates&#10;    "><menuentrytitle>
      plgvpd: Get viewport limits in normalized
device coordinates
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgvpw; Get viewport limits in world coordinates&#10;    "><menuentrytitle>
      plgvpw: Get viewport limits in world coordinates
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgxax; Get x axis parameters&#10;    "><menuentrytitle>
      plgxax: Get x axis parameters
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgyax; Get y axis parameters&#10;    "><menuentrytitle>
      plgyax: Get y axis parameters
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgzax; Get z axis parameters&#10;    "><menuentrytitle>
      plgzax: Get z axis parameters
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plhist; Plot a histogram from unbinned data&#10;    "><menuentrytitle>
      plhist: Plot a histogram from unbinned data
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plhlsrgb; Convert HLS color to RGB&#10;    "><menuentrytitle>
      plhlsrgb: Convert HLS color to RGB
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plinit; Initialize PLplot&#10;    "><menuentrytitle>
      plinit: Initialize PLplot
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      pljoin; Draw a line between two points&#10;    "><menuentrytitle>
      pljoin: Draw a line between two points
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      pllab; Simple routine to write labels&#10;    "><menuentrytitle>
      pllab: Simple routine to write labels
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      pllightsource; Sets the 3D position of the light&#10;source&#10;    "><menuentrytitle>
      pllightsource: Sets the 3D position of the light
source
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plline; Draw a line&#10;    "><menuentrytitle>
      plline: Draw a line
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plline3; Draw a line in 3 space&#10;    "><menuentrytitle>
      plline3: Draw a line in 3 space
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      pllsty; Select line style&#10;    "><menuentrytitle>
      pllsty: Select line style
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plmesh; Plot surface mesh&#10;    "><menuentrytitle>
      plmesh: Plot surface mesh
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plmeshc; Magnitude colored plot surface mesh with contour_&#10;    "><menuentrytitle>
      plmeshc: Magnitude colored plot surface mesh with contour.
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plmkstrm; Creates a new stream and makes it the&#10;default&#10;    "><menuentrytitle>
      plmkstrm: Creates a new stream and makes it the
default
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plmtex; Write text relative to viewport boundaries&#10;    "><menuentrytitle>
      plmtex: Write text relative to viewport boundaries
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plot3d; Plot 3-d surface plot&#10;    "><menuentrytitle>
      plot3d: Plot 3-d surface plot
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plot3dc; Magnitude colored plot surface with contour_&#10;    "><menuentrytitle>
      plot3dc: Magnitude colored plot surface with contour.
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plparseopts; Parse command-line arguments&#10;    "><menuentrytitle>
      plparseopts: Parse command-line arguments
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plpat; Set area fill pattern&#10;    "><menuentrytitle>
      plpat: Set area fill pattern
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plpoin; Plots a character at the specified points&#10;    "><menuentrytitle>
      plpoin: Plots a character at the specified points
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plpoin3;  Plots a character at the specified&#10;      points in 3 space&#10;    "><menuentrytitle>
      plpoin3:  Plots a character at the specified
      points in 3 space
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plpoly3; Draw a polygon in 3 space&#10;    "><menuentrytitle>
      plpoly3: Draw a polygon in 3 space
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plprec; Set precision in numeric labels&#10;    "><menuentrytitle>
      plprec: Set precision in numeric labels
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plpsty; Select area fill pattern&#10;    "><menuentrytitle>
      plpsty: Select area fill pattern
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plptex; Write text inside the viewport&#10;    "><menuentrytitle>
      plptex: Write text inside the viewport
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plreplot; Replays contents of plot buffer to&#10;current device/file&#10;    "><menuentrytitle>
      plreplot: Replays contents of plot buffer to
current device/file
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plrgbhls; Convert RGB color to HLS&#10;    "><menuentrytitle>
      plrgbhls: Convert RGB color to HLS
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plschr; Set character size&#10;    "><menuentrytitle>
      plschr: Set character size
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plscmap0; Set color map0 colors by 8-bit RGB&#10;values&#10;    "><menuentrytitle>
      plscmap0: Set color map0 colors by 8-bit RGB
values
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plscmap0n; Set number of colors in color map0&#10;    "><menuentrytitle>
      plscmap0n: Set number of colors in color map0
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plscmap1; Set color map1 colors using 8-bit RGB&#10;values&#10;    "><menuentrytitle>
      plscmap1: Set color map1 colors using 8-bit RGB
values
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plscmap1l; Set color map1 colors using a&#10;piece-wise linear relationship&#10;    "><menuentrytitle>
      plscmap1l: Set color map1 colors using a
piece-wise linear relationship
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plscmap1n; Set number of colors in color map1&#10;    "><menuentrytitle>
      plscmap1n: Set number of colors in color map1
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plscol0;  Set a given color from color map0 by 8&#10;bit RGB value&#10;    "><menuentrytitle>
      plscol0:  Set a given color from color map0 by 8
bit RGB value
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plscolbg; Set the background color&#10;by 8-bit RGB value&#10;    "><menuentrytitle>
      plscolbg: Set the background color
by 8-bit RGB value
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plscolor; Used to globally turn color output on/off&#10;    "><menuentrytitle>
      plscolor: Used to globally turn color output on/off
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plscompression; Set device-compression level&#10;    "><menuentrytitle>
      plscompression: Set device-compression level
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsdev; Set the device [keyword] name&#10;    "><menuentrytitle>
      plsdev: Set the device (keyword) name
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsdidev; Set parameters that define current&#10;      device-space window&#10;    "><menuentrytitle>
      plsdidev: Set parameters that define current
      device-space window
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsdimap; Set up transformation from metafile&#10;coordinates&#10;    "><menuentrytitle>
      plsdimap: Set up transformation from metafile
coordinates
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsdiori; Set plot orientation&#10;    "><menuentrytitle>
      plsdiori: Set plot orientation
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsdiplt; Set parameters that define current&#10;      plot-space window&#10;    "><menuentrytitle>
      plsdiplt: Set parameters that define current
      plot-space window
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsdiplz; Set parameters incrementally [zoom mode]&#10;      that define current plot-space window&#10;    "><menuentrytitle>
      plsdiplz: Set parameters incrementally (zoom mode)
      that define current plot-space window
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsesc; Set the escape character for text strings&#10;    "><menuentrytitle>
      plsesc: Set the escape character for text strings
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsetopt; Set any command-line option&#10;    "><menuentrytitle>
      plsetopt: Set any command-line option
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsfam; Set family file parameters&#10;    "><menuentrytitle>
      plsfam: Set family file parameters
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsfci; Set FCI [font characterization integer]&#10;    "><menuentrytitle>
      plsfci: Set FCI (font characterization integer)
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsfnam; Set output file name&#10;    "><menuentrytitle>
      plsfnam: Set output file name
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plshades; Shade regions on the basis of value&#10;    "><menuentrytitle>
      plshades: Shade regions on the basis of value
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plshade;  Shade individual region on the basis of value&#10;    "><menuentrytitle>
      plshade:  Shade individual region on the basis of value
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plshade1; Shade individual region on the basis of value&#10;    "><menuentrytitle>
      plshade1: Shade individual region on the basis of value
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsmaj; Set length of major ticks&#10;    "><menuentrytitle>
      plsmaj: Set length of major ticks
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsmem; Set the memory area to be plotted&#10;    "><menuentrytitle>
      plsmem: Set the memory area to be plotted
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsmin; Set length of minor ticks&#10;    "><menuentrytitle>
      plsmin: Set length of minor ticks
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsori; Set orientation&#10;    "><menuentrytitle>
      plsori: Set orientation
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plspage; Set page parameters&#10;    "><menuentrytitle>
      plspage: Set page parameters
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plspause; Set the pause [on end-of-page] status&#10;    "><menuentrytitle>
      plspause: Set the pause (on end-of-page) status
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsstrm; Set current output stream&#10;    "><menuentrytitle>
      plsstrm: Set current output stream
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plssub; Set the number of subpages in x and y&#10;    "><menuentrytitle>
      plssub: Set the number of subpages in x and y
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plssym; Set symbol size&#10;    "><menuentrytitle>
      plssym: Set symbol size
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plstar; Initialization&#10;    "><menuentrytitle>
      plstar: Initialization
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plstart; Initialization&#10;    "><menuentrytitle>
      plstart: Initialization
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plstripa; Add a point to a stripchart&#10;    "><menuentrytitle>
      plstripa: Add a point to a stripchart
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plstripc; Create a 4-pen stripchart&#10;    "><menuentrytitle>
      plstripc: Create a 4-pen stripchart
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plstripd; Deletes and releases memory used by a&#10;stripchart&#10;    "><menuentrytitle>
      plstripd: Deletes and releases memory used by a
stripchart
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plstyl; Set line style&#10;    "><menuentrytitle>
      plstyl: Set line style
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsurf3d; Plot shaded 3-d surface plot&#10;    "><menuentrytitle>
      plsurf3d: Plot shaded 3-d surface plot
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsvect; Set arrow style for vector plots&#10;    "><menuentrytitle>
      plsvect: Set arrow style for vector plots
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsvpa; Specify viewport in absolute coordinates&#10;    "><menuentrytitle>
      plsvpa: Specify viewport in absolute coordinates
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsxax; Set x axis parameters&#10;    "><menuentrytitle>
      plsxax: Set x axis parameters
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsyax; Set y axis parameters&#10;    "><menuentrytitle>
      plsyax: Set y axis parameters
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsym; Plots a symbol at the specified points&#10;    "><menuentrytitle>
      plsym: Plots a symbol at the specified points
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plszax; Set z axis parameters&#10;    "><menuentrytitle>
      plszax: Set z axis parameters
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      pltext; Switch to text screen&#10;    "><menuentrytitle>
      pltext: Switch to text screen
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plvasp; Specify viewport using aspect ratio only&#10;    "><menuentrytitle>
      plvasp: Specify viewport using aspect ratio only
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plvect; Vector plot&#10;    "><menuentrytitle>
      plvect: Vector plot
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plvpas; Specify viewport using coordinates and aspect ratio&#10;    "><menuentrytitle>
      plvpas: Specify viewport using coordinates and aspect ratio
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plvpor; Specify viewport using coordinates&#10;    "><menuentrytitle>
      plvpor: Specify viewport using coordinates
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plvsta; Select standard viewport&#10;    "><menuentrytitle>
      plvsta: Select standard viewport
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plw3d; Set up window for 3-d plotting&#10;    "><menuentrytitle>
      plw3d: Set up window for 3-d plotting
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plwid; Set pen width&#10;    "><menuentrytitle>
      plwid: Set pen width
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plwind; Specify world coordinates of viewport boundaries&#10;    "><menuentrytitle>
      plwind: Specify world coordinates of viewport boundaries
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plxormod; Enter or leave xor mode&#10;    "><menuentrytitle>
      plxormod: Enter or leave xor mode
    </menuentrytitle><menuentrydescrip/></menuentry></menu><node name="pl_setcontlabelformat; Set&#10;format of numerical label for contours" next="pl_setcontlabelparam; Set parameters of&#10;contour labelling other than format of numerical label" up="The Common API for PLplot"/><section>pl_setcontlabelformat: Set
format of numerical label for contours</section><para>
      <quotation><para><t>
	  <b>pl_setcontlabelformat</b>
	(<i>lexp</i>, <i>sigdig</i>);</t></para></quotation>
    </para><para>
     Set format of numerical label for contours.
    </para><varlist><varlistentry><term>
	  <code>lexp</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	  If the contour numerical label is greater than 10^(lexp) or less
	  than 10^(-lexp), then the
	  exponential format is used.  Default value of lexp is 4.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>sigdig</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	  Number of significant digits.  Default value is 2.
	  </para></listitem></varlistentry></varlist><node name="pl_setcontlabelparam; Set parameters of&#10;contour labelling other than format of numerical label" previous="pl_setcontlabelformat; Set&#10;format of numerical label for contours" next="pladv; Advance the [sub-]page" up="The Common API for PLplot"/><section>pl_setcontlabelparam: Set parameters of
contour labelling other than format of numerical label</section><para>
      <quotation><para><t>
	  <b>pl_setcontlabelparam</b>
	(<i>offset</i>, <i>size</i>, <i>spacing</i>, <i>active</i>);</t></para></quotation>
    </para><para>
    Set parameters of
    contour labelling other than those handled by <code>pl_setcontlabelformat</code> (<pxref node="pl_setcontlabelformat; Set&#10;format of numerical label for contours" file=""/>).
    </para><varlist><varlistentry><term>
	  <code>offset</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	   Offset of label from contour line (if set to 0.0, labels are
	   printed on the lines).  Default value is 0.006.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>size</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	  Font height for contour labels (normalized).  Default value is 0.3.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>spacing</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	  Spacing parameter for contour labels.  Default value is 0.1.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>active</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	  Activate labels.  Set to 1 if you want contour labels on.
	  Default is off (0).
	  </para></listitem></varlistentry></varlist><node name="pladv; Advance the [sub-]page" previous="pl_setcontlabelparam; Set parameters of&#10;contour labelling other than format of numerical label" next="&#10;      plaxes; Draw a box with axes; etc_ with arbitrary&#10;origin&#10;    " up="The Common API for PLplot"/><section>pladv: Advance the (sub-)page</section><para>
      <quotation><para><t>
	  <b>pladv</b>
	(<i>sub</i>);</t></para></quotation>
    </para><para>
      Advances to the next subpage if
      <samp><code>sub</code>=0</samp>, performing a page
      advance if there are no remaining subpages on the current page.  If
      subpages aren't being used, <samp><code>pladv</code> (<pxref node="pladv; Advance the [sub-]page" file=""/>)(0)</samp> will
      always advance the page.  If
      <samp><code>sub</code>&gt;0</samp>, PLplot switches
      to the specified subpage.  Note that this allows you to overwrite a
      plot on the specified subpage; if this is not what you intended, use
      <code>pleop</code> (<pxref node="&#10;      pleop; Eject current page&#10;    " file=""/>) followed by <code>plbop</code> (<pxref node="plbop; Begin a new page" file=""/>) to first advance the page.  This routine
      is called automatically (with
      <samp><code>sub</code>=0</samp>) by <code>plenv</code> (<pxref node="&#10;      plenv; Set up standard window and draw box&#10;    " file=""/>), but if
      <code>plenv</code> (<pxref node="&#10;      plenv; Set up standard window and draw box&#10;    " file=""/>) is not used, <code>pladv</code> (<pxref node="pladv; Advance the [sub-]page" file=""/>) must be called after initializing PLplot
      but before defining the viewport.
    </para><varlist><varlistentry><term>
	  <code>sub</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Specifies the subpage number (starting from 1 in the top left
	    corner and increasing along the rows) to which to advance.  Set
	    to zero to advance to the next subpage.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plaxes; Draw a box with axes; etc_ with arbitrary&#10;origin&#10;    " previous="pladv; Advance the [sub-]page" next="&#10;      plbin; Plot a histogram from binned data&#10;    " up="The Common API for PLplot"/><section>
      plaxes: Draw a box with axes, etc. with arbitrary
origin
    </section><para>
      <quotation><para><t>
           <b>plaxes</b>
        (<i>x0</i>, <i>y0</i>, <i>xopt</i>, <i>xtick</i>, <i>nxsub</i>, <i>yopt</i>, <i>ytick</i>, <i>nysub</i>);</t></para></quotation>
    </para><para>
      Draws a box around the currently defined viewport with arbitrary
      world-coordinate origin specified by
      <samp><code>x0</code></samp> and
      <samp><code>y0</code></samp>
      and labels it with world coordinate values appropriate to the
      window.  Thus <code>plaxes</code> (<pxref node="&#10;      plaxes; Draw a box with axes; etc_ with arbitrary&#10;origin&#10;    " file=""/>) should only be called after defining both
      viewport and window.  The character strings
      <samp><code>xopt</code></samp> and
      <samp><code>yopt</code></samp> specify how the box
      should be drawn as described below.  If ticks and/or subticks are to
      be drawn for a particular axis, the tick intervals and number of
      subintervals may be specified explicitly, or they may be defaulted by
      setting the appropriate arguments to zero. </para><varlist><varlistentry><term>
	  <code>x0</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            World X coordinate of origin.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>y0</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            World Y coordinate of origin.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xopt</code>
	  (<samp>const char *</samp>, input)
	</term><listitem><para>
	    Pointer to character string specifying options for horizontal
	    axis.  The string can include any combination of the following
	    letters (upper or lower case) in any order:
	    <itemize markchar="•"><listitem><para>
		  <samp>a</samp>: Draws axis, X-axis is horizontal
		  line (<samp>y=0</samp>), and Y-axis is vertical
		  line (<samp>x=0</samp>).
		</para></listitem><listitem><para>
		  <samp>b</samp>: Draws bottom (X) or left (Y) edge
		  of frame.
		</para></listitem><listitem><para>
		  <samp>c</samp>: Draws top (X) or right (Y) edge of
		  frame.
		</para></listitem><listitem><para>
		  <samp>f</samp>:  Always use fixed point numeric labels.
		</para></listitem><listitem><para>
		  <samp>g</samp>: Draws a grid at the major tick
		  interval.
		</para></listitem><listitem><para>
		  <samp>h</samp>: Draws a grid at the minor tick
		  interval.
		</para></listitem><listitem><para>
		  <samp>i</samp>: Inverts tick marks, so they are
		  drawn outwards, rather than inwards.
		</para></listitem><listitem><para>
		  <samp>l</samp>: Labels axis logarithmically.  This
		  only affects the labels, not the data, and so it is
		  necessary to compute the logarithms of data points before
		  passing them to any of the drawing routines.
		</para></listitem><listitem><para>
		  <samp>m</samp>: Writes numeric labels at major tick
		  intervals in the unconventional location (above box for
		  X, right of box for Y).
		</para></listitem><listitem><para>
		  <samp>n</samp>: Writes numeric labels at major tick
		  intervals in the conventional location (below box for X,
		  left of box for Y).
		</para></listitem><listitem><para>
		  <samp>s</samp>: Enables subticks between major
		  ticks, only valid if <samp>t</samp> is also
		  specified.
		</para></listitem><listitem><para>
		  <samp>t</samp>: Draws major ticks.
		</para></listitem></itemize>
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xtick</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    World coordinate interval between major ticks on the x axis.
	    If it is set to zero, PLplot automatically generates a suitable
	    tick interval.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nxsub</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of subintervals between major x axis ticks for minor
	    ticks.  If it is set to zero, PLplot automatically generates a
	    suitable minor tick interval.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>yopt</code>
	  (<samp>const char *</samp>, input)
	</term><listitem><para>
	    Pointer to character string specifying options for vertical
	    axis.  The string can include any combination of the letters
	    defined above for
	    <samp><code>xopt</code></samp>, and in addition
	    may contain:
	    <itemize markchar="•"><listitem><para>
		  <samp>v</samp>: Write numeric labels for vertical
		  axis parallel to the base of the graph, rather than
		  parallel to the axis.
		</para></listitem></itemize>
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ytick</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    World coordinate interval between major ticks on the y axis.
	    If it is set to zero, PLplot automatically generates a suitable
	    tick interval.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nysub</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of subintervals between major y axis ticks for minor
	    ticks.  If it is set to zero, PLplot automatically generates a
	    suitable minor tick interval.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plbin; Plot a histogram from binned data&#10;    " previous="&#10;      plaxes; Draw a box with axes; etc_ with arbitrary&#10;origin&#10;    " next="plbop; Begin a new page" up="The Common API for PLplot"/><section>
      plbin: Plot a histogram from binned data
    </section><para>
      <quotation><para><t>
           <b>plbin</b>
        (<i>nbin</i>, <i>x</i>, <i>y</i>, <i>center</i>);</t></para></quotation>
    </para><para>
      Plots a histogram consisting of
      <samp><code>nbin</code></samp> bins.  The value
      associated with the <samp>i</samp>'th bin is placed in
      <samp><code>x</code>[i]</samp>, and the number of
      points in the bin is placed in
      <samp><code>y</code>[i]</samp>.  For proper
      operation, the values in
      <samp><code>x</code>[i]</samp> must form a strictly
      increasing sequence.  If
      <samp><code>center</code>=0</samp>,
      <samp><code>x</code>[i]</samp> is the left-hand edge
      of the <samp>i</samp>'th bin, and if
      <samp><code>center</code>=1</samp>, the bin
      boundaries are placed midway between the values in the
      <samp><code>x</code></samp> array.  Also see <code>plhist</code> (<pxref node="&#10;      plhist; Plot a histogram from unbinned data&#10;    " file=""/>)
      for drawing histograms from unbinned data.
    </para><varlist><varlistentry><term>
	  <code>nbin</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of bins (i.e., number of values in
	    <samp><code>x</code></samp> and
	    <samp><code>y</code></samp> arrays.)
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>x</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array containing values associated with bins.  These
	    must form a strictly increasing sequence.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>y</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array containing number of points in bin.  This is a
	    <samp>PLFLT</samp> (instead of <samp>PLINT</samp>)
	    array so as to allow histograms of probabilities, etc.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>center</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Indicates whether the values in
	    <samp><code>x</code></samp> represent the lower
	    bin boundaries
	    (<samp><code>center</code>=0</samp>) or whether
	    the bin boundaries are to be midway between the
	    <samp><code>x</code></samp> values
	    (<samp><code>center</code>=1</samp>).  If the
	    values in <samp><code>x</code></samp> are
	    equally spaced and
	    <samp><code>center</code>=1</samp>, the values
	    in <samp><code>x</code></samp> are the center
	    values of the bins.
	  </para></listitem></varlistentry></varlist><node name="plbop; Begin a new page" previous="&#10;      plbin; Plot a histogram from binned data&#10;    " next="plbox; Draw a box with axes; etc" up="The Common API for PLplot"/><section>plbop: Begin a new page</section><para>
      <quotation><para><t>
	  <b>plbop</b>
	();</t></para></quotation>
    </para><para>
      Begins a new page.  For a file driver, the output file is opened if
      necessary.  Advancing the page via <code>pleop</code> (<pxref node="&#10;      pleop; Eject current page&#10;    " file=""/>) and <code>plbop</code> (<pxref node="plbop; Begin a new page" file=""/>) is useful when
      a page break is desired at a particular point when plotting to
      subpages.  Another use for <code>pleop</code> (<pxref node="&#10;      pleop; Eject current page&#10;    " file=""/>) and <code>plbop</code> (<pxref node="plbop; Begin a new page" file=""/>) is when plotting pages
      to different files, since you can manually set the file name
      by calling <code>plsfnam</code> (<pxref node="&#10;      plsfnam; Set output file name&#10;    " file=""/>) after the call to <code>pleop</code> (<pxref node="&#10;      pleop; Eject current page&#10;    " file=""/>).
      (In fact some drivers may only support a single page per file, making
      this a necessity.)  One way to handle this case automatically is to
      page advance via <code>pladv</code> (<pxref node="pladv; Advance the [sub-]page" file=""/>), but enable familying (see <code>plsfam</code> (<pxref node="&#10;      plsfam; Set family file parameters&#10;    " file=""/>)) with a
      small limit on the file size so that a new family member file will be
      created on each page break.
    </para><node name="plbox; Draw a box with axes; etc" previous="plbop; Begin a new page" next="&#10;      plbox3; Draw a box with axes; etc; in 3-d&#10;    " up="The Common API for PLplot"/><section>plbox: Draw a box with axes, etc</section><para>
      <quotation><para><t>
	  <b>plbox</b>
	(<i>xopt</i>, <i>xtick</i>, <i>nxsub</i>, <i>yopt</i>, <i>ytick</i>, <i>nysub</i>);</t></para></quotation>
    </para><para>
      Draws a box around the currently defined viewport, and labels it with
      world coordinate values appropriate to the window.  Thus <code>plbox</code> (<pxref node="plbox; Draw a box with axes; etc" file=""/>)
      should only be called after defining both viewport and window.  The
      character strings <samp><code>xopt</code></samp> and
      <samp><code>yopt</code></samp> specify how the box
      should be drawn as described below.  If ticks and/or subticks are to
      be drawn for a particular axis, the tick intervals and number of
      subintervals may be specified explicitly, or they may be defaulted by
      setting the appropriate arguments to zero.
    </para><varlist><varlistentry><term>
	  <code>xopt</code>
	  (<samp>const char *</samp>, input)
	</term><listitem><para>
	    Pointer to character string specifying options for horizontal
	    axis.  The string can include any combination of the following
	    letters (upper or lower case) in any order:
	    <itemize markchar="•"><listitem><para>
		  <samp>a</samp>: Draws axis, X-axis is horizontal
		  line (<samp>y=0</samp>), and Y-axis is vertical
		  line (<samp>x=0</samp>).
		</para></listitem><listitem><para>
		  <samp>b</samp>: Draws bottom (X) or left (Y) edge
		  of frame.
		</para></listitem><listitem><para>
		  <samp>c</samp>: Draws top (X) or right (Y) edge of
		  frame.
		</para></listitem><listitem><para>
		  <samp>f</samp>:  Always use fixed point numeric labels.
		</para></listitem><listitem><para>
		  <samp>g</samp>: Draws a grid at the major tick
		  interval.
		</para></listitem><listitem><para>
		  <samp>h</samp>: Draws a grid at the minor tick
		  interval.
		</para></listitem><listitem><para>
		  <samp>i</samp>: Inverts tick marks, so they are
		  drawn outwards, rather than inwards.
		</para></listitem><listitem><para>
		  <samp>l</samp>: Labels axis logarithmically.  This
		  only affects the labels, not the data, and so it is
		  necessary to compute the logarithms of data points before
		  passing them to any of the drawing routines.
		</para></listitem><listitem><para>
		  <samp>m</samp>: Writes numeric labels at major tick
		  intervals in the unconventional location (above box for
		  X, right of box for Y).
		</para></listitem><listitem><para>
		  <samp>n</samp>: Writes numeric labels at major tick
		  intervals in the conventional location (below box for X,
		  left of box for Y).
		</para></listitem><listitem><para>
		  <samp>s</samp>: Enables subticks between major
		  ticks, only valid if <samp>t</samp> is also
		  specified.
		</para></listitem><listitem><para>
		  <samp>t</samp>: Draws major ticks.
		</para></listitem></itemize>
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xtick</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    World coordinate interval between major ticks on the x axis.
	    If it is set to zero, PLplot automatically generates a suitable
	    tick interval.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nxsub</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of subintervals between major x axis ticks for minor
	    ticks.  If it is set to zero, PLplot automatically generates a
	    suitable minor tick interval.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>yopt</code>
	  (<samp>const char *</samp>, input)
	</term><listitem><para>
	    Pointer to character string specifying options for vertical
	    axis.  The string can include any combination of the letters
	    defined above for
	    <samp><code>xopt</code></samp>, and in addition
	    may contain:
	    <itemize markchar="•"><listitem><para>
		  <samp>v</samp>: Write numeric labels for vertical
		  axis parallel to the base of the graph, rather than
		  parallel to the axis.
		</para></listitem></itemize>
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ytick</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    World coordinate interval between major ticks on the y axis.
	    If it is set to zero, PLplot automatically generates a suitable
	    tick interval.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nysub</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of subintervals between major y axis ticks for minor
	    ticks.  If it is set to zero, PLplot automatically generates a
	    suitable minor tick interval.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plbox3; Draw a box with axes; etc; in 3-d&#10;    " previous="plbox; Draw a box with axes; etc" next="&#10;      plcalc_world; Calculate world coordinates and&#10;corresponding window index from relative device coordinates&#10;    " up="The Common API for PLplot"/><section>
      plbox3: Draw a box with axes, etc, in 3-d
    </section><para>
      <quotation><para><t>
	  <b>plbox3</b>
	(<i>xopt</i>, <i>xlabel</i>, <i>xtick</i>, <i>nxsub</i>, <i>yopt</i>, <i>ylabel</i>, <i>ytick</i>, <i>nysub</i>, <i>zopt</i>, <i>zlabel</i>, <i>ztick</i>, <i>nzsub</i>);</t></para></quotation>
    </para><para>
      Draws axes, numeric and text labels for a three-dimensional surface
      plot.  For a more complete description of three-dimensional plotting
      see <ref node="Three Dimensional Surface Plots" file="">Three Dimensional Surface Plots</ref>.
    </para><varlist><varlistentry><term>
	  <code>xopt</code>
	  (<samp>const char *</samp>, input)
	</term><listitem><para>
	    Pointer to character string specifying options for the x axis.
	    The string can include any combination of the following letters
	    (upper or lower case) in any order:
	    <itemize markchar="•"><listitem><para>
		  <samp>b</samp>: Draws axis at base, at height
		  <samp>z=<code>zmin</code></samp> where
		  <samp><code>zmin</code></samp> is defined
		  by call to <code>plw3d</code> (<pxref node="&#10;      plw3d; Set up window for 3-d plotting&#10;    " file=""/>).  This character must be specified in
		  order to use any of the other options.
		</para></listitem><listitem><para>
		  <samp>f</samp>: Always use fixed point numeric labels.
		</para></listitem><listitem><para>
		  <samp>i</samp>: Inverts tick marks, so they are
		  drawn downwards, rather than upwards.
		</para></listitem><listitem><para>
		  <samp>l</samp>: Labels axis logarithmically.  This
		  only affects the labels, not the data, and so it is
		  necessary to compute the logarithms of data points before
		  passing them to any of the drawing routines.
		</para></listitem><listitem><para>
		  <samp>n</samp>: Writes numeric labels at major tick
		  intervals.
		</para></listitem><listitem><para>
		  <samp>s</samp>: Enables subticks between major
		  ticks, only valid if <samp>t</samp> is also
		  specified.
		</para></listitem><listitem><para>
		  <samp>t</samp>: Draws major ticks.
		</para></listitem><listitem><para>
		  <samp>u</samp>: If this is specified, the text
		  label for the axis is written under the axis.
		</para></listitem></itemize>
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xlabel</code>
	  (<samp>const char *</samp>, input)
	</term><listitem><para>
	    Pointer to character string specifying text label for the x
	    axis.  It is only drawn if <samp>u</samp> is in the
	    <samp><code>xopt</code></samp> string.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xtick</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    World coordinate interval between major ticks on the x axis.
	    If it is set to zero, PLplot automatically generates a suitable
	    tick interval.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nxsub</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of subintervals between major x axis ticks for minor
	    ticks.  If it is set to zero, PLplot automatically generates a
	    suitable minor tick interval.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>yopt</code>
	  (<samp>const char *</samp>, input)
	</term><listitem><para>
	    Pointer to character string specifying options for the y axis.
	    The string is interpreted in the same way as
	    <samp><code>xopt</code></samp>.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ylabel</code>
	  (<samp>const char *</samp>, input)
	</term><listitem><para>
	    Pointer to character string specifying text label for the y
	    axis.  It is only drawn if <samp>u</samp> is in the
	    <samp><code>yopt</code></samp> string.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ytick</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    World coordinate interval between major ticks on the y axis.
	    If it is set to zero, PLplot automatically generates a suitable
	    tick interval.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nysub</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of subintervals between major y axis ticks for minor
	    ticks.  If it is set to zero, PLplot automatically generates a
	    suitable minor tick interval.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>zopt</code>
	  (<samp>const char *</samp>, input)
	</term><listitem><para>
	    Pointer to character string specifying options for the z axis.
	    The string can include any combination of the following letters
	    (upper or lower case) in any order:
	    <itemize markchar="•"><listitem><para>
		  <samp>b</samp>: Draws z axis to the left of the
		  surface plot.
		</para></listitem><listitem><para>
		  <samp>c</samp>: Draws z axis to the right of the
		  surface plot.
		</para></listitem><listitem><para>
		  <samp>d</samp>: Draws grid lines parallel to the
		  x-y plane behind the figure.  These lines are not drawn
		  until after <code>plot3d</code> (<pxref node="&#10;      plot3d; Plot 3-d surface plot&#10;    " file=""/>) or <code>plmesh</code> (<pxref node="&#10;      plmesh; Plot surface mesh&#10;    " file=""/>) are called because of
		  the need for hidden line removal.
		</para></listitem><listitem><para>
		  <samp>f</samp>: Always use fixed point numeric labels.
		</para></listitem><listitem><para>
		  <samp>i</samp>: Inverts tick marks, so they are
		  drawn away from the center.
		</para></listitem><listitem><para>
		  <samp>l</samp>: Labels axis logarithmically.  This
		  only affects the labels, not the data, and so it is
		  necessary to compute the logarithms of data points before
		  passing them to any of the drawing routines.
		</para></listitem><listitem><para>
		  <samp>m</samp>: Writes numeric labels at major tick
		  intervals on the right-hand vertical axis.
		</para></listitem><listitem><para>
		  <samp>n</samp>: Writes numeric labels at major tick
		  intervals on the left-hand vertical axis.
		</para></listitem><listitem><para>
		  <samp>s</samp>: Enables subticks between major
		  ticks, only valid if <samp>t</samp> is also
		  specified.
		</para></listitem><listitem><para>
		  <samp>t</samp>: Draws major ticks.
		</para></listitem><listitem><para>
		  <samp>u</samp>: If this is specified, the text
		  label is written beside the left-hand axis.
		</para></listitem><listitem><para>
		  <samp>v</samp>: If this is specified, the text
		  label is written beside the right-hand axis.
		</para></listitem></itemize>
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>zlabel</code>
	  (<samp>const char *</samp>, input)
	</term><listitem><para>
	    Pointer to character string specifying text label for the z
	    axis.  It is only drawn if <samp>u</samp> or
	    <samp>v</samp> are in the
	    <samp><code>zopt</code></samp> string.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ztick</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    World coordinate interval between major ticks on the z axis.
	    If it is set to zero, PLplot automatically generates a suitable
	    tick interval.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nzsub</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of subintervals between major z axis ticks for minor
	    ticks.  If it is set to zero, PLplot automatically generates a
	    suitable minor tick interval.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plcalc_world; Calculate world coordinates and&#10;corresponding window index from relative device coordinates&#10;    " previous="&#10;      plbox3; Draw a box with axes; etc; in 3-d&#10;    " next="&#10;      plclear; Clear current [sub]page&#10;    " up="The Common API for PLplot"/><section>
      plcalc_world: Calculate world coordinates and
corresponding window index from relative device coordinates
    </section><para>
      <quotation><para><t>
	  <b>plcalc_world</b>
	(<i>rx</i>, <i>ry</i>, <i>wx</i>, <i>wy</i>, <i>window</i>);</t></para></quotation>
    </para><para>
Calculate world coordinates,
<samp><code>wx</code></samp> and
<samp><code>wy</code></samp>, and corresponding
<samp><code>window</code></samp> index
from relative device coordinates,
<samp><code>rx</code></samp> and
<samp><code>ry</code></samp>.
    </para><varlist><varlistentry><term>
	  <code>rx</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    Input relative device coordinate (ranging from 0. to 1.) for the
	    x coordinate.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ry</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    Input relative device coordinate (ranging from 0. to 1.) for the
	    y coordinate.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>wx</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
	    Pointer to the returned world coordinate for x corresponding
	    to the relative device coordinates
	    <samp><code>rx</code></samp> and
	    <samp><code>ry</code></samp>.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>wy</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
	    Pointer to the returned world coordinate for y corresponding
	    to the relative device coordinates
	    <samp><code>rx</code></samp> and
	    <samp><code>ry</code></samp>.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>window</code>
	  (<samp>PLINT *</samp>, output)
	</term><listitem><para>
	    Pointer to the returned last defined window index that corresponds to the
	    input relative device coordinates (and the returned world
	    coordinates).  To give some background on the window index,
	    for each page the initial window index is set to
	    zero, and each time <code>plwind</code> (<pxref node="&#10;      plwind; Specify world coordinates of viewport boundaries&#10;    " file=""/>) is called within the page, world
	    and device coordinates are stored for the window and the window
	    index is incremented.  Thus, for a simple page layout with
	    non-overlapping viewports and one window per viewport,
	    <samp><code>window</code></samp> corresponds to
	    the viewport index (in the order which the viewport/windows
	    were created) of the only viewport/window corresponding to
	    <samp><code>rx</code></samp> and
	    <samp><code>ry</code></samp>.  However, for
	    more complicated layouts with potentially overlapping viewports
	    and possibly more than one window (set of world coordinates) per
	    viewport, <samp><code>window</code></samp>
	    and the corresponding output world coordinates
	    corresponds to the last window created that fulfils the criterion
	    that the relative device coordinates are inside it.  Finally, in
	    all cases where the input relative device coordinates are not
	    inside any viewport/window, then
	    <samp><code>window</code></samp> is set to -1.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plclear; Clear current [sub]page&#10;    " previous="&#10;      plcalc_world; Calculate world coordinates and&#10;corresponding window index from relative device coordinates&#10;    " next="&#10;      plcol0; Set color; map0&#10;    " up="The Common API for PLplot"/><section>
      plclear: Clear current (sub)page
    </section><para>
      <quotation><para><t>
	  <b>plclear</b>
	();</t></para></quotation>
    </para><para>
      Clears the current page, effectively erasing everything that have
      been drawn.  This command only works with interactive drivers; if the driver
      does not support this, the page is filled with the background color in use.
      If the current page is divided into subpages, only the current subpage
      is erased.  The nth subpage can be selected with <code>pladv</code> (<pxref node="pladv; Advance the [sub-]page" file=""/>)(n).
    </para><node name="&#10;      plcol0; Set color; map0&#10;    " previous="&#10;      plclear; Clear current [sub]page&#10;    " next="&#10;      plcol1; Set color; map1&#10;    " up="The Common API for PLplot"/><section>
      plcol0: Set color, map0
    </section><para>
      <quotation><para><t>
	  <b>plcol0</b>
	(<i>color</i>);</t></para></quotation>
    </para><para>
      Sets the color for color map0 (see <ref node="Color Map0" file="">Color Map0</ref>).
    </para><varlist><varlistentry><term>
	  <code>color</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Integer representing the color.  The defaults at present are
	    (these may change):
	    <multitable cols="2"><tbody><row><entry> 0 <entry>black (default background)</entry></entry></row><row><entry> 1 <entry>red (default foreground)</entry></entry></row><row><entry> 2 <entry>yellow</entry></entry></row><row><entry> 3 <entry>green</entry></entry></row><row><entry> 4 <entry>aquamarine</entry></entry></row><row><entry> 5 <entry>pink</entry></entry></row><row><entry> 6 <entry>wheat</entry></entry></row><row><entry> 7 <entry>grey</entry></entry></row><row><entry> 8 <entry>brown</entry></entry></row><row><entry> 9 <entry>blue</entry></entry></row><row><entry>10 <entry>BlueViolet</entry></entry></row><row><entry>11 <entry>cyan</entry></entry></row><row><entry>12 <entry>turquoise</entry></entry></row><row><entry>13 <entry>magenta</entry></entry></row><row><entry>14 <entry>salmon</entry></entry></row><row><entry>15 <entry>white</entry></entry></row></tbody></multitable>
	    Use <code>plscmap0</code> (<pxref node="&#10;      plscmap0; Set color map0 colors by 8-bit RGB&#10;values&#10;    " file=""/>) to change the entire map0 color palette and
	    <code>plscol0</code> (<pxref node="&#10;      plscol0;  Set a given color from color map0 by 8&#10;bit RGB value&#10;    " file=""/>) to change an individual color in the map0 color
	    palette.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plcol1; Set color; map1&#10;    " previous="&#10;      plcol0; Set color; map0&#10;    " next="&#10;      plcont; Contour plot&#10;    " up="The Common API for PLplot"/><section>
      plcol1: Set color, map1
    </section><para>
      <quotation><para><t>
           <b>plcol1</b>
        (<i>col1</i>);</t></para></quotation>
    </para><para> Sets the color for color map1 (see <ref node="Color Map1" file="">Color Map1</ref>).  </para><varlist><varlistentry><term>
	  <code>col1</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            This value must be in the range from 0. to 1. and is mapped to
	    color using the continuous map1 color palette which by default
	    ranges from blue to the background color to red.  The map1
	    palette can also be straightforwardly changed by the user with
	    <code>plscmap1</code> (<pxref node="&#10;      plscmap1; Set color map1 colors using 8-bit RGB&#10;values&#10;    " file=""/>) or <code>plscmap1l</code> (<pxref node="&#10;      plscmap1l; Set color map1 colors using a&#10;piece-wise linear relationship&#10;    " file=""/>).
	  </para></listitem></varlistentry></varlist><node name="&#10;      plcont; Contour plot&#10;    " previous="&#10;      plcol1; Set color; map1&#10;    " next="&#10;      plcpstrm; Copy state parameters from the&#10;reference stream to the current stream&#10;    " up="The Common API for PLplot"/><section>
      plcont: Contour plot
    </section><para>
      <quotation><para><t>
	  <b>plcont</b>
	(<i>z</i>, <i>nx</i>, <i>ny</i>, <i>kx</i>, <i>lx</i>, <i>ky</i>, <i>ly</i>, <i>clevel</i>, <i>nlevel</i>, <i>pltr</i>, <i>pltr_data</i>);</t></para></quotation>
    </para><para>
      Draws a contour plot of the data in
      <samp><code>z</code>[<code>nx</code>][<code>ny</code>]</samp>,
      using the <samp><code>nlevel</code></samp> contour
      levels specified by <samp><code>clevel</code></samp>.
      Only the region of the array from
      <samp><code>kx</code></samp> to
      <samp><code>lx</code></samp> and from
      <samp><code>ky</code></samp> to
      <samp><code>ly</code></samp> is plotted out.  A
      transformation routine pointed to by <samp><code>pltr</code></samp>
      with a pointer <samp><code>pltr_data</code></samp>
      for additional data required by the transformation routine
      is used to map indices within the array
      to the world coordinates.  See the following discussion of the
      arguments and <ref node="Contour and Shade Plots" file="">Contour and Shade Plots</ref> for
      more information.
    </para><varlist><varlistentry><term>
	  <code>z</code>
	  (<samp>PLFLT **</samp>, input)
	</term><listitem><para>
	    Pointer to a vectored two-dimensional array containing data to
	    be contoured.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nx, ny</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Physical dimensions of array
	    <samp><code>z</code></samp>.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>kx, lx</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Range of <samp>x</samp> indices to consider.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ky, ly</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Range of <samp>y</samp> indices to consider.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>clevel</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array specifying levels at which to draw contours.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nlevel</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of contour levels to draw.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>pltr</code>
	  (<samp>void (*) (PLFLT, PLFLT, PLFLT *, PLFLT *, PLPointer)
           </samp>, input)
	</term><listitem><para>
	    Pointer to function that defines transformation between indices
	    in array <samp><code>z</code></samp> and the
	    world coordinates (C only).  Transformation functions are
	    provided in the PLplot library:
	    <code>pltr0</code> (<pxref node="&#10;      pltr0; Identity transformation for grid to world&#10;mapping&#10;    " file=""/>) for identity mapping, and <code>pltr1</code> (<pxref node="&#10;      pltr1; Linear interpolation for grid to world&#10;mapping using singly dimensioned coord arrays&#10;    " file=""/>) and <code>pltr2</code> (<pxref node="&#10;      pltr2; Linear interpolation for grid to world&#10;      mapping using doubly dimensioned coord arrays [column&#10;      dominant; as per normal C 2d arrays]&#10;    " file=""/>) for
	    arbitrary mappings respectively defined by one- and
	    two-dimensional arrays.  In addition, user-supplied routines
	    for the transformation can be used as well.  Examples of
	    all of these approaches are given in
	    <ref node="Contour Plots from C" file="">Contour Plots from C</ref>.
	    The transformation function should
	    have the form given by any of <code>pltr0</code> (<pxref node="&#10;      pltr0; Identity transformation for grid to world&#10;mapping&#10;    " file=""/>), <code>pltr1</code> (<pxref node="&#10;      pltr1; Linear interpolation for grid to world&#10;mapping using singly dimensioned coord arrays&#10;    " file=""/>), or <code>pltr2</code> (<pxref node="&#10;      pltr2; Linear interpolation for grid to world&#10;      mapping using doubly dimensioned coord arrays [column&#10;      dominant; as per normal C 2d arrays]&#10;    " file=""/>).
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>pltr_data</code>
	  (<samp>PLPointer</samp>, input)
	</term><listitem><para>
	    Extra parameter to help
	    pass information to <code>pltr0</code> (<pxref node="&#10;      pltr0; Identity transformation for grid to world&#10;mapping&#10;    " file=""/>), <code>pltr1</code> (<pxref node="&#10;      pltr1; Linear interpolation for grid to world&#10;mapping using singly dimensioned coord arrays&#10;    " file=""/>), <code>pltr2</code> (<pxref node="&#10;      pltr2; Linear interpolation for grid to world&#10;      mapping using doubly dimensioned coord arrays [column&#10;      dominant; as per normal C 2d arrays]&#10;    " file=""/>), or whatever routine
	    that is externally supplied.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plcpstrm; Copy state parameters from the&#10;reference stream to the current stream&#10;    " previous="&#10;      plcont; Contour plot&#10;    " next="&#10;      plend; End plotting session&#10;    " up="The Common API for PLplot"/><section>
      plcpstrm: Copy state parameters from the
reference stream to the current stream
    </section><para>
      <quotation><para><t>
           <b>plcpstrm</b>
        (<i>iplsr</i>, <i>flags</i>);</t></para></quotation>
    </para><para>
      Copies state parameters from the reference stream to the current stream.
      Tell driver interface to map device coordinates unless
<samp><code>flags</code> == 1</samp>.
    </para><para>
      This function is used for making save files of selected plots (e.g.
      from the TK driver).  After initializing, you can get a copy of the
      current plot to the specified device by switching to this stream and
      issuing a <code>plcpstrm</code> (<pxref node="&#10;      plcpstrm; Copy state parameters from the&#10;reference stream to the current stream&#10;    " file=""/>) and a <code>plreplot</code> (<pxref node="&#10;      plreplot; Replays contents of plot buffer to&#10;current device/file&#10;    " file=""/>), with calls to <code>plbop</code> (<pxref node="plbop; Begin a new page" file=""/>) and
      <code>pleop</code> (<pxref node="&#10;      pleop; Eject current page&#10;    " file=""/>) as appropriate.  The plot buffer must have previously been
      enabled (done automatically by some display drivers, such as X).
    </para><varlist><varlistentry><term>
	  <code>iplsr</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Number of reference stream.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>flags</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            If <samp><code>flags</code></samp> is set to 1
	    the device coordinates are <i>not</i> copied from the reference to current
	    stream.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plend; End plotting session&#10;    " previous="&#10;      plcpstrm; Copy state parameters from the&#10;reference stream to the current stream&#10;    " next="&#10;      plend1; End plotting session for current stream&#10;    " up="The Common API for PLplot"/><section>
      plend: End plotting session
    </section><para>
      <quotation><para><t>
	  <b>plend</b>
	();</t></para></quotation>
    </para><para>
      Ends a plotting session, tidies up all the output files, switches
      interactive devices back into text mode and frees up any memory that
      was allocated.  Must be called before end of program.
    </para><node name="&#10;      plend1; End plotting session for current stream&#10;    " previous="&#10;      plend; End plotting session&#10;    " next="&#10;      plenv0; Same as plenv but if in multiplot&#10;      mode does not advance the subpage; instead clears it_&#10;    " up="The Common API for PLplot"/><section>
      plend1: End plotting session for current stream
    </section><para>
      <quotation><para><t>
	  <b>plend1</b>
	();</t></para></quotation>
    </para><para>
      Ends a plotting session for the current output stream only.  See
      <code>plsstrm</code> (<pxref node="&#10;      plsstrm; Set current output stream&#10;    " file=""/>) for more info.
    </para><node name="&#10;      plenv0; Same as plenv but if in multiplot&#10;      mode does not advance the subpage; instead clears it_&#10;    " previous="&#10;      plend1; End plotting session for current stream&#10;    " next="&#10;      plenv; Set up standard window and draw box&#10;    " up="The Common API for PLplot"/><section>
      plenv0: Same as <code>plenv</code> but if in multiplot
      mode does not advance the subpage, instead clears it.
    </section><para>
      <quotation><para><t>
	  <b>plenv0</b>
	(<i>xmin</i>, <i>xmax</i>, <i>ymin</i>, <i>ymax</i>, <i>just</i>, <i>axis</i>);</t></para></quotation>
    </para><para>
      Sets up plotter environment for simple graphs by calling <code>pladv</code> (<pxref node="pladv; Advance the [sub-]page" file=""/>) and
      setting up viewport and window to sensible default values.  <code>plenv0</code> (<pxref node="&#10;      plenv0; Same as plenv but if in multiplot&#10;      mode does not advance the subpage; instead clears it_&#10;    " file=""/>)
      leaves enough room around most graphs for axis labels and a title.
      When these defaults are not suitable, use the individual routines
      <code>plvpas</code> (<pxref node="&#10;      plvpas; Specify viewport using coordinates and aspect ratio&#10;    " file=""/>), <code>plvpor</code> (<pxref node="&#10;      plvpor; Specify viewport using coordinates&#10;    " file=""/>), or <code>plvasp</code> (<pxref node="&#10;      plvasp; Specify viewport using aspect ratio only&#10;    " file=""/>) for setting up the viewport, <code>plwind</code> (<pxref node="&#10;      plwind; Specify world coordinates of viewport boundaries&#10;    " file=""/>)
      for defining the window, and <code>plbox</code> (<pxref node="plbox; Draw a box with axes; etc" file=""/>) for drawing the box.
    </para><varlist><varlistentry><term>
	  <code>xmin</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    Value of x at left-hand edge of window (in world coordinates).
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xmax</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    Value of x at right-hand edge of window (in world coordinates).
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ymin</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    Value of y at bottom edge of window (in world coordinates).
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ymax</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    Value of y at top edge of window (in world coordinates).
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>just</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
           Controls how the axes will be scaled:
        <itemize markchar="•"><listitem><para>
	    <samp>-1</samp>: the scales
            will not be set, the user must set up the scale before calling
            <code>plenv0</code> (<pxref node="&#10;      plenv0; Same as plenv but if in multiplot&#10;      mode does not advance the subpage; instead clears it_&#10;    " file=""/>) using <code>plsvpa</code> (<pxref node="&#10;      plsvpa; Specify viewport in absolute coordinates&#10;    " file=""/>), <code>plvasp</code> (<pxref node="&#10;      plvasp; Specify viewport using aspect ratio only&#10;    " file=""/>) or other.
         </para></listitem><listitem><para>
	    <samp>0</samp>: the x and
	    y axes are scaled independently to use as much of the screen as
	    possible.
         </para></listitem><listitem><para>
	    <samp>1</samp>: the scales of
	    the x and y axes are made equal.
	  </para></listitem><listitem><para>
	    <samp>2</samp>: the axis of
	    the x and y axes are made equal, and the plot box will be square.
	  </para></listitem></itemize>
        </para></listitem></varlistentry><varlistentry><term>
	  <code>axis</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Controls drawing of the box around the plot:
	    <itemize markchar="•"><listitem><para>
		  <samp>-2</samp>: draw no box, no tick marks, no
numeric tick labels, no axes.
		</para></listitem><listitem><para>
		  <samp>-1</samp>: draw box only.
		</para></listitem><listitem><para>
		  <samp>0</samp>: draw box, ticks, and numeric tick labels.
		</para></listitem><listitem><para>
		  <samp>1</samp>: also draw coordinate axes at
		  <samp>x=0</samp> and <samp>y=0</samp>.
		</para></listitem><listitem><para>
		  <samp>2</samp>: also draw a grid at major tick
positions in both coordinates.
		</para></listitem><listitem><para>
		  <samp>3</samp>: also draw a grid at minor tick
positions in both coordinates.
		</para></listitem><listitem><para>
		  <samp>10</samp>: same as 0 except logarithmic
		  <samp>x</samp> tick marks. (The <samp>x</samp>
		  data have to be converted to logarithms separately.)
		</para></listitem><listitem><para>
		  <samp>11</samp>: same as 1 except logarithmic
		  <samp>x</samp> tick marks. (The <samp>x</samp>
                  data have to be converted to logarithms separately.)
		</para></listitem><listitem><para>
		  <samp>12</samp>: same as 2 except logarithmic
		  <samp>x</samp> tick marks. (The <samp>x</samp>
                  data have to be converted to logarithms separately.)
		</para></listitem><listitem><para>
		  <samp>13</samp>: same as 3 except logarithmic
		  <samp>x</samp> tick marks. (The <samp>x</samp>
                  data have to be converted to logarithms separately.)
		</para></listitem><listitem><para>
		  <samp>20</samp>: same as 0 except logarithmic
		  <samp>y</samp> tick marks. (The <samp>y</samp>
		  data have to be converted to logarithms separately.)
		</para></listitem><listitem><para>
		  <samp>21</samp>: same as 1 except logarithmic
		  <samp>y</samp> tick marks. (The <samp>y</samp>
                  data have to be converted to logarithms separately.)
		</para></listitem><listitem><para>
		  <samp>22</samp>: same as 2 except logarithmic
		  <samp>y</samp> tick marks. (The <samp>y</samp>
                  data have to be converted to logarithms separately.)
		</para></listitem><listitem><para>
		  <samp>23</samp>: same as 3 except logarithmic
		  <samp>y</samp> tick marks. (The <samp>y</samp>
                  data have to be converted to logarithms separately.)
		</para></listitem><listitem><para>
		  <samp>30</samp>: same as 0 except logarithmic
		  <samp>x</samp> and <samp>y</samp> tick marks. (The <samp>x</samp> and <samp>y</samp>
		  data have to be converted to logarithms separately.)
		</para></listitem><listitem><para>
		  <samp>31</samp>: same as 1 except logarithmic
		  <samp>x</samp> and <samp>y</samp> tick marks. (The <samp>x</samp> and <samp>y</samp>
                  data have to be converted to logarithms separately.)
		</para></listitem><listitem><para>
		  <samp>32</samp>: same as 2 except logarithmic
		  <samp>x</samp> and <samp>y</samp> tick marks. (The <samp>x</samp> and <samp>y</samp>
                  data have to be converted to logarithms separately.)
		</para></listitem><listitem><para>
		  <samp>33</samp>: same as 3 except logarithmic
		  <samp>x</samp> and <samp>y</samp> tick marks. (The <samp>x</samp> and <samp>y</samp>
                  data have to be converted to logarithms separately.)
		</para></listitem></itemize>
	  </para></listitem></varlistentry></varlist><node name="&#10;      plenv; Set up standard window and draw box&#10;    " previous="&#10;      plenv0; Same as plenv but if in multiplot&#10;      mode does not advance the subpage; instead clears it_&#10;    " next="&#10;      pleop; Eject current page&#10;    " up="The Common API for PLplot"/><section>
      plenv: Set up standard window and draw box
    </section><para>
      <quotation><para><t>
	  <b>plenv</b>
	(<i>xmin</i>, <i>xmax</i>, <i>ymin</i>, <i>ymax</i>, <i>just</i>, <i>axis</i>);</t></para></quotation>
    </para><para>
      Sets up plotter environment for simple graphs by calling <code>pladv</code> (<pxref node="pladv; Advance the [sub-]page" file=""/>) and
      setting up viewport and window to sensible default values.  <code>plenv</code> (<pxref node="&#10;      plenv; Set up standard window and draw box&#10;    " file=""/>)
      leaves enough room around most graphs for axis labels and a title.
      When these defaults are not suitable, use the individual routines
      <code>plvpas</code> (<pxref node="&#10;      plvpas; Specify viewport using coordinates and aspect ratio&#10;    " file=""/>), <code>plvpor</code> (<pxref node="&#10;      plvpor; Specify viewport using coordinates&#10;    " file=""/>), or <code>plvasp</code> (<pxref node="&#10;      plvasp; Specify viewport using aspect ratio only&#10;    " file=""/>) for setting up the viewport, <code>plwind</code> (<pxref node="&#10;      plwind; Specify world coordinates of viewport boundaries&#10;    " file=""/>)
      for defining the window, and <code>plbox</code> (<pxref node="plbox; Draw a box with axes; etc" file=""/>) for drawing the box.
    </para><varlist><varlistentry><term>
	  <code>xmin</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    Value of x at left-hand edge of window (in world coordinates).
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xmax</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    Value of x at right-hand edge of window (in world coordinates).
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ymin</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    Value of y at bottom edge of window (in world coordinates).
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ymax</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    Value of y at top edge of window (in world coordinates).
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>just</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
           Controls how the axes will be scaled:
        <itemize markchar="•"><listitem><para>
	    <samp>-1</samp>: the scales
            will not be set, the user must set up the scale before calling
            <code>plenv</code> (<pxref node="&#10;      plenv; Set up standard window and draw box&#10;    " file=""/>) using <code>plsvpa</code> (<pxref node="&#10;      plsvpa; Specify viewport in absolute coordinates&#10;    " file=""/>), <code>plvasp</code> (<pxref node="&#10;      plvasp; Specify viewport using aspect ratio only&#10;    " file=""/>) or other.
         </para></listitem><listitem><para>
	    <samp>0</samp>: the x and
	    y axes are scaled independently to use as much of the screen as
	    possible.
         </para></listitem><listitem><para>
	    <samp>1</samp>: the scales of
	    the x and y axes are made equal.
	  </para></listitem><listitem><para>
	    <samp>2</samp>: the axis of
	    the x and y axes are made equal, and the plot box will be square.
	  </para></listitem></itemize>
        </para></listitem></varlistentry><varlistentry><term>
	  <code>axis</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Controls drawing of the box around the plot:
	    <itemize markchar="•"><listitem><para>
		  <samp>-2</samp>: draw no box, no tick marks, no
numeric tick labels, no axes.
		</para></listitem><listitem><para>
		  <samp>-1</samp>: draw box only.
		</para></listitem><listitem><para>
		  <samp>0</samp>: draw box, ticks, and numeric tick labels.
		</para></listitem><listitem><para>
		  <samp>1</samp>: also draw coordinate axes at
		  <samp>x=0</samp> and <samp>y=0</samp>.
		</para></listitem><listitem><para>
		  <samp>2</samp>: also draw a grid at major tick
positions in both coordinates.
		</para></listitem><listitem><para>
		  <samp>3</samp>: also draw a grid at minor tick
positions in both coordinates.
		</para></listitem><listitem><para>
		  <samp>10</samp>: same as 0 except logarithmic
		  <samp>x</samp> tick marks. (The <samp>x</samp>
		  data have to be converted to logarithms separately.)
		</para></listitem><listitem><para>
		  <samp>11</samp>: same as 1 except logarithmic
		  <samp>x</samp> tick marks. (The <samp>x</samp>
                  data have to be converted to logarithms separately.)
		</para></listitem><listitem><para>
		  <samp>12</samp>: same as 2 except logarithmic
		  <samp>x</samp> tick marks. (The <samp>x</samp>
                  data have to be converted to logarithms separately.)
		</para></listitem><listitem><para>
		  <samp>13</samp>: same as 3 except logarithmic
		  <samp>x</samp> tick marks. (The <samp>x</samp>
                  data have to be converted to logarithms separately.)
		</para></listitem><listitem><para>
		  <samp>20</samp>: same as 0 except logarithmic
		  <samp>y</samp> tick marks. (The <samp>y</samp>
		  data have to be converted to logarithms separately.)
		</para></listitem><listitem><para>
		  <samp>21</samp>: same as 1 except logarithmic
		  <samp>y</samp> tick marks. (The <samp>y</samp>
                  data have to be converted to logarithms separately.)
		</para></listitem><listitem><para>
		  <samp>22</samp>: same as 2 except logarithmic
		  <samp>y</samp> tick marks. (The <samp>y</samp>
                  data have to be converted to logarithms separately.)
		</para></listitem><listitem><para>
		  <samp>23</samp>: same as 3 except logarithmic
		  <samp>y</samp> tick marks. (The <samp>y</samp>
                  data have to be converted to logarithms separately.)
		</para></listitem><listitem><para>
		  <samp>30</samp>: same as 0 except logarithmic
		  <samp>x</samp> and <samp>y</samp> tick marks. (The <samp>x</samp> and <samp>y</samp>
		  data have to be converted to logarithms separately.)
		</para></listitem><listitem><para>
		  <samp>31</samp>: same as 1 except logarithmic
		  <samp>x</samp> and <samp>y</samp> tick marks. (The <samp>x</samp> and <samp>y</samp>
                  data have to be converted to logarithms separately.)
		</para></listitem><listitem><para>
		  <samp>32</samp>: same as 2 except logarithmic
		  <samp>x</samp> and <samp>y</samp> tick marks. (The <samp>x</samp> and <samp>y</samp>
                  data have to be converted to logarithms separately.)
		</para></listitem><listitem><para>
		  <samp>33</samp>: same as 3 except logarithmic
		  <samp>x</samp> and <samp>y</samp> tick marks. (The <samp>x</samp> and <samp>y</samp>
                  data have to be converted to logarithms separately.)
		</para></listitem></itemize>
	  </para></listitem></varlistentry></varlist><node name="&#10;      pleop; Eject current page&#10;    " previous="&#10;      plenv; Set up standard window and draw box&#10;    " next="&#10;      plerrx; Draw x error bar&#10;    " up="The Common API for PLplot"/><section>
      pleop: Eject current page
    </section><para>
      <quotation><para><t>
	  <b>pleop</b>
	();</t></para></quotation>
    </para><para>
      Clears the graphics screen of an interactive device, or ejects a page
      on a plotter.  See <code>plbop</code> (<pxref node="plbop; Begin a new page" file=""/>) for more information.
    </para><node name="&#10;      plerrx; Draw x error bar&#10;    " previous="&#10;      pleop; Eject current page&#10;    " next="&#10;      plerry; Draw y error bar&#10;    " up="The Common API for PLplot"/><section>
      plerrx: Draw x error bar
    </section><para>
      <quotation><para><t>
	  <b>plerrx</b>
	(<i>n</i>, <i>xmin</i>, <i>xmax</i>, <i>y</i>);</t></para></quotation>
    </para><para>
      Draws a set of <samp><code>n</code></samp>
      horizontal error bars, the
<samp>i</samp>'th error
bar extending from <samp><code>xmin</code>[i]</samp>
to <samp><code>xmax</code>[i]</samp> at y coordinate
<samp><code>y</code>[i]</samp>.  The terminals of the error bar are of length equal to the
minor tick length (settable using <code>plsmin</code> (<pxref node="&#10;      plsmin; Set length of minor ticks&#10;    " file=""/>)).
    </para><varlist><varlistentry><term>
	  <code>n</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of error bars to draw.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xmin</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array with x coordinates of
left-hand endpoint of error bars.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xmax</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array with x coordinates of
right-hand endpoint of error bars.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>y</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array with y coordinates of
error bar.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plerry; Draw y error bar&#10;    " previous="&#10;      plerrx; Draw x error bar&#10;    " next="&#10;      plfamadv; Advance to the next family file on the&#10;next new page&#10;    " up="The Common API for PLplot"/><section>
      plerry: Draw y error bar
    </section><para>
      <quotation><para><t>
	  <b>plerry</b>
	(<i>n</i>, <i>x</i>, <i>ymin</i>, <i>ymax</i>);</t></para></quotation>
    </para><para>
      Draws a set of <samp><code>n</code></samp> vertical
      error bars, the <samp>i</samp>'th error bar extending from
      <samp><code>ymin</code>[i]</samp> to
      <samp><code>ymax</code>[i]</samp> at x coordinate
      <samp><code>x</code>[i]</samp>.  The terminals of the
      error bar are of length equal to the minor tick length (settable
      using <code>plsmin</code> (<pxref node="&#10;      plsmin; Set length of minor ticks&#10;    " file=""/>)).
    </para><varlist><varlistentry><term>
	  <code>n</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of error bars to draw.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>x</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array with x coordinates of error bars.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ymin</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array with y coordinates of lower endpoint of error
	    bars.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ymax</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array with y coordinate of upper endpoint of error
	    bar.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plfamadv; Advance to the next family file on the&#10;next new page&#10;    " previous="&#10;      plerry; Draw y error bar&#10;    " next="&#10;      plfill; Draw filled polygon&#10;    " up="The Common API for PLplot"/><section>
      plfamadv: Advance to the next family file on the
next new page
    </section><para>
      <quotation><para><t>
           <b>plfamadv</b>
        ();</t></para></quotation>
    </para><para>
      Advance to the next family file on the next new page.
    </para><node name="&#10;      plfill; Draw filled polygon&#10;    " previous="&#10;      plfamadv; Advance to the next family file on the&#10;next new page&#10;    " next="&#10;      plfill3; Draw filled polygon in 3D&#10;    " up="The Common API for PLplot"/><section>
      plfill: Draw filled polygon
    </section><para>
      <quotation><para><t>
	  <b>plfill</b>
	(<i>n</i>, <i>x</i>, <i>y</i>);</t></para></quotation>
    </para><para>
      Fills the polygon defined by the
      <samp><code>n</code></samp> points
      <samp>(<code>x</code>[i],
      <code>y</code>[i])</samp> using the pattern defined by
      <code>plpsty</code> (<pxref node="&#10;      plpsty; Select area fill pattern&#10;    " file=""/>) or <code>plpat</code> (<pxref node="&#10;      plpat; Set area fill pattern&#10;    " file=""/>).  The routine will automatically close the
      polygon between the last and first vertices.  If multiple closed
      polygons are passed in <samp><code>x</code></samp>
      and <samp><code>y</code></samp> then <code>plfill</code> (<pxref node="&#10;      plfill; Draw filled polygon&#10;    " file=""/>) will
      fill in between them.
    </para><varlist><varlistentry><term>
	  <code>n</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of vertices in polygon.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>x</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array with x coordinates of vertices.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>y</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array with y coordinates of vertices.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plfill3; Draw filled polygon in 3D&#10;    " previous="&#10;      plfill; Draw filled polygon&#10;    " next="&#10;      plflush; Flushes the output stream&#10;    " up="The Common API for PLplot"/><section>
      plfill3: Draw filled polygon in 3D
    </section><para>
      <quotation><para><t>
	  <b>plfill3</b>
	(<i>n</i>, <i>x</i>, <i>y</i>, <i>z</i>);</t></para></quotation>
    </para><para>
      Fills the 3D polygon defined by the
      <samp><code>n</code></samp> points in the
      <samp><code>x</code></samp>,
      <samp><code>y</code></samp>, and
      <samp><code>z</code></samp> arrays
      using the pattern defined by
      <code>plpsty</code> (<pxref node="&#10;      plpsty; Select area fill pattern&#10;    " file=""/>) or <code>plpat</code> (<pxref node="&#10;      plpat; Set area fill pattern&#10;    " file=""/>).  The routine will automatically close the
      polygon between the last and first vertices.  If multiple closed
      polygons are passed in <samp><code>x</code></samp>,
      <samp><code>y</code></samp>,
      and <samp><code>z</code></samp> then <code>plfill3</code> (<pxref node="&#10;      plfill3; Draw filled polygon in 3D&#10;    " file=""/>) will
      fill in between them.
    </para><varlist><varlistentry><term>
	  <code>n</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of vertices in polygon.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>x</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array with x coordinates of vertices.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>y</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array with y coordinates of vertices.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>z</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array with z coordinates of vertices.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plflush; Flushes the output stream&#10;    " previous="&#10;      plfill3; Draw filled polygon in 3D&#10;    " next="&#10;      plfont; Set character font&#10;    " up="The Common API for PLplot"/><section>
      plflush: Flushes the output stream
    </section><para>
      <quotation><para><t>
           <b>plflush</b>
        ();</t></para></quotation>
    </para><para>
      Flushes the output stream. Use sparingly, if at all.
    </para><node name="&#10;      plfont; Set character font&#10;    " previous="&#10;      plflush; Flushes the output stream&#10;    " next="&#10;      plfontld; Load character font&#10;    " up="The Common API for PLplot"/><section>
      plfont: Set character font
    </section><para>
      <quotation><para><t>
	  <b>plfont</b>
	(<i>font</i>);</t></para></quotation>
    </para><para>
      Sets the default character font for subsequent character drawing.
      Also affects symbols produced by <code>plpoin</code> (<pxref node="&#10;      plpoin; Plots a character at the specified points&#10;    " file=""/>).  This routine has no
      effect unless the extended character set is loaded (see <code>plfontld</code> (<pxref node="&#10;      plfontld; Load character font&#10;    " file=""/>)).
    </para><varlist><varlistentry><term>
	  <code>font</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Specifies the font:
	    <itemize markchar="•"><listitem><para>
		  <samp>1</samp>: Normal font (simplest and fastest)
		</para></listitem><listitem><para>
		  <samp>2</samp>: Roman font
		</para></listitem><listitem><para>
		  <samp>3</samp>: Italic font
		</para></listitem><listitem><para>
		  <samp>4</samp>: Script font
		</para></listitem></itemize>
	  </para></listitem></varlistentry></varlist><node name="&#10;      plfontld; Load character font&#10;    " previous="&#10;      plfont; Set character font&#10;    " next="&#10;      plgchr; Get character default height and current&#10;[scaled] height&#10;    " up="The Common API for PLplot"/><section>
      plfontld: Load character font
    </section><para>
      <quotation><para><t>
	  <b>plfontld</b>
	(<i>set</i>);</t></para></quotation>
    </para><para>
      Sets the character set to use for subsequent character drawing.  May
      be called before calling initializing PLplot.
    </para><varlist><varlistentry><term>
	  <code>set</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Specifies the character set to load:
	    <itemize markchar="•"><listitem><para>
		  <samp>0</samp>: Standard character set
		</para></listitem><listitem><para>
		  <samp>1</samp>: Extended character set
		</para></listitem></itemize>
	  </para></listitem></varlistentry></varlist><node name="&#10;      plgchr; Get character default height and current&#10;[scaled] height&#10;    " previous="&#10;      plfontld; Load character font&#10;    " next="&#10;      plgcol0; Returns 8-bit RGB values for given color&#10;from color map0&#10;    " up="The Common API for PLplot"/><section>
      plgchr: Get character default height and current
(scaled) height
    </section><para>
      <quotation><para><t>
           <b>plgchr</b>
        (<i>p_def</i>, <i>p_ht</i>);</t></para></quotation>
    </para><para>
      Get character default height and current (scaled) height.
    </para><varlist><varlistentry><term>
	  <code>p_def</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
            Pointer to default character height (mm).
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>p_ht</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
            Pointer to current (scaled) character height (mm).
	  </para></listitem></varlistentry></varlist><node name="&#10;      plgcol0; Returns 8-bit RGB values for given color&#10;from color map0&#10;    " previous="&#10;      plgchr; Get character default height and current&#10;[scaled] height&#10;    " next="&#10;      plgcolbg;  Returns the background color&#10;[cmap0[0]] by 8-bit RGB value&#10;    " up="The Common API for PLplot"/><section>
      plgcol0: Returns 8-bit RGB values for given color
from color map0
    </section><para>
      <quotation><para><t>
           <b>plgcol0</b>
        (<i>icol0</i>, <i>r</i>, <i>g</i>, <i>b</i>);</t></para></quotation>
    </para><para>
      Returns 8-bit RGB values (-255) for given color from color map0 (see
      <ref node="Color Map0" file="">Color Map0</ref>).  Values are
      negative if an invalid color id is given.
    </para><varlist><varlistentry><term>
	  <code>icol0</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Index of desired cmap0 color.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>r</code>
	  (<samp>PLINT *</samp>, output)
	</term><listitem><para>
            Pointer to 8-bit red value.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>g</code>
	  (<samp>PLINT *</samp>, output)
	</term><listitem><para>
            Pointer to 8-bit green value.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>b</code>
	  (<samp>PLINT *</samp>, output)
	</term><listitem><para>
            Pointer to 8-bit blue value.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plgcolbg;  Returns the background color&#10;[cmap0[0]] by 8-bit RGB value&#10;    " previous="&#10;      plgcol0; Returns 8-bit RGB values for given color&#10;from color map0&#10;    " next="&#10;      plgcompression; Get the current&#10;      device-compression setting&#10;    " up="The Common API for PLplot"/><section>
      plgcolbg:  Returns the background color
(cmap0[0]) by 8-bit RGB value
    </section><para>
      <quotation><para><t>
           <b>plgcolbg</b>
        (<i>r</i>, <i>g</i>, <i>b</i>);</t></para></quotation>
    </para><para>
       Returns the background color (cmap0[0]) by 8-bit RGB value.
    </para><varlist><varlistentry><term>
	  <code>r</code>
	  (<samp>PLINT *</samp>, output)
	</term><listitem><para>
            Pointer to an unsigned 8-bit integer (0-255) representing
	    the degree of red in the color.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>g</code>
	  (<samp>PLINT *</samp>, output)
	</term><listitem><para>
            Pointer to an unsigned 8-bit integer (0-255) representing
	    the degree of green in the color.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>b</code>
	  (<samp>PLINT *</samp>, output)
	</term><listitem><para>
            Pointer to an unsigned 8-bit integer (0-255) representing
	    the degree of blue in the color.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plgcompression; Get the current&#10;      device-compression setting&#10;    " previous="&#10;      plgcolbg;  Returns the background color&#10;[cmap0[0]] by 8-bit RGB value&#10;    " next="&#10;      plgdev; Get the current device [keyword] name&#10;    " up="The Common API for PLplot"/><section>
      plgcompression: Get the current
      device-compression setting
    </section><para>
      <quotation><para><t>
	  <b>plgcompression</b>
	(<i>compression</i>);</t></para></quotation>
    </para><para>
      Get the current device-compression setting.  This parameter is
      only used for drivers that provide compression.
    </para><varlist><varlistentry><term>
	  <code>compression</code>
	  (<samp>PLINT *</samp>, output)
	</term><listitem><para>
           Pointer to a variable to be filled with the current
	   device-compression setting.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plgdev; Get the current device [keyword] name&#10;    " previous="&#10;      plgcompression; Get the current&#10;      device-compression setting&#10;    " next="&#10;      plgdidev; Get parameters that define current&#10;      device-space window&#10;    " up="The Common API for PLplot"/><section>
      plgdev: Get the current device (keyword) name
    </section><para>
      <quotation><para><t>
           <b>plgdev</b>
        (<i>p_dev</i>);</t></para></quotation>
    </para><para>
      Get the current device (keyword) name.  Note: you
<i>must</i> have allocated
space for this (80 characters is safe).
    </para><varlist><varlistentry><term>
	  <code>p_dev</code>
	  (<samp>char *</samp>, output)
	</term><listitem><para>
            Pointer to device (keyword) name string.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plgdidev; Get parameters that define current&#10;      device-space window&#10;    " previous="&#10;      plgdev; Get the current device [keyword] name&#10;    " next="&#10;      plgdiori; Get plot orientation&#10;    " up="The Common API for PLplot"/><section>
      plgdidev: Get parameters that define current
      device-space window
    </section><para>
      <quotation><para><t>
           <b>plgdidev</b>
        (<i>p_mar</i>, <i>p_aspect</i>, <i>p_jx</i>, <i>p_jy</i>);</t></para></quotation>
    </para><para>
      Get relative margin width, aspect ratio, and relative justification
      that define current device-space window.
      If <code>plsdidev</code> (<pxref node="&#10;      plsdidev; Set parameters that define current&#10;      device-space window&#10;    " file=""/>) has not been called the default values pointed to by
      <samp><code>p_mar</code></samp>,
      <samp><code>p_aspect</code></samp>,
      <samp><code>p_jx</code></samp>, and
      <samp><code>p_jy</code></samp>
      will all be 0.
    </para><varlist><varlistentry><term>
	  <code>p_mar</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
            Pointer to relative margin width.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>p_aspect</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
            Pointer to aspect ratio.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>p_jx</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
            Pointer to relative justification in x.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>p_jy</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
            Pointer to relative justification in y.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plgdiori; Get plot orientation&#10;    " previous="&#10;      plgdidev; Get parameters that define current&#10;      device-space window&#10;    " next="&#10;      plgdiplt; Get parameters that define current&#10;      plot-space window&#10;    " up="The Common API for PLplot"/><section>
      plgdiori: Get plot orientation
    </section><para>
      <quotation><para><t>
           <b>plgdiori</b>
        (<i>p_rot</i>);</t></para></quotation>
    </para><para>
      Get plot orientation parameter which is multiplied by 90 degrees to
      obtain the angle of rotation.  Note, arbitrary rotation parameters
      such as 0.2 (corresponding to 18 degrees) are possible, but the usual
      values for the rotation parameter are 0., 1., 2., and 3. corresponding
      to 0 degrees (landscape mode), 90 degrees (portrait mode), 180 degrees
      (seascape mode), and 270 degrees (upside-down mode).
      If <code>plsdiori</code> (<pxref node="&#10;      plsdiori; Set plot orientation&#10;    " file=""/>) has not been called the default value pointed to by
      <samp><code>p_rot</code></samp>
      will be 0.
    </para><varlist><varlistentry><term>
	  <code>p_rot</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
            Pointer to orientation parameter.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plgdiplt; Get parameters that define current&#10;      plot-space window&#10;    " previous="&#10;      plgdiori; Get plot orientation&#10;    " next="&#10;      plgfam; Get family file parameters&#10;    " up="The Common API for PLplot"/><section>
      plgdiplt: Get parameters that define current
      plot-space window
    </section><para>
      <quotation><para><t>
           <b>plgdiplt</b>
        (<i>p_xmin</i>, <i>p_ymin</i>, <i>p_xmax</i>, <i>p_ymax</i>);</t></para></quotation>
    </para><para>
      Get relative minima and maxima that define current
      plot-space window.
      If <code>plsdiplt</code> (<pxref node="&#10;      plsdiplt; Set parameters that define current&#10;      plot-space window&#10;    " file=""/>) has not been called the default values pointed to by
      <samp><code>p_xmin</code></samp>,
      <samp><code>p_ymin</code></samp>,
      <samp><code>p_xmax</code></samp>, and
      <samp><code>p_ymax</code></samp>
      will be 0., 0., 1., and 1.

    </para><varlist><varlistentry><term>
	  <code>p_xmin</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
            Pointer to relative minimum in x.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>p_ymin</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
            Pointer to relative minimum in y.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>p_xmax</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
            Pointer to relative maximum in x.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>p_ymax</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
            Pointer to relative maximum in y.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plgfam; Get family file parameters&#10;    " previous="&#10;      plgdiplt; Get parameters that define current&#10;      plot-space window&#10;    " next="&#10;      plgfci; Get FCI [font characterization integer]&#10;    " up="The Common API for PLplot"/><section>
      plgfam: Get family file parameters
    </section><para>
      <quotation><para><t>
	  <b>plgfam</b>
	(<i>fam</i>, <i>num</i>, <i>bmax</i>);</t></para></quotation>
    </para><para>
      Gets information about current family file, if familying is
      enabled.  See <ref node="Family File Output" file="">Family File Output</ref> for more information.
    </para><varlist><varlistentry><term>
	  <code>fam</code>
	  (<samp>PLINT *</samp>, output)
	</term><listitem><para>
	    Pointer to variable with the Boolean family flag value.  If
	    nonzero, familying is enabled.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>num</code>
	  (<samp>PLINT *</samp>, output)
	</term><listitem><para>
	    Pointer to variable with the current family file number.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>bmax</code>
	  (<samp>PLINT *</samp>, output)
	</term><listitem><para>
	    Pointer to variable with the maximum file size (in bytes) for a
	    family file.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plgfci; Get FCI [font characterization integer]&#10;    " previous="&#10;      plgfam; Get family file parameters&#10;    " next="&#10;      plgfnam; Get output file name&#10;    " up="The Common API for PLplot"/><section>
      plgfci: Get FCI (font characterization integer)
    </section><para>
      <quotation><para><t>
	  <b>plgfci</b>
	(<i>fci</i>);</t></para></quotation>
    </para><para>
      Gets information about the current font using the FCI approach.
      See <ref node="FCI" file="">FCI</ref> for more information.
    </para><varlist><varlistentry><term>
	  <code>fci</code>
	  (<samp>PLUNICODE *</samp>, output)
	</term><listitem><para>
	    Pointer to PLUNICODE (unsigned 32-bit integer) variable which
	    is updated with current FCI value.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plgfnam; Get output file name&#10;    " previous="&#10;      plgfci; Get FCI [font characterization integer]&#10;    " next="&#10;      plglevel; Get the [current] run level&#10;    " up="The Common API for PLplot"/><section>
      plgfnam: Get output file name
    </section><para>
      <quotation><para><t>
	  <b>plgfnam</b>
	(<i>fnam</i>);</t></para></quotation>
    </para><para>
      Gets the current output file name, if applicable.
    </para><varlist><varlistentry><term>
	  <code>fnam</code>
	  (<samp>char *</samp>, output)
	</term><listitem><para>
	    Pointer to file name string (a preallocated string of 80 characters or more).
	  </para></listitem></varlistentry></varlist><node name="&#10;      plglevel; Get the [current] run level&#10;    " previous="&#10;      plgfnam; Get output file name&#10;    " next="&#10;      plgpage; Get page parameters&#10;    " up="The Common API for PLplot"/><section>
      plglevel: Get the (current) run level
    </section><para>
      <quotation><para><t>
           <b>plglevel</b>
        (<i>p_level</i>);</t></para></quotation>
    </para><para>
      Get the (current) run level. Valid settings are:
    <itemize markchar="•"><listitem><para>
    0,  uninitialized
    </para></listitem><listitem><para>
    1,  initialized
    </para></listitem><listitem><para>
    2,  viewport defined
    </para></listitem><listitem><para>
    3,  world coords defined
    </para></listitem></itemize>

</para><varlist><varlistentry><term>
	  <code>p_level</code>
	  (<samp>PLINT *</samp>, output)
	</term><listitem><para>
            Pointer to the run level.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plgpage; Get page parameters&#10;    " previous="&#10;      plglevel; Get the [current] run level&#10;    " next="&#10;      plgra; Switch to graphics screen&#10;    " up="The Common API for PLplot"/><section>
      plgpage: Get page parameters
    </section><para>
      <quotation><para><t>
	  <b>plgpage</b>
	(<i>xp</i>, <i>yp</i>, <i>xleng</i>, <i>yleng</i>, <i>xoff</i>, <i>yoff</i>);</t></para></quotation>
    </para><para>
      Gets the current page configuration. The parameters are expressed
      in units that are specific to the current driver. For instance:
      screen drivers will usually interpret them as number of pixels,
      whereas printer drivers will usually use mm.
    </para><varlist><varlistentry><term>
	  <code>xp</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
	    Pointer to number of pixels in x.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>yp</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
	    Pointer to number of pixels in y.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xleng</code>
	  (<samp>PLINT *</samp>, output)
	</term><listitem><para>
	    Pointer to x page length value.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>yleng</code>
	  (<samp>PLINT *</samp>, output)
	</term><listitem><para>
	    Pointer to y page length value.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xoff</code>
	  (<samp>PLINT *</samp>, output)
	</term><listitem><para>
	    Pointer to x page offset.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>yoff</code>
	  (<samp>PLINT *</samp>, output)
	</term><listitem><para>
	    Pointer to y page offset.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plgra; Switch to graphics screen&#10;    " previous="&#10;      plgpage; Get page parameters&#10;    " next="&#10;      plgriddata; Grid data from irregularly sampled&#10;      data&#10;    " up="The Common API for PLplot"/><section>
      plgra: Switch to graphics screen
    </section><para>
      <quotation><para><t>
	  <b>plgra</b>
	();</t></para></quotation>
    </para><para>
      Sets an interactive device to graphics mode, used in conjunction with
      <code>pltext</code> (<pxref node="&#10;      pltext; Switch to text screen&#10;    " file=""/>) to allow graphics and text to be interspersed.  On a device
      which supports separate text and graphics windows, this command
      causes control to be switched to the graphics window.  If already in
      graphics mode, this command is ignored.  It is also ignored on
      devices which only support a single window or use a different method
      for shifting focus.  See also <code>pltext</code> (<pxref node="&#10;      pltext; Switch to text screen&#10;    " file=""/>).
    </para><node name="&#10;      plgriddata; Grid data from irregularly sampled&#10;      data&#10;    " previous="&#10;      plgra; Switch to graphics screen&#10;    " next="&#10;      plgspa; Get current subpage parameters&#10;    " up="The Common API for PLplot"/><section>
      plgriddata: Grid data from irregularly sampled
      data
    </section><para>
      <quotation><para><t>
	  <b>plggriddata</b>
	(<i>x</i>, <i>y</i>, <i>z</i>, <i>npts</i>, <i>xg</i>, <i>nptsx</i>, <i>yg</i>, <i>nptsy</i>, <i>zg</i>, <i>type</i>, <i>data</i>);</t></para></quotation>
    </para><para>
      Real world data is frequently irregularly sampled, but all PLplot 3D
      plots require data placed in a uniform grid. This function takes
      irregularly sampled data from three input arrays
      <samp>x[npts]</samp>, <samp>y[npts]</samp>, and
      <samp>z[npts]</samp>, reads the desired grid location from
      input arrays <samp>xg[nptsx]</samp> and
      <samp>yg[nptsy]</samp>, and returns the gridded data into
      output array <samp>zg[nptsx][nptsy]</samp>.  The algorithm used
      to grid the data is specified with the argument
      <samp>type</samp> which can have one parameter specified in
      argument <samp>data</samp>.
    </para><varlist><varlistentry><term>
	  <code>x</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    The input <samp>x</samp> array.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>y</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    The input <samp>y</samp> array.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>z</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    The input <samp>z</samp> array. Each triple
            <samp>x[i]</samp>, <samp>y[i]</samp>,
            <samp>z[i]</samp> represents one data sample coordinates.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>npts</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    The number of data samples in the <samp>x</samp>,
            <samp>y</samp> and <samp>z</samp> arrays.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xg</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    The input array that specifies the grid spacing in the x
	    direction. Usually <samp>xg</samp> has
            <samp>nptsx</samp> equaly spaced values from the mininum
            to the maximum values of the <samp>x</samp> input array.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nptsx</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    The number of points in the <samp>xg</samp> array.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>yg</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    The input array that specifies the grid spacing in the y
	    direction. Similar to the <samp>xg</samp> parameter.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nptsy</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    The number of points in the <samp>yg</samp> array.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>sg</code>
	  (<samp>PLFLT **</samp>, output)
	</term><listitem><para>
	    The output array, where data lies in the regular grid
	    specified by <samp>xg</samp> and <samp>yg.</samp>
            the <samp>zg</samp> array must exists or be allocated by
            the user prior to the calling, and must have dimension
            <samp>zg[nptsx][xptsy]</samp>.
          </para></listitem></varlistentry><varlistentry><term>
	  <code>type</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    The type of gridding algorithm to use, which can be:
          </para><itemize markchar="•"><listitem><para>
                <samp>GRID_CSA</samp>: Bivariate Cubic Spline
                approximation
              </para></listitem><listitem><para>
                <samp>GRID_DTLI</samp>: Delaunay Triangulation Linear
                Interpolation
              </para></listitem><listitem><para>
                <samp>GRID_NNI</samp>: Natural Neighbors Interpolation
              </para></listitem><listitem><para>
                <samp>GRID_NNIDW</samp>: Nearest Neighbors Inverse
                Distance Weighted
              </para></listitem><listitem><para>
                <samp>GRID_NNLI</samp>: Nearest Neighbors Linear
                Interpolation
              </para></listitem><listitem><para>
                <samp>GRID_NNAIDW</samp>:  Nearest Neighbors Around
                Inverse Distance Weighted
              </para></listitem></itemize><para>
            For details on the algorithm read the source file
            <file>plgridd.c</file>.
          </para></listitem></varlistentry><varlistentry><term>
	  <code>data</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    Some gridding algorithms require extra data, which can be
	    specified through this argument. Currently, for algoritm:
          </para><itemize markchar="•"><listitem><para>
                <samp>GRID_NNIDW</samp>, <samp>data</samp>
                specifies the number of neighbors to use, the lower the
                value, the noisier (more local) the approximation is.
              </para></listitem><listitem><para>
                <samp>GRID_NNLI</samp>, <samp>data</samp>
                specifies what a thin triangle is, in the range
                [1. .. 2.]. High values enable the usage of very thin
                triangles for interpolation, possibly resulting in error in
                the approximation.
              </para></listitem><listitem><para>
                <samp>GRID_NNI</samp>, only weights greater than
                <samp>data</samp> will be accepted. If 0, all weigths
                will be accepted.
              </para></listitem></itemize></listitem></varlistentry></varlist><node name="&#10;      plgspa; Get current subpage parameters&#10;    " previous="&#10;      plgriddata; Grid data from irregularly sampled&#10;      data&#10;    " next="&#10;      plgstrm; Get current stream number&#10;    " up="The Common API for PLplot"/><section>
      plgspa: Get current subpage parameters
    </section><para>
      <quotation><para><t>
	  <b>plgspa</b>
	(<i>xmin</i>, <i>xmax</i>, <i>ymin</i>, <i>ymax</i>);</t></para></quotation>
    </para><para>
      Gets the size of the current subpage in millimeters measured from the
      bottom left hand corner of the output device page or screen.  Can be
      used in conjunction with <code>plsvpa</code> (<pxref node="&#10;      plsvpa; Specify viewport in absolute coordinates&#10;    " file=""/>) for setting the size of a viewport
      in absolute coordinates (millimeters).
    </para><varlist><varlistentry><term>
	  <code>xmin</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
	    Pointer to variable with position of left hand edge of subpage
	    in millimeters.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xmax</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
	    Pointer to variable with position of right hand edge of subpage
	    in millimeters.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ymin</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
	    Pointer to variable with position of bottom edge of subpage in
	    millimeters.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ymax</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
	    Pointer to variable with position of top edge of subpage in
	    millimeters.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plgstrm; Get current stream number&#10;    " previous="&#10;      plgspa; Get current subpage parameters&#10;    " next="&#10;      plgver; Get the current library version number&#10;    " up="The Common API for PLplot"/><section>
      plgstrm: Get current stream number
    </section><para>
      <quotation><para><t>
	  <b>plgstrm</b>
	(<i>strm</i>);</t></para></quotation>
    </para><para>
      Gets the number of the current output stream. See also <code>plsstrm</code> (<pxref node="&#10;      plsstrm; Set current output stream&#10;    " file=""/>).
    </para><varlist><varlistentry><term>
	  <code>strm</code>
	  (<samp>PLINT *</samp>, output)
	</term><listitem><para>
	    Pointer to current stream value.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plgver; Get the current library version number&#10;    " previous="&#10;      plgstrm; Get current stream number&#10;    " next="&#10;      plgvpd; Get viewport limits in normalized&#10;device coordinates&#10;    " up="The Common API for PLplot"/><section>
      plgver: Get the current library version number
    </section><para>
      <quotation><para><t>
           <b>plgver</b>
        (<i>p_ver</i>);</t></para></quotation>
    </para><para>
      Get the current library version number.  Note: you <i>must</i>
      have allocated space for this (80 characters is safe).
    </para><varlist><varlistentry><term>
	  <code>p_ver</code>
	  (<samp>char *</samp>, output)
	</term><listitem><para>
            Pointer to the current library version number.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plgvpd; Get viewport limits in normalized&#10;device coordinates&#10;    " previous="&#10;      plgver; Get the current library version number&#10;    " next="&#10;      plgvpw; Get viewport limits in world coordinates&#10;    " up="The Common API for PLplot"/><section>
      plgvpd: Get viewport limits in normalized
device coordinates
    </section><para>
      <quotation><para><t>
           <b>plgvpd</b>
        (<i>p_xmin</i>, <i>p_xmax</i>, <i>p_ymin</i>, <i>p_ymax</i>);</t></para></quotation>
    </para><para>
      Get viewport limits in normalized device coordinates.
    </para><varlist><varlistentry><term>
	  <code>p_xmin</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
            Lower viewport limit of the normalized device coordinate in x.
	    </para></listitem></varlistentry><varlistentry><term>
	  <code>p_xmax</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
            Upper viewport limit of the normalized device coordinate in x.
	    </para></listitem></varlistentry><varlistentry><term>
	  <code>p_ymin</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
            Lower viewport limit of the normalized device coordinate in y.
	    </para></listitem></varlistentry><varlistentry><term>
	  <code>p_ymax</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
            Upper viewport limit of the normalized device coordinate in y.
	    </para></listitem></varlistentry></varlist><node name="&#10;      plgvpw; Get viewport limits in world coordinates&#10;    " previous="&#10;      plgvpd; Get viewport limits in normalized&#10;device coordinates&#10;    " next="&#10;      plgxax; Get x axis parameters&#10;    " up="The Common API for PLplot"/><section>
      plgvpw: Get viewport limits in world coordinates
    </section><para>
      <quotation><para><t>
           <b>plgvpw</b>
        (<i>p_xmin</i>, <i>p_xmax</i>, <i>p_ymin</i>, <i>p_ymax</i>);</t></para></quotation>
    </para><para>
      Get viewport limits in world coordinates.
    </para><varlist><varlistentry><term>
	  <code>p_xmin</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
            Lower viewport limit of the world coordinate in x.
	    </para></listitem></varlistentry><varlistentry><term>
	  <code>p_xmax</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
            Upper viewport limit of the world coordinate in x.
	    </para></listitem></varlistentry><varlistentry><term>
	  <code>p_ymin</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
            Lower viewport limit of the world coordinate in y.
	    </para></listitem></varlistentry><varlistentry><term>
	  <code>p_ymax</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
            Upper viewport limit of the world coordinate in y.
	    </para></listitem></varlistentry></varlist><node name="&#10;      plgxax; Get x axis parameters&#10;    " previous="&#10;      plgvpw; Get viewport limits in world coordinates&#10;    " next="&#10;      plgyax; Get y axis parameters&#10;    " up="The Common API for PLplot"/><section>
      plgxax: Get x axis parameters
    </section><para>
      <quotation><para><t>
	  <b>plgxax</b>
	(<i>digmax</i>, <i>digits</i>);</t></para></quotation>
    </para><para>
      Returns current values of the
      <samp><code>digmax</code></samp> and
      <samp><code>digits</code></samp> flags for the x
      axis.  <samp><code>digits</code></samp> is updated
      after the plot is drawn, so this routine should only be called
      <i>after</i> the call to <code>plbox</code> (<pxref node="plbox; Draw a box with axes; etc" file=""/>) (or <code> plbox3</code> (<pxref node="&#10;      plbox3; Draw a box with axes; etc; in 3-d&#10;    " file=""/>)) is
      complete.  See <ref node="Annotating the Viewport" file="">Annotating the Viewport</ref> for more information.
    </para><varlist><varlistentry><term>
	  <code>digmax</code>
	  (<samp>PLINT *</samp>, output)
	</term><listitem><para>
	    Pointer to variable with the maximum number of digits for the x axis.  If
	    nonzero, the printed label has been switched to a floating point
	    representation when the number of digits exceeds
	    <samp><code>digmax</code></samp>.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>digits</code>
	  (<samp>PLINT *</samp>, output)
	</term><listitem><para>
	    Pointer to variable with the actual number of digits for the
	    numeric labels (x axis) from the last plot.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plgyax; Get y axis parameters&#10;    " previous="&#10;      plgxax; Get x axis parameters&#10;    " next="&#10;      plgzax; Get z axis parameters&#10;    " up="The Common API for PLplot"/><section>
      plgyax: Get y axis parameters
    </section><para>
      <quotation><para><t>
	  <b>plgyax</b>
	(<i>digmax</i>, <i>digits</i>);</t></para></quotation>
    </para><para>
      Identical to <code>plgxax</code> (<pxref node="&#10;      plgxax; Get x axis parameters&#10;    " file=""/>), except that arguments are flags for y axis.
      See the description of <code>plgxax</code> (<pxref node="&#10;      plgxax; Get x axis parameters&#10;    " file=""/>) for more detail.
    </para><varlist><varlistentry><term>
	  <code>digmax</code>
	  (<samp>PLINT *</samp>, output)
	</term><listitem><para>
	    Pointer to variable with the maximum number of digits for the y axis.  If
	    nonzero, the printed label has been switched to a floating point
	    representation when the number of digits exceeds
	    <samp><code>digmax</code></samp>.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>digits</code>
	  (<samp>PLINT *</samp>, output)
	</term><listitem><para>
	    Pointer to variable with the actual number of digits for the
	    numeric labels (y axis) from the last plot.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plgzax; Get z axis parameters&#10;    " previous="&#10;      plgyax; Get y axis parameters&#10;    " next="&#10;      plhist; Plot a histogram from unbinned data&#10;    " up="The Common API for PLplot"/><section>
      plgzax: Get z axis parameters
    </section><para>
      <quotation><para><t>
	  <b>plgzax</b>
	(<i>digmax</i>, <i>digits</i>);</t></para></quotation>
    </para><para>
      Identical to <code>plgxax</code> (<pxref node="&#10;      plgxax; Get x axis parameters&#10;    " file=""/>), except that arguments are flags for z axis.
      See the description of <code>plgxax</code> (<pxref node="&#10;      plgxax; Get x axis parameters&#10;    " file=""/>) for more detail.
    </para><varlist><varlistentry><term>
	  <code>digmax</code>
	  (<samp>PLINT *</samp>, output)
	</term><listitem><para>
	    Pointer to variable with the maximum number of digits for the z axis.  If
	    nonzero, the printed label has been switched to a floating point
	    representation when the number of digits exceeds
	    <samp><code>digmax</code></samp>.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>digits</code>
	  (<samp>PLINT *</samp>, output)
	</term><listitem><para>
	    Pointer to variable with the actual number of digits for the
	    numeric labels (z axis) from the last plot.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plhist; Plot a histogram from unbinned data&#10;    " previous="&#10;      plgzax; Get z axis parameters&#10;    " next="&#10;      plhlsrgb; Convert HLS color to RGB&#10;    " up="The Common API for PLplot"/><section>
      plhist: Plot a histogram from unbinned data
    </section><para>
      <quotation><para><t>
	  <b>plhist</b>
	(<i>n</i>, <i>data</i>, <i>datmin</i>, <i>datmax</i>, <i>nbin</i>, <i>oldwin</i>);</t></para></quotation>
    </para><para>
      Plots a histogram from <samp><code>n</code></samp>
      data points stored in the array
      <samp><code>data</code></samp>.  This routine bins
      the data into <samp><code>nbin</code></samp> bins
      equally spaced between
      <samp><code>datmin</code></samp> and
      <samp><code>datmax</code></samp>, and calls <code>plbin</code> (<pxref node="&#10;      plbin; Plot a histogram from binned data&#10;    " file=""/>)
      to draw the resulting histogram.  Parameter
      <samp><code>oldwin</code></samp> allows the histogram
      either to be plotted in an existing window or causes <code>plhist</code> (<pxref node="&#10;      plhist; Plot a histogram from unbinned data&#10;    " file=""/>) to call
      <code>plenv</code> (<pxref node="&#10;      plenv; Set up standard window and draw box&#10;    " file=""/>) with suitable limits before plotting the histogram.
    </para><varlist><varlistentry><term>
	  <code>n</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of data points.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>data</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array with values of the
	    <samp><code>n</code></samp> data points.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>datmin</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    Left-hand edge of lowest-valued bin.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>datmax</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    Right-hand edge of highest-valued bin.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nbin</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of (equal-sized) bins into which to divide the interval
	    <samp><code>xmin</code></samp> to
	    <samp><code>xmax</code></samp>.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>oldwin</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    If one, the histogram is plotted in the currently-defined
	    window, and if zero, <code>plenv</code> (<pxref node="&#10;      plenv; Set up standard window and draw box&#10;    " file=""/>) is called automatically before
	    plotting.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plhlsrgb; Convert HLS color to RGB&#10;    " previous="&#10;      plhist; Plot a histogram from unbinned data&#10;    " next="&#10;      plinit; Initialize PLplot&#10;    " up="The Common API for PLplot"/><section>
      plhlsrgb: Convert HLS color to RGB
    </section><para>
      <quotation><para><t>
           <b>plhlsrgb</b>
        (<i>h</i>, <i>l</i>, <i>s</i>, <i>p_r</i>, <i>p_g</i>, <i>p_b</i>);</t></para></quotation>
    </para><para>
      Convert HLS color coordinates to RGB
    </para><varlist><varlistentry><term>
	  <code>h</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            Hue, in degrees on the colour cone (0.0-360.0)
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>l</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            Lightness, expressed as a fraction of the axis of the colour
            cone (0.0-1.0)
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>s</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            Saturation, expressed as a fraction of the radius of the
            colour cone (0.0-1.0)
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>p_r</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
            Pointer to red intensity (0.0-1.0) of the colour
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>p_g</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
            Pointer to green intensity (0.0-1.0) of the colour
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>p_b</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
            Pointer to blue intensity (0.0-1.0) of the colour
	  </para></listitem></varlistentry></varlist><node name="&#10;      plinit; Initialize PLplot&#10;    " previous="&#10;      plhlsrgb; Convert HLS color to RGB&#10;    " next="&#10;      pljoin; Draw a line between two points&#10;    " up="The Common API for PLplot"/><section>
      plinit: Initialize PLplot
    </section><para>
      <quotation><para><t>
	  <b>plinit</b>
	();</t></para></quotation>
    </para><para>
      Initializing the plotting package.  The program prompts for the
      device keyword or number of the desired output device.  Hitting a
      RETURN in response to the prompt is the same as selecting the first
      device.  <code>plinit</code> (<pxref node="&#10;      plinit; Initialize PLplot&#10;    " file=""/>) will issue no prompt if either the device was
      specified previously (via command line flag, the <code>plsetopt</code> (<pxref node="&#10;      plsetopt; Set any command-line option&#10;    " file=""/>) function,
      or the <code>plsdev</code> (<pxref node="&#10;      plsdev; Set the device [keyword] name&#10;    " file=""/>) function), or if only one device is
      enabled when PLplot is installed.  If subpages have been specified,
      the output device is divided into <samp>nx</samp> by
      <samp>ny</samp> subpages, each of which may be used
      independently.  If <code>plinit</code> (<pxref node="&#10;      plinit; Initialize PLplot&#10;    " file=""/>) is called again during a program, the
      previously opened file will be closed.  The subroutine <code>pladv</code> (<pxref node="pladv; Advance the [sub-]page" file=""/>) is
      used to advance from one subpage to the next.
    </para><node name="&#10;      pljoin; Draw a line between two points&#10;    " previous="&#10;      plinit; Initialize PLplot&#10;    " next="&#10;      pllab; Simple routine to write labels&#10;    " up="The Common API for PLplot"/><section>
      pljoin: Draw a line between two points
    </section><para>
      <quotation><para><t>
	  <b>pljoin</b>
	(<i>x1</i>, <i>y1</i>, <i>x2</i>, <i>y2</i>);</t></para></quotation>
    </para><para>
      Joins the point <samp>(<code>x1</code>,
      <code>y1</code>)</samp> to
      <samp>(<code>x2</code>,
      <code>y2</code>)</samp>.
    </para><varlist><varlistentry><term>
	  <code>x1</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    x coordinate of first point.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>y1</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    y coordinate of first point.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>x2</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    x coordinate of second point.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>y2</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    y coordinate of second point.
	  </para></listitem></varlistentry></varlist><node name="&#10;      pllab; Simple routine to write labels&#10;    " previous="&#10;      pljoin; Draw a line between two points&#10;    " next="&#10;      pllightsource; Sets the 3D position of the light&#10;source&#10;    " up="The Common API for PLplot"/><section>
      pllab: Simple routine to write labels
    </section><para>
      <quotation><para><t>
	  <b>pllab</b>
	(<i>xlabel</i>, <i>ylabel</i>, <i>tlabel</i>);</t></para></quotation>
    </para><para>
      Routine for writing simple labels. Use <code>plmtex</code> (<pxref node="&#10;      plmtex; Write text relative to viewport boundaries&#10;    " file=""/>) for more complex
      labels.
    </para><varlist><varlistentry><term>
	  <code>xlabel</code>
	  (<samp>const char *</samp>, input)
	</term><listitem><para>
	    Label for horizontal axis.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ylabel</code>
	  (<samp>const char *</samp>, input)
	</term><listitem><para>
	    Label for vertical axis.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>tlabel</code>
	  (<samp>const char *</samp>, input)
	</term><listitem><para>
	    Title of graph.
	  </para></listitem></varlistentry></varlist><node name="&#10;      pllightsource; Sets the 3D position of the light&#10;source&#10;    " previous="&#10;      pllab; Simple routine to write labels&#10;    " next="&#10;      plline; Draw a line&#10;    " up="The Common API for PLplot"/><section>
      pllightsource: Sets the 3D position of the light
source
    </section><para>
      <quotation><para><t>
           <b>pllightsource</b>
        (<i>x</i>, <i>y</i>, <i>z</i>);</t></para></quotation>
    </para><para>
    Sets the 3D position of the light source for use with <code>plsurf3d</code> (<pxref node="&#10;      plsurf3d; Plot shaded 3-d surface plot&#10;    " file=""/>).
    </para><varlist><varlistentry><term>
	  <code>x</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            X-coordinate of the light source.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>y</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            Y-coordinate of the light source.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>z</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            Z-coordinate of the light source.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plline; Draw a line&#10;    " previous="&#10;      pllightsource; Sets the 3D position of the light&#10;source&#10;    " next="&#10;      plline3; Draw a line in 3 space&#10;    " up="The Common API for PLplot"/><section>
      plline: Draw a line
    </section><para>
      <quotation><para><t>
	  <b>plline</b>
	(<i>n</i>, <i>x</i>, <i>y</i>);</t></para></quotation>
    </para><para>
      Draws line defined by <samp><code>n</code></samp>
      points in
      <samp><code>x</code></samp> and
      <samp><code>y</code></samp>.
    </para><varlist><varlistentry><term>
	  <code>n</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of points defining line.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>x</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array with x coordinates of points.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>y</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array with y coordinates of points.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plline3; Draw a line in 3 space&#10;    " previous="&#10;      plline; Draw a line&#10;    " next="&#10;      pllsty; Select line style&#10;    " up="The Common API for PLplot"/><section>
      plline3: Draw a line in 3 space
    </section><para>
      <quotation><para><t>
           <b>plline3</b>
        (<i>n</i>, <i>x</i>, <i>y</i>, <i>z</i>);</t></para></quotation>
    </para><para>
      Draws line in 3 space defined by <samp><code>n</code></samp>
      points in
      <samp><code>x</code></samp>,
      <samp><code>y</code></samp>, and
      <samp><code>z</code></samp>.
      You must first set up the viewport, the
      2d viewing window (in world coordinates), and the 3d normalized
      coordinate box.  See <file>x18c.c</file> for more info.
    </para><varlist><varlistentry><term>
	  <code>n</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of points defining line.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>x</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array with x coordinates of points.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>y</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array with y coordinates of points.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>z</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array with z coordinates of points.
	  </para></listitem></varlistentry></varlist><node name="&#10;      pllsty; Select line style&#10;    " previous="&#10;      plline3; Draw a line in 3 space&#10;    " next="&#10;      plmesh; Plot surface mesh&#10;    " up="The Common API for PLplot"/><section>
      pllsty: Select line style
    </section><para>
      <quotation><para><t>
	  <b>pllsty</b>
	(<i>n</i>);</t></para></quotation>
    </para><para>
      This sets the line style according to one of eight predefined
      patterns (also see <code>plstyl</code> (<pxref node="&#10;      plstyl; Set line style&#10;    " file=""/>)).
    </para><varlist><varlistentry><term>
	  <code>n</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Integer value between 1 and 8. Line style 1 is a continuous line,
	    line style 2 is a line with short dashes and gaps, line style 3 is
	    a line with long dashes and gaps, line style 4 has long dashes and
	    short gaps and so on.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plmesh; Plot surface mesh&#10;    " previous="&#10;      pllsty; Select line style&#10;    " next="&#10;      plmeshc; Magnitude colored plot surface mesh with contour_&#10;    " up="The Common API for PLplot"/><section>
      plmesh: Plot surface mesh
    </section><para>
      <quotation><para><t>
	  <b>plmesh</b>
	(<i>x</i>, <i>y</i>, <i>z</i>, <i>nx</i>, <i>ny</i>, <i>opt</i>);</t></para></quotation>
    </para><para>
      Plots a surface mesh within the environment set up by <code>plw3d</code> (<pxref node="&#10;      plw3d; Set up window for 3-d plotting&#10;    " file=""/>).  The
      surface is defined by the two-dimensional array
      <samp><code>z</code>[<code>nx</code>][<code>ny</code>]</samp>,
      the point <samp><code>z</code>[i][j]</samp> being the
      value of the function at <samp>(<code>x</code>[i],
      <code>y</code>[j])</samp>.  Note that the points in
      arrays <samp><code>x</code></samp> and
      <samp><code>y</code></samp> do not need to be equally
      spaced, but must be stored in ascending order.  The parameter
      <samp><code>opt</code></samp> controls the way in
      which the surface is displayed.  For further details see <ref node="Three Dimensional Surface Plots" file="">Three Dimensional Surface Plots</ref>.
    </para><varlist><varlistentry><term>
	  <code>x</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to set of x coordinate values at which the function is
	    evaluated.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>y</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to set of y coordinate values at which the function is
	    evaluated.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>z</code>
	  (<samp>PLFLT **</samp>, input)
	</term><listitem><para>
	    Pointer to a vectored two-dimensional array with set of
	    function values.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nx</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of <samp><code>x</code></samp> values at
	    which function is evaluated.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ny</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of <samp><code>y</code></samp> values at
	    which function is evaluated.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>opt</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Determines the way in which the surface is represented:
	    <itemize markchar="•"><listitem><para>
		  <samp><code>opt</code>=DRAW_LINEX</samp>: Lines
		  are drawn showing
		  <samp><code>z</code></samp> as a function
		  of <samp><code>x</code></samp> for each
		  value of <samp><code>y</code>[j]</samp>.
		</para></listitem><listitem><para>
		  <samp><code>opt</code>=DRAW_LINEY</samp>: Lines
		  are drawn showing
		  <samp><code>z</code></samp> as a function
		  of <samp><code>y</code></samp> for each
		  value of <samp><code>x</code>[i]</samp>.
		</para></listitem><listitem><para>
		  <samp><code>opt</code>=DRAW_LINEXY</samp>: Network
		  of lines is drawn connecting points at which function is
		  defined.
		</para></listitem></itemize>
	  </para></listitem></varlistentry></varlist><node name="&#10;      plmeshc; Magnitude colored plot surface mesh with contour_&#10;    " previous="&#10;      plmesh; Plot surface mesh&#10;    " next="&#10;      plmkstrm; Creates a new stream and makes it the&#10;default&#10;    " up="The Common API for PLplot"/><section>
      plmeshc: Magnitude colored plot surface mesh with contour.
    </section><para>
      <quotation><para><t>
	  <b>plmeshc</b>
	(<i>x</i>, <i>y</i>, <i>z</i>, <i>nx</i>, <i>ny</i>, <i>opt</i>, <i>clevel</i>, <i>nlevel</i>);</t></para></quotation>
    </para><para>
    Identical to <code>plmesh</code> but with extra functionalities:
    the surface mesh can be colored accordingly to the current z value being plotted,
    a contour plot can be drawn at the base XY plane, and a curtain can be drawn between
    the plotted function border and the base XY plane.
    </para><varlist><varlistentry><term>
	  <code>x</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to set of x coordinate values at which the function is
	    evaluated.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>y</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to set of y coordinate values at which the function is
	    evaluated.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>z</code>
	  (<samp>PLFLT **</samp>, input)
	</term><listitem><para>
	    Pointer to a vectored two-dimensional array with set of
	    function values.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nx</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of <samp><code>x</code></samp> values at
	    which function is evaluated.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ny</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of <samp><code>y</code></samp> values at
	    which function is evaluated.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>opt</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Determines the way in which the surface is represented. To specify
            more than one option just add the options, e.g. DRAW_LINEXY + MAG_COLOR
	    <itemize markchar="•"><listitem><para>
		  <samp><code>opt</code>=DRAW_LINEX</samp>: Lines
		  are drawn showing
		  <samp><code>z</code></samp> as a function
		  of <samp><code>x</code></samp> for each
		  value of <samp><code>y</code>[j]</samp>.
		</para></listitem><listitem><para>
		  <samp><code>opt</code>=DRAW_LINEY</samp>: Lines
		  are drawn showing
		  <samp><code>z</code></samp> as a function
		  of <samp><code>y</code></samp> for each
		  value of <samp><code>x</code>[i]</samp>.
		</para></listitem><listitem><para>
		  <samp><code>opt</code>=DRAW_LINEXY</samp>: Network
		  of lines is drawn connecting points at which function is
		  defined.
		</para></listitem><listitem><para>
		  <samp><code>opt</code>=MAG_COLOR</samp>: Each line
                  in the mesh is colored according to the z value being plotted. The
                  color is used from the current colormap 1.
		</para></listitem><listitem><para>
		  <samp><code>opt</code>=BASE_CONT</samp>: A contour
                  plot is drawn at the base XY plane using parameters
                  <code>nlevel</code> and <code>clevel</code>.
		</para></listitem><listitem><para>
		  <samp><code>opt</code>=DRAW_SIDES</samp>: draws a curtain
                  between the base XY plane and the borders of the plotted function.
		</para></listitem></itemize>
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>clevel</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to the array that defines the contour level spacing.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nlevel</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
          Number of elements in the <samp>clevel</samp> array.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plmkstrm; Creates a new stream and makes it the&#10;default&#10;    " previous="&#10;      plmeshc; Magnitude colored plot surface mesh with contour_&#10;    " next="&#10;      plmtex; Write text relative to viewport boundaries&#10;    " up="The Common API for PLplot"/><section>
      plmkstrm: Creates a new stream and makes it the
default
    </section><para>
      <quotation><para><t>
           <b>plmkstrm</b>
        (<i>p_strm</i>);</t></para></quotation>
    </para><para>
      Creates a new stream and makes it the default.  Differs from using
      <code>plsstrm</code> (<pxref node="&#10;      plsstrm; Set current output stream&#10;    " file=""/>), in that a free stream number is found, and returned.
      Unfortunately, I <i>have</i> to start at stream 1 and work upward, since
      stream 0 is preallocated.  One of the <i>big</i> flaws in the PLplot API is
      that no initial, library-opening call is required.  So stream 0 must
      be preallocated, and there is no simple way of determining whether it
      is already in use or not.
    </para><varlist><varlistentry><term>
	  <code>p_strm</code>
	  (<samp>PLINT *</samp>, output)
	</term><listitem><para>
            Pointer to stream number of the created stream.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plmtex; Write text relative to viewport boundaries&#10;    " previous="&#10;      plmkstrm; Creates a new stream and makes it the&#10;default&#10;    " next="&#10;      plot3d; Plot 3-d surface plot&#10;    " up="The Common API for PLplot"/><section>
      plmtex: Write text relative to viewport boundaries
    </section><para>
      <quotation><para><t>
	  <b>plmtex</b>
	(<i>side</i>, <i>disp</i>, <i>pos</i>, <i>just</i>, <i>text</i>);</t></para></quotation>
    </para><para>
      Writes text at a specified position relative to the viewport
      boundaries.  Text may be written inside or outside the viewport, but
      is clipped at the subpage boundaries.  The reference point of a
      string lies along a line passing through the string at half the
      height of a capital letter.  The position of the reference point
      along this line is determined by
      <samp><code>just</code></samp>, and the position of
      the reference point relative to the viewport is set by
      <samp><code>disp</code></samp> and
      <samp><code>pos</code></samp>.
    </para><varlist><varlistentry><term>
	  <code>side</code>
	  (<samp>const char *</samp>, input)
	</term><listitem><para>
	    Specifies the side of the viewport along which the text is to
	    be written. The string must be one of:
	    <itemize markchar="•"><listitem><para>
		  <samp>b</samp>: Bottom of viewport, text written
		  parallel to edge.
		</para></listitem><listitem><para>
		  <samp>bv</samp>: Bottom of viewport, text written at
		  right angles to edge.
		</para></listitem><listitem><para>
		  <samp>l</samp>: Left of viewport, text written
		  parallel to edge.
		</para></listitem><listitem><para>
		  <samp>lv</samp>: Left of viewport, text written at
		  right angles to edge.
		</para></listitem><listitem><para>
		  <samp>r</samp>: Right of viewport, text written
		  parallel to edge.
		</para></listitem><listitem><para>
		  <samp>rv</samp>: Right of viewport, text written at
		  right angles to edge.
		</para></listitem><listitem><para>
		  <samp>t</samp>: Top of viewport, text written
		  parallel to edge.
		</para></listitem><listitem><para>
		  <samp>tv</samp>: Top of viewport, text written at
		  right angles to edge.
		</para></listitem></itemize>
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>disp</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    Position of the reference point of string, measured outwards
	    from the specified viewport edge in units of the current
	    character height.  Use negative
	    <samp><code>disp</code></samp> to write within
	    the viewport.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>pos</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    Position of the reference point of string along the specified
	    edge, expressed as a fraction of the length of the edge.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>just</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    Specifies the position of the string relative to its reference
	    point.  If <samp><code>just</code>=0</samp>,
	    the reference point is at the left and if
	    <samp><code>just</code>=1</samp>, it is at the
	    right of the string.  Other values of
	    <samp><code>just</code></samp> give
	    intermediate justifications.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>text</code>
	  (<samp>const char *</samp>, input)
	</term><listitem><para>
	    The string to be written out.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plot3d; Plot 3-d surface plot&#10;    " previous="&#10;      plmtex; Write text relative to viewport boundaries&#10;    " next="&#10;      plot3dc; Magnitude colored plot surface with contour_&#10;    " up="The Common API for PLplot"/><section>
      plot3d: Plot 3-d surface plot
    </section><para>
      <quotation><para><t>
	  <b>plot3d</b>
	(<i>x</i>, <i>y</i>, <i>z</i>, <i>nx</i>, <i>ny</i>, <i>opt</i>, <i>side</i>);</t></para></quotation>
    </para><para>
      Plots a three dimensional surface plot within the environment set up
      by <code>plw3d</code> (<pxref node="&#10;      plw3d; Set up window for 3-d plotting&#10;    " file=""/>).  The surface is defined by the two-dimensional array
      <samp><code>z</code>[<code>nx</code>][<code>ny</code>]</samp>,
      the point <samp><code>z</code>[i][j]</samp> being the
      value of the function at <samp>(<code>x</code>[i],
      <code>y</code>[j])</samp>.  Note that the points in
      arrays <samp><code>x</code></samp> and
      <samp><code>y</code></samp> do not need to be equally
      spaced, but must be stored in ascending order.  The parameter
      <samp><code>opt</code></samp> controls the way in
      which the surface is displayed.  For further details see <ref node="Three Dimensional Surface Plots" file="">Three Dimensional Surface Plots</ref>.
      The only difference between <code>plmesh</code> (<pxref node="&#10;      plmesh; Plot surface mesh&#10;    " file=""/>) and <code>plot3d</code> (<pxref node="&#10;      plot3d; Plot 3-d surface plot&#10;    " file=""/>) is that <code>plmesh</code> (<pxref node="&#10;      plmesh; Plot surface mesh&#10;    " file=""/>) draws
      the botton side of the surface, while <code>plot3d</code> (<pxref node="&#10;      plot3d; Plot 3-d surface plot&#10;    " file=""/>) only draws the surface as
      viewed from the top.
    </para><varlist><varlistentry><term>
	  <code>x</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to set of x coordinate values at which the function is
	    evaluated.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>y</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to set of y coordinate values at which the function is
	    evaluated.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>z</code>
	  (<samp>PLFLT **</samp>, input)
	</term><listitem><para>
	    Pointer to a vectored two-dimensional array with set of
	    function values.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nx</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of <samp><code>x</code></samp> values at
	    which function is evaluated.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ny</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of <samp><code>y</code></samp> values at
	    which function is evaluated.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>opt</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Determines the way in which the surface is represented:
	    <itemize markchar="•"><listitem><para>
		  <samp><code>opt</code>=DRAW_LINEX</samp>: Lines
		  are drawn showing
		  <samp><code>z</code></samp> as a function
		  of <samp><code>x</code></samp> for each
		  value of <samp><code>y</code>[j]</samp>.
		</para></listitem><listitem><para>
		  <samp><code>opt</code>=DRAW_LINEY</samp>: Lines
		  are drawn showing
		  <samp><code>z</code></samp> as a function
		  of <samp><code>y</code></samp> for each
		  value of <samp><code>x</code>[i]</samp>.
		</para></listitem><listitem><para>
		  <samp><code>opt</code>=DRAW_LINEXY</samp>: Network
		  of lines is drawn connecting points at which function is
		  defined.
		</para></listitem></itemize>
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>side</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Flag to indicate whether or not ``sides'' should be draw on the
	    figure.  If <samp><code>side</code>=0</samp> no
	    sides are drawn, otherwise the sides are drawn.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plot3dc; Magnitude colored plot surface with contour_&#10;    " previous="&#10;      plot3d; Plot 3-d surface plot&#10;    " next="&#10;      plparseopts; Parse command-line arguments&#10;    " up="The Common API for PLplot"/><section>
      plot3dc: Magnitude colored plot surface with contour.
    </section><para>
      <quotation><para><t>
	  <b>plot3dc</b>
	(<i>x</i>, <i>y</i>, <i>z</i>, <i>nx</i>, <i>ny</i>, <i>opt</i>, <i>clevel</i>, <i>nlevel</i>);</t></para></quotation>
    </para><para>
    Identical to <code>plot3d</code> but with extra functionalities:
    the surface mesh can be colored accordingly to the current z value being plotted,
    a contour plot can be drawn at the base XY plane, and a curtain can be drawn between
    the plotted function border and the base XY plane.
    The arguments are identical to <code>plmeshc</code>. The only difference between
    <code>plmeshc</code> (<pxref node="&#10;      plmeshc; Magnitude colored plot surface mesh with contour_&#10;    " file=""/>) and <code>plot3dc</code> (<pxref node="&#10;      plot3dc; Magnitude colored plot surface with contour_&#10;    " file=""/>) is that <code>plmeshc</code> (<pxref node="&#10;      plmeshc; Magnitude colored plot surface mesh with contour_&#10;    " file=""/>) draws the botton side of the surface, while
    <code>plot3dc</code> (<pxref node="&#10;      plot3dc; Magnitude colored plot surface with contour_&#10;    " file=""/>) only draws the surface as viewed from the top.
    </para><node name="&#10;      plparseopts; Parse command-line arguments&#10;    " previous="&#10;      plot3dc; Magnitude colored plot surface with contour_&#10;    " next="&#10;      plpat; Set area fill pattern&#10;    " up="The Common API for PLplot"/><section>
      plparseopts: Parse command-line arguments
    </section><para>
      <quotation><para><t>
	  <b>plparseopts</b>
	(<i>p_argc</i>, <i>argv</i>, <i>mode</i>);</t></para></quotation>
    </para><para>
    Parse command-line arguments.
    </para><varlist><varlistentry><term>
	  <code>p_argc</code>
	  (<samp>int *</samp>, input)
	</term><listitem><para>
	    pointer to number of arguments.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>argv</code>
	  (<samp>char **</samp>, input)
	</term><listitem><para>
	    Pointer to character array containing
	    <samp><code>*p_argc</code></samp> command-line
	    arguments.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>mode</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Parsing mode with the following possibilities:
<itemize markchar="•"><listitem><para>
PL_PARSE_FULL (1) -- Full parsing of command line and all error messages
enabled, including program exit when an error occurs.  Anything on the
command line that isn't recognized as a valid option or option argument is
flagged as an error.
</para></listitem><listitem><para>
PL_PARSE_QUIET (2) -- Turns off all output except in the case of errors.
</para></listitem><listitem><para>
PL_PARSE_NODELETE (4) -- Turns off deletion of processed arguments.
</para></listitem><listitem><para>
PL_PARSE_SHOWALL (8) -- Show invisible options
</para></listitem><listitem><para>
PL_PARSE_NOPROGRAM (32) -- Specified if argv[0] is NOT a pointer to the
program name.
</para></listitem><listitem><para>
PL_PARSE_NODASH (64) -- Set if leading dash is NOT required.
</para></listitem><listitem><para>
PL_PARSE_SKIP (128) -- Set to quietly skip over any unrecognized args.
</para></listitem></itemize>
	  </para></listitem></varlistentry></varlist><node name="&#10;      plpat; Set area fill pattern&#10;    " previous="&#10;      plparseopts; Parse command-line arguments&#10;    " next="&#10;      plpoin; Plots a character at the specified points&#10;    " up="The Common API for PLplot"/><section>
      plpat: Set area fill pattern
    </section><para>
      <quotation><para><t>
	  <b>plpat</b>
	(<i>nlin</i>, <i>inc</i>, <i>del</i>);</t></para></quotation>
    </para><para>
      Sets the area fill pattern.  The pattern consists of 1 or 2 sets of
      parallel lines with specified inclinations and spacings.  The
      arguments to this routine are the number of sets to use (1 or 2)
      followed by two pointers to integer arrays (of 1 or 2 elements)
      specifying the inclinations in tenths of a degree and the spacing in
      micrometers.  (also see <code>plpsty</code> (<pxref node="&#10;      plpsty; Select area fill pattern&#10;    " file=""/>))
    </para><varlist><varlistentry><term>
	  <code>nlin</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of sets of lines making up the pattern, either 1 or 2.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>inc</code>
	  (<samp>PLINT *</samp>, input)
	</term><listitem><para>
	    Pointer to array with
	    <samp><code>nlin</code></samp> elements.
	    Specifies the line inclination in tenths of a degree.  (Should
	    be between -900 and 900).
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>del</code>
	  (<samp>PLINT *</samp>, input)
	</term><listitem><para>
	    Pointer to array with
	    <samp><code>nlin</code></samp> elements.
	    Specifies the spacing in micrometers between the lines making
	    up the pattern.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plpoin; Plots a character at the specified points&#10;    " previous="&#10;      plpat; Set area fill pattern&#10;    " next="&#10;      plpoin3;  Plots a character at the specified&#10;      points in 3 space&#10;    " up="The Common API for PLplot"/><section>
      plpoin: Plots a character at the specified points
    </section><para>
      <quotation><para><t>
	  <b>plpoin</b>
	(<i>n</i>, <i>x</i>, <i>y</i>, <i>code</i>);</t></para></quotation>
    </para><para>
      Marks a set of <samp><code>n</code></samp>
      points in
      <samp><code>x</code></samp> and
      <samp><code>y</code></samp> using
      the symbol defined by
      <samp><code>code</code></samp>.
      If
      <samp><code>code</code></samp> is between 32 and 127,
      the symbol is simply the corresponding printable ASCII character
      in the default font.
    </para><varlist><varlistentry><term>
	  <code>n</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of points to be marked.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>x</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array with x coordinates of the points.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>y</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array with y coordinates of the points.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>code</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Code number for the symbol to be plotted.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plpoin3;  Plots a character at the specified&#10;      points in 3 space&#10;    " previous="&#10;      plpoin; Plots a character at the specified points&#10;    " next="&#10;      plpoly3; Draw a polygon in 3 space&#10;    " up="The Common API for PLplot"/><section>
      plpoin3:  Plots a character at the specified
      points in 3 space
    </section><para>
      <quotation><para><t>
           <b>plpoin3</b>
        (<i>n</i>, <i>x</i>, <i>y</i>, <i>z</i>, <i>code</i>);</t></para></quotation>
    </para><para>
      Marks a set of <samp><code>n</code></samp>
      points in
      <samp><code>x</code></samp>,
      <samp><code>y</code></samp>, and
      <samp><code>z</code></samp> using
      the symbol defined by
      <samp><code>code</code></samp>.
      If
      <samp><code>code</code></samp> is between 32 and 127,
      the symbol is simply the corresponding printable ASCII character
      in the default font.
       Setup similar to <code>plline3</code> (<pxref node="&#10;      plline3; Draw a line in 3 space&#10;    " file=""/>).
    </para><varlist><varlistentry><term>
	  <code>n</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Number of points to be marked.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>x</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array with x coordinates of the points.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>y</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array with y coordinates of the points.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>z</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array with z coordinates of the points.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>code</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Code number for the symbol to be plotted.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plpoly3; Draw a polygon in 3 space&#10;    " previous="&#10;      plpoin3;  Plots a character at the specified&#10;      points in 3 space&#10;    " next="&#10;      plprec; Set precision in numeric labels&#10;    " up="The Common API for PLplot"/><section>
      plpoly3: Draw a polygon in 3 space
    </section><para>
      <quotation><para><t>
           <b>plpoly3</b>
        (<i>n</i>, <i>x</i>, <i>y</i>, <i>z</i>, <i>draw</i>, <i>ifcc</i>);</t></para></quotation>
    </para><para>
      Draws a polygon in 3 space defined by <samp><code>n</code></samp>
      points in
      <samp><code>x</code></samp>,
      <samp><code>y</code></samp>, and
      <samp><code>z</code></samp>.
      Setup like <code>plline3</code> (<pxref node="&#10;      plline3; Draw a line in 3 space&#10;    " file=""/>), but differs from that function in that <code>plpoly3</code> (<pxref node="&#10;      plpoly3; Draw a polygon in 3 space&#10;    " file=""/>)
      attempts to determine if the polygon is viewable depending on the
      order of the points within the arrays and the value of
      <samp><code>ifcc</code></samp>.  If the back of
      polygon is facing the viewer, then it isn't drawn.  If this isn't what
      you want, then use <code>plline3</code> (<pxref node="&#10;      plline3; Draw a line in 3 space&#10;    " file=""/>) instead.
    </para><para>
      The points are assumed to be in a plane, and the directionality of
      the plane is determined from the first three points.  Additional
      points do not <i>have</i> to lie on the plane defined
      by the first three, but if they do not, then the determination of
      visibility obviously can't be 100% accurate... So if you're 3 space
      polygons are too far from planar, consider breaking them into smaller
      polygons.  3 points define a plane :-).
    </para><para>
      <i>Bugs</i>:  If one of the first two segments is of
      zero length, or if they are colinear, the calculation of visibility
      has a 50/50 chance of being correct.  Avoid such situations :-).  See
      <file>x18c.c</file> for an example of this problem.
      (Search for 20.1).
    </para><varlist><varlistentry><term>
	  <code>n</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of points defining line.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>x</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array with x coordinates of points.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>y</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array with y coordinates of points.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>z</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array with z coordinates of points.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>draw</code>
	  (<samp>PLINT *</samp>, input)
	</term><listitem><para>
            Pointer to array which controls drawing the segments of the
	    polygon.  If <samp><code>draw[i]</code></samp> is true,
	    then the polygon segment from index
	    <samp><code>[i]</code></samp> to
	    <samp><code>[i+1]</code></samp> is drawn, otherwise, not.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ifcc</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
      If <samp><code>ifcc</code>=1</samp>
      the directionality of the polygon is determined by assuming the points
      are laid out in a counter-clockwise order.
      If <samp><code>ifcc</code>=0</samp>
      the directionality of the polygon is determined by assuming the points
      are laid out in a clockwise order.
    </para></listitem></varlistentry></varlist><node name="&#10;      plprec; Set precision in numeric labels&#10;    " previous="&#10;      plpoly3; Draw a polygon in 3 space&#10;    " next="&#10;      plpsty; Select area fill pattern&#10;    " up="The Common API for PLplot"/><section>
      plprec: Set precision in numeric labels
    </section><para>
      <quotation><para><t>
	  <b>plprec</b>
	(<i>set</i>, <i>prec</i>);</t></para></quotation>
    </para><para>
      Sets the number of places after the decimal point in numeric labels.
    </para><varlist><varlistentry><term>
	  <code>set</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    If <samp><code>set</code></samp> is equal to 0
	    then PLplot automatically determines the number of places to
	    use after the decimal point in numeric labels (like those used
	    to label axes).  If
	    <samp><code>set</code></samp> is 1 then
	    <samp><code>prec</code></samp> sets the number
	    of places.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>prec</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    The number of characters to draw after the decimal point in
	    numeric labels.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plpsty; Select area fill pattern&#10;    " previous="&#10;      plprec; Set precision in numeric labels&#10;    " next="&#10;      plptex; Write text inside the viewport&#10;    " up="The Common API for PLplot"/><section>
      plpsty: Select area fill pattern
    </section><para>
      <quotation><para><t>
	  <b>plpsty</b>
	(<i>n</i>);</t></para></quotation>
    </para><para>
      Select one of eight predefined area fill patterns to use (also see
      <code>plpat</code> (<pxref node="&#10;      plpat; Set area fill pattern&#10;    " file=""/>)).
    </para><varlist><varlistentry><term>
	  <code>n</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    The desired pattern. Pattern 1 consists of horizontal lines,
	    pattern 2 consists of vertical lines, pattern 3 consists of lines
	    at 45 degrees angle (upward), and so on.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plptex; Write text inside the viewport&#10;    " previous="&#10;      plpsty; Select area fill pattern&#10;    " next="&#10;      plreplot; Replays contents of plot buffer to&#10;current device/file&#10;    " up="The Common API for PLplot"/><section>
      plptex: Write text inside the viewport
    </section><para>
      <quotation><para><t>
	  <b>plptex</b>
	(<i>x</i>, <i>y</i>, <i>dx</i>, <i>dy</i>, <i>just</i>, <i>text</i>);</t></para></quotation>
    </para><para>
      Writes text at a specified position and inclination within the
      viewport.  Text is clipped at the viewport boundaries.  The reference
      point of a string lies along a line passing through the string at
      half the height of a capital letter.  The position of the reference
      point along this line is determined by
      <samp><code>just</code></samp>, the reference point
      is placed at world coordinates <samp>(<code>x</code>,
      <code>y</code>)</samp> within the viewport.  The
      inclination of the string is specified in terms of differences of
      world coordinates making it easy to write text parallel to a line in
      a graph.
    </para><varlist><varlistentry><term>
	  <code>x</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    x coordinate of reference point of string.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>y</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    y coordinate of reference point of string.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>dx</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    Together with <samp><code>dy</code></samp>,
	    this specifies the inclination of the string.  The baseline of
	    the string is parallel to a line joining
	    <samp>(<code>x</code>,
	    <code>y</code>)</samp> to
	    <samp>(<code>x</code>+<code>dx</code>,
	    <code>y</code>+<code>dy</code>)</samp>.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>dy</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    Together with <samp><code>dx</code></samp>,
	    this specifies the inclination of the string.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>just</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    Specifies the position of the string relative to its reference
	    point.  If <samp><code>just</code>=0</samp>,
	    the reference point is at the left and if
	    <samp><code>just</code>=1</samp>, it is at the
	    right of the string.  Other values of
	    <samp><code>just</code></samp> give
	    intermediate justifications.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>text</code>
	  (<samp>const char *</samp>, input)
	</term><listitem><para>
	    The string to be written out.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plreplot; Replays contents of plot buffer to&#10;current device/file&#10;    " previous="&#10;      plptex; Write text inside the viewport&#10;    " next="&#10;      plrgbhls; Convert RGB color to HLS&#10;    " up="The Common API for PLplot"/><section>
      plreplot: Replays contents of plot buffer to
current device/file
    </section><para>
      <quotation><para><t>
	  <b>plreplot</b>
        ();</t></para></quotation>
    </para><para>
      Replays contents of plot buffer to current device/file.
    </para><node name="&#10;      plrgbhls; Convert RGB color to HLS&#10;    " previous="&#10;      plreplot; Replays contents of plot buffer to&#10;current device/file&#10;    " next="&#10;      plschr; Set character size&#10;    " up="The Common API for PLplot"/><section>
      plrgbhls: Convert RGB color to HLS
    </section><para>
      <quotation><para><t>
           <b>plrgbhls</b>
        (<i>r</i>, <i>g</i>, <i>b</i>, <i>p_h</i>, <i>p_l</i>, <i>p_s</i>);</t></para></quotation>
    </para><para>
      Convert RGB color coordinates to HLS
    </para><varlist><varlistentry><term>
	  <code>r</code>
	  (<samp>PLFLT</samp>, output)
	</term><listitem><para>
            Red intensity (0.0-1.0) of the colour
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>g</code>
	  (<samp>PLFLT</samp>, output)
	</term><listitem><para>
            Green intensity (0.0-1.0) of the colour
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>b</code>
	  (<samp>PLFLT</samp>, output)
	</term><listitem><para>
            Blue intensity (0.0-1.0) of the colour
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>p_h</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
            Pointer to hue, in degrees on the colour cone (0.0-360.0)
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>p_l</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
            Pointer to lightness, expressed as a fraction of the axis of the colour
            cone (0.0-1.0)
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>p_s</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
            Pointer to saturation, expressed as a fraction of the radius of the
            colour cone (0.0-1.0)
	  </para></listitem></varlistentry></varlist><node name="&#10;      plschr; Set character size&#10;    " previous="&#10;      plrgbhls; Convert RGB color to HLS&#10;    " next="&#10;      plscmap0; Set color map0 colors by 8-bit RGB&#10;values&#10;    " up="The Common API for PLplot"/><section>
      plschr: Set character size
    </section><para>
      <quotation><para><t>
	  <b>plschr</b>
	(<i>def</i>, <i>scale</i>);</t></para></quotation>
    </para><para>
      This sets up the size of all subsequent characters drawn.  The actual
      height of a character is the product of the default character size
      and a scaling factor.
    </para><varlist><varlistentry><term>
	  <code>def</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The default height of a character in millimeters, should be set
	    to zero if the default height is to remain unchanged.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>scale</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    Scale factor to be applied to default to get actual character
	    height.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plscmap0; Set color map0 colors by 8-bit RGB&#10;values&#10;    " previous="&#10;      plschr; Set character size&#10;    " next="&#10;      plscmap0n; Set number of colors in color map0&#10;    " up="The Common API for PLplot"/><section>
      plscmap0: Set color map0 colors by 8-bit RGB
values
    </section><para>
      <quotation><para><t>
           <b>plscmap0</b>
        (<i>r</i>, <i>g</i>, <i>b</i>, <i>ncol0</i>);</t></para></quotation>
    </para><para>
      Set color map0 colors using 8-bit RGB values (see <ref node="Color Map0" file="">Color Map0</ref>).  This sets the entire color
       map -- only as many colors as specified will be allocated.
    </para><varlist><varlistentry><term>
	  <code>r</code>
	  (<samp>PLINT *</samp>, input)
	</term><listitem><para>
            Pointer to array with set of unsigned 8-bit integers (0-255)
	    representing the degree of red in the color.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>g</code>
	  (<samp>PLINT *</samp>, input)
	</term><listitem><para>
            Pointer to array with set of unsigned 8-bit integers (0-255)
	    representing the degree of green in the color.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>b</code>
	  (<samp>PLINT *</samp>, input)
	</term><listitem><para>
            Pointer to array with set of unsigned 8-bit integers (0-255)
	    representing the degree of blue in the color.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ncol0</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Number of items in the
	    <samp><code>r</code></samp>,
	    <samp><code>g</code></samp>, and
	    <samp><code>b</code></samp> arrays.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plscmap0n; Set number of colors in color map0&#10;    " previous="&#10;      plscmap0; Set color map0 colors by 8-bit RGB&#10;values&#10;    " next="&#10;      plscmap1; Set color map1 colors using 8-bit RGB&#10;values&#10;    " up="The Common API for PLplot"/><section>
      plscmap0n: Set number of colors in color map0
    </section><para>
      <quotation><para><t>
           <b>plscmap0n</b>
        (<i>ncol0</i>);</t></para></quotation>
    </para><para> Set number of colors in color map0 (see <ref node="Color Map0" file="">Color Map0</ref>). Allocate (or reallocate) color map0,
      and fill with default values for those colors not previously allocated.
      The first 16 default colors are given in the <code>plcol0</code> (<pxref node="&#10;      plcol0; Set color; map0&#10;    " file=""/>) documentation.
      For larger indices the default color is red. </para><para>
      The drivers are not guaranteed to support more than 16 colors.
    </para><varlist><varlistentry><term>
	  <code>ncol0</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Number of colors that will be allocated in the map0 palette.
	    If this number is zero or less, then the value from the
	    previous call to <code>plscmap0n</code> (<pxref node="&#10;      plscmap0n; Set number of colors in color map0&#10;    " file=""/>) is used and if there is no
	    previous call, then a default value is used.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plscmap1; Set color map1 colors using 8-bit RGB&#10;values&#10;    " previous="&#10;      plscmap0n; Set number of colors in color map0&#10;    " next="&#10;      plscmap1l; Set color map1 colors using a&#10;piece-wise linear relationship&#10;    " up="The Common API for PLplot"/><section>
      plscmap1: Set color map1 colors using 8-bit RGB
values
    </section><para>
      <quotation><para><t>
           <b>plscmap1</b>
        (<i>r</i>, <i>g</i>, <i>b</i>, <i>ncol1</i>);</t></para></quotation>
    </para><para> Set color map1 colors using 8-bit RGB values (see <ref node="Color Map1" file="">Color Map1</ref>).  This also sets the number of colors.
      </para><varlist><varlistentry><term>
	  <code>r</code>
	  (<samp>PLINT *</samp>, input)
	</term><listitem><para>
            Pointer to array with set of unsigned 8-bit integers (0-255)
	    representing the degree of red in the color.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>g</code>
	  (<samp>PLINT *</samp>, input)
	</term><listitem><para>
            Pointer to array with set of unsigned 8-bit integers (0-255)
	    representing the degree of green in the color.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>b</code>
	  (<samp>PLINT *</samp>, input)
	</term><listitem><para>
            Pointer to array with set of unsigned 8-bit integers (0-255)
	    representing the degree of blue in the color.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ncol1</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Number of items in the
	    <samp><code>r</code></samp>,
	    <samp><code>g</code></samp>, and
	    <samp><code>b</code></samp> arrays.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plscmap1l; Set color map1 colors using a&#10;piece-wise linear relationship&#10;    " previous="&#10;      plscmap1; Set color map1 colors using 8-bit RGB&#10;values&#10;    " next="&#10;      plscmap1n; Set number of colors in color map1&#10;    " up="The Common API for PLplot"/><section>
      plscmap1l: Set color map1 colors using a
piece-wise linear relationship
    </section><para>
      <quotation><para><t>
           <b>plscmap1l</b>
        (<i>itype</i>, <i>npts</i>, <i>pos</i>, <i>coord1</i>, <i>coord2</i>, <i>coord3</i>, <i>rev</i>);</t></para></quotation>
    </para><para> Set color map1 colors using a piece-wise linear relationship
      between position in the color map (from 0 to 1) and position in HLS or
      RGB color space (see <ref node="Color Map1" file="">Color Map1</ref>).  May be called at
      any time. </para><para>
      The idea here is to specify a number of control points that define
      the mapping between palette 1 input positions (intensities) and HLS (or RGB).  Between
      these points, linear interpolation is used which
      gives a smooth variation of
      color with input position.  Any number of control points may be specified,
      located at arbitrary positions, although typically 2 - 4
      are enough. Another way of stating this is that we are traversing a
      given number of lines through HLS (or RGB) space as we move through
      color map1 entries.  The control points at the minimum and maximum
      position (0 and 1) must always be specified.  By adding more control
      points you can get more variation.  One good technique for plotting
      functions that vary about some expected average is to use an
      additional 2 control points in the center (position ~= 0.5) that are
      the same lightness as the background (typically white for paper output,
      black for crt), and same hue as the boundary control points.  This
      allows the highs and lows to be very easily distinguished.
    </para><para>
      Each control point must specify the position in color map1 as well as
      three coordinates in HLS or RGB space.  The first point
      <i>must</i> correspond to position = 0, and the last to
      position = 1.
    </para><para> The hue is interpolated around the "front" of the color wheel
      (red&lt;-&gt;green&lt;-&gt;blue&lt;-&gt;red) unless the "rev" flag is set, in
      which case interpolation (between the <samp>i</samp> and
      <samp>i + 1</samp> control point for <samp>rev[i]</samp>)
      proceeds around the back (reverse) side.  Specifying rev=NULL is
      equivalent to setting rev[]=0 for every control point. </para><para>
<para><strong> Bounds on coordinates</strong></para><multitable cols="4"><tbody><row><entry>RGB</entry><entry>R</entry><entry>[0, 1]</entry><entry>magnitude</entry></row><row><entry>RGB</entry><entry>G</entry><entry>[0, 1]</entry><entry>magnitude</entry></row><row><entry>RGB</entry><entry>B</entry><entry>[0, 1]</entry><entry>magnitude</entry></row><row><entry>HLS</entry><entry>hue</entry><entry>[0, 360]</entry><entry>degrees</entry></row><row><entry>HLS</entry><entry>lightness</entry><entry>[0, 1]</entry><entry>magnitude</entry></row><row><entry>HLS</entry><entry>saturation</entry><entry>[0, 1]</entry><entry>magnitude</entry></row></tbody></multitable>
    </para><varlist><varlistentry><term>
	  <code>itype</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            0: HLS, 1: RGB
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>npts</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            number of control points
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>pos</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
            position for each control point (between 0.0 and 1.0, in
            ascending order)
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>coord1</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
            first coordinate (H or R) for each control point
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>coord2</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
            second coordinate (L or G) for each control point
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>coord3</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
            third coordinate (S or B) for each control point
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>rev</code>
	  (<samp>PLINT *</samp>, input)
	</term><listitem><para>
            reverse flag for each control point (<samp>rev[i]</samp> refers
	    to the interpolation interval between the <samp>i</samp> and
	    <samp>i + 1</samp> control points).
	  </para></listitem></varlistentry></varlist><node name="&#10;      plscmap1n; Set number of colors in color map1&#10;    " previous="&#10;      plscmap1l; Set color map1 colors using a&#10;piece-wise linear relationship&#10;    " next="&#10;      plscol0;  Set a given color from color map0 by 8&#10;bit RGB value&#10;    " up="The Common API for PLplot"/><section>
      plscmap1n: Set number of colors in color map1
    </section><para>
      <quotation><para><t>
           <b>plscmap1n</b>
        (<i>ncol1</i>);</t></para></quotation>
    </para><para> Set number of colors in color map1, (re-)allocate color map1, and
    set default values if this is the first allocation (see <ref node="Color Map1" file="">Color Map1</ref>). </para><varlist><varlistentry><term>
	  <code>ncol1</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Number of colors that will be allocated in the map1 palette.
	    If this number is zero or less, then the value from the
	    previous call to <code>plscmap1n</code> (<pxref node="&#10;      plscmap1n; Set number of colors in color map1&#10;    " file=""/>) is used and if there is no
	    previous call, then a default value is used.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plscol0;  Set a given color from color map0 by 8&#10;bit RGB value&#10;    " previous="&#10;      plscmap1n; Set number of colors in color map1&#10;    " next="&#10;      plscolbg; Set the background color&#10;by 8-bit RGB value&#10;    " up="The Common API for PLplot"/><section>
      plscol0:  Set a given color from color map0 by 8
bit RGB value
    </section><para>
      <quotation><para><t>
           <b>plscol0</b>
        (<i>icol0</i>, <i>r</i>, <i>g</i>, <i>b</i>);</t></para></quotation>
    </para><para> Set a given color by 8-bit RGB value for color map0 (see <ref node="Color Map0" file="">Color Map0</ref>).  Overwrites
    the previous color value for the given index and, thus, does
    not result in any additional allocation of space for colors. </para><varlist><varlistentry><term>
	  <code>icol0</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Color index.  Must be less than the maximum number of colors
	    (which is set by default, by <code>plscmap0n</code> (<pxref node="&#10;      plscmap0n; Set number of colors in color map0&#10;    " file=""/>), or even by <code>plscmap0</code> (<pxref node="&#10;      plscmap0; Set color map0 colors by 8-bit RGB&#10;values&#10;    " file=""/>)).
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>r</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Unsigned 8-bit integer (0-255) representing
	    the degree of red in the color.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>g</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Unsigned 8-bit integer (0-255) representing
	    the degree of green in the color.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>b</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Unsigned 8-bit integer (0-255) representing
	    the degree of blue in the color.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plscolbg; Set the background color&#10;by 8-bit RGB value&#10;    " previous="&#10;      plscol0;  Set a given color from color map0 by 8&#10;bit RGB value&#10;    " next="&#10;      plscolor; Used to globally turn color output on/off&#10;    " up="The Common API for PLplot"/><section>
      plscolbg: Set the background color
by 8-bit RGB value
    </section><para>
      <quotation><para><t>
           <b>plscolbg</b>
        (<i>r</i>, <i>g</i>, <i>b</i>);</t></para></quotation>
    </para><para>
      Set the background color (color 0 in color map 0) by 8-bit RGB value (see
<ref node="Color Map0" file="">Color Map0</ref>).
    </para><varlist><varlistentry><term>
	  <code>r</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Unsigned 8-bit integer (0-255) representing
	    the degree of red in the color.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>g</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Unsigned 8-bit integer (0-255) representing
	    the degree of green in the color.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>b</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Unsigned 8-bit integer (0-255) representing
	    the degree of blue in the color.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plscolor; Used to globally turn color output on/off&#10;    " previous="&#10;      plscolbg; Set the background color&#10;by 8-bit RGB value&#10;    " next="&#10;      plscompression; Set device-compression level&#10;    " up="The Common API for PLplot"/><section>
      plscolor: Used to globally turn color output on/off
    </section><para>
      <quotation><para><t>
           <b>plscolor</b>
        (<i>color</i>);</t></para></quotation>
    </para><para>
      Used to globally turn color output on/off for those drivers/devices
      that support it.
    </para><varlist><varlistentry><term>
	  <code>color</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Color flag (Boolean).  If zero, color is turned off.  If
	    non-zero, color is turned on.
          </para></listitem></varlistentry></varlist><node name="&#10;      plscompression; Set device-compression level&#10;    " previous="&#10;      plscolor; Used to globally turn color output on/off&#10;    " next="&#10;      plsdev; Set the device [keyword] name&#10;    " up="The Common API for PLplot"/><section>
      plscompression: Set device-compression level
    </section><para>
      <quotation><para><t>
	  <b>plscompression</b>
	(<i>compression</i>);</t></para></quotation>
    </para><para>
      Set device-compression level.  Only used for drivers that provide
      compression.  This function, if used, should be invoked
      before a call to <code>plinit</code> (<pxref node="&#10;      plinit; Initialize PLplot&#10;    " file=""/>).
    </para><varlist><varlistentry><term>
	  <code>compression</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    The desired compression level. This is a device-dependent
	    value.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plsdev; Set the device [keyword] name&#10;    " previous="&#10;      plscompression; Set device-compression level&#10;    " next="&#10;      plsdidev; Set parameters that define current&#10;      device-space window&#10;    " up="The Common API for PLplot"/><section>
      plsdev: Set the device (keyword) name
    </section><para>
      <quotation><para><t>
           <b>plsdev</b>
        (<i>devname</i>);</t></para></quotation>
    </para><para>
      Set the device (keyword) name.
    </para><varlist><varlistentry><term>
	  <code>devname</code>
	  (<samp>const char *</samp>, output)
	</term><listitem><para>
            Pointer to device (keyword) name string.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plsdidev; Set parameters that define current&#10;      device-space window&#10;    " previous="&#10;      plsdev; Set the device [keyword] name&#10;    " next="&#10;      plsdimap; Set up transformation from metafile&#10;coordinates&#10;    " up="The Common API for PLplot"/><section>
      plsdidev: Set parameters that define current
      device-space window
    </section><para>
      <quotation><para><t>
           <b>plsdidev</b>
        (<i>mar</i>, <i>aspect</i>, <i>jx</i>, <i>jy</i>);</t></para></quotation>
    </para><para>
      Set relative margin width, aspect ratio, and relative
      justification that define current device-space window.  If you want to just use the previous value for any of
      these, just pass in the magic value PL_NOTSET. It is unlikely that one
      should ever need to change the aspect ratio but it's in there for
      completeness.
      If <code>plsdidev</code> (<pxref node="&#10;      plsdidev; Set parameters that define current&#10;      device-space window&#10;    " file=""/>) is not called the default values
      of <samp><code>mar</code></samp>,
      <samp><code>jx</code></samp>, and
      <samp><code>jy</code></samp>
      are all 0. <samp><code>aspect</code></samp>
      is set to a device-specific value.
    </para><varlist><varlistentry><term>
	  <code>mar</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            Relative margin width.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>aspect</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            Aspect ratio.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>jx</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            Relative justification in x.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>jy</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            Relative justification in y.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plsdimap; Set up transformation from metafile&#10;coordinates&#10;    " previous="&#10;      plsdidev; Set parameters that define current&#10;      device-space window&#10;    " next="&#10;      plsdiori; Set plot orientation&#10;    " up="The Common API for PLplot"/><section>
      plsdimap: Set up transformation from metafile
coordinates
    </section><para>
      <quotation><para><t>
           <b>plsdimap</b>
        (<i>dimxmin</i>, <i>dimxmax</i>, <i>dimymin</i>, <i>dimymax</i>, <i>dimxpmm</i>, <i>dimypmm</i>);</t></para></quotation>
    </para><para>
      Set up transformation from metafile coordinates.  The size of the plot
      is scaled so as to preserve aspect ratio.  This isn't intended to be a
      general-purpose facility just yet (not sure why the user would need
      it, for one).
    </para><varlist><varlistentry><term>
	  <code>dimxmin</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            NEEDS DOCUMENTATION
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>dimxmax</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            NEEDS DOCUMENTATION
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>dimymin</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            NEEDS DOCUMENTATION
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>dimymax</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            NEEDS DOCUMENTATION
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>dimxpmm</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            NEEDS DOCUMENTATION
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>dimypmm</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            NEEDS DOCUMENTATION
	  </para></listitem></varlistentry></varlist><node name="&#10;      plsdiori; Set plot orientation&#10;    " previous="&#10;      plsdimap; Set up transformation from metafile&#10;coordinates&#10;    " next="&#10;      plsdiplt; Set parameters that define current&#10;      plot-space window&#10;    " up="The Common API for PLplot"/><section>
      plsdiori: Set plot orientation
    </section><para>
      <quotation><para><t>
           <b>plsdiori</b>
        (<i>rot</i>);</t></para></quotation>
    </para><para>
      Set plot orientation parameter which is multiplied by 90 degrees to
      obtain the angle of rotation.  Note, arbitrary rotation parameters such as 0.2
      (corresponding to 18 degrees) are possible, but the usual values for
      the rotation parameter are 0., 1., 2., and 3. corresponding to 0 degrees
      (landscape mode), 90 degrees (portrait mode), 180 degrees (seascape
      mode), and 270 degrees (upside-down mode).
      If <code>plsdiori</code> (<pxref node="&#10;      plsdiori; Set plot orientation&#10;    " file=""/>) is not called the default value
      of <samp><code>rot</code></samp>
      is 0.
    </para><varlist><varlistentry><term>
	  <code>rot</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            Plot orientation parameter.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plsdiplt; Set parameters that define current&#10;      plot-space window&#10;    " previous="&#10;      plsdiori; Set plot orientation&#10;    " next="&#10;      plsdiplz; Set parameters incrementally [zoom mode]&#10;      that define current plot-space window&#10;    " up="The Common API for PLplot"/><section>
      plsdiplt: Set parameters that define current
      plot-space window
    </section><para>
      <quotation><para><t>
           <b>plsdiplt</b>
        (<i>xmin</i>, <i>ymin</i>, <i>xmax</i>, <i>ymax</i>);</t></para></quotation>
    </para><para>
      Set relative minima and maxima that define the current
      plot-space window.  If <code>plsdiplt</code> (<pxref node="&#10;      plsdiplt; Set parameters that define current&#10;      plot-space window&#10;    " file=""/>) is not called the default values
      of <samp><code>xmin</code></samp>,
      <samp><code>ymin</code></samp>,
      <samp><code>xmax</code></samp>, and
      <samp><code>ymax</code></samp>
      are 0., 0., 1., and 1.
    </para><varlist><varlistentry><term>
	  <code>xmin</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            Relative minimum in x.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ymin</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            Relative minimum in y.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xmax</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            Relative maximum in x.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ymax</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            Relative maximum in y.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plsdiplz; Set parameters incrementally [zoom mode]&#10;      that define current plot-space window&#10;    " previous="&#10;      plsdiplt; Set parameters that define current&#10;      plot-space window&#10;    " next="&#10;      plsesc; Set the escape character for text strings&#10;    " up="The Common API for PLplot"/><section>
      plsdiplz: Set parameters incrementally (zoom mode)
      that define current plot-space window
    </section><para>
      <quotation><para><t>
           <b>plsdiplz</b>
        (<i>xmin</i>, <i>ymin</i>, <i>xmax</i>, <i>ymax</i>);</t></para></quotation>
    </para><para>
      Set relative minima and maxima incrementally (zoom mode)
      that define the current plot-space window.  This function has
      the same effect as <code>plsdiplt</code> (<pxref node="&#10;      plsdiplt; Set parameters that define current&#10;      plot-space window&#10;    " file=""/>) if that function has not been previously
      called.  Otherwise, this function implements zoom mode using the
      transformation <samp>min_used = old_min + old_length*min </samp>
      and <samp>max_used = old_min + old_length*max </samp> for
      each axis.  For example, if <samp>min = 0.05</samp> and
      <samp>max = 0.95</samp> for each axis, repeated calls to
      <code>plsdiplz</code> (<pxref node="&#10;      plsdiplz; Set parameters incrementally [zoom mode]&#10;      that define current plot-space window&#10;    " file=""/>) will zoom in by 10 per cent for each call.
    </para><varlist><varlistentry><term>
	  <code>xmin</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            Relative (incremental) minimum in x.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ymin</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            Relative (incremental) minimum in y.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xmax</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            Relative (incremental) maximum in x.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ymax</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            Relative (incremental) maximum in y.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plsesc; Set the escape character for text strings&#10;    " previous="&#10;      plsdiplz; Set parameters incrementally [zoom mode]&#10;      that define current plot-space window&#10;    " next="&#10;      plsetopt; Set any command-line option&#10;    " up="The Common API for PLplot"/><section>
      plsesc: Set the escape character for text strings
    </section><para>
      <quotation><para><t>
           <b>plsesc</b>
        (<i>esc</i>);</t></para></quotation>
    </para><para>
    Set the escape character for text strings.  From C (in contrast to
    fortran, see <code>plsescfortran</code> (<pxref node="&#10;      plsesc; Set the escape character for text strings&#10;for fortran&#10;    " file=""/>)) you pass
    <samp><code>esc</code></samp> as a character.
    Only selected characters are allowed to prevent the user from shooting
    himself in the foot (For example, a \ isn't allowed since it conflicts with C's use
    of backslash as a character escape).  Here are the allowed escape
characters and their corresponding decimal ASCII values:
<itemize markchar="•"><listitem><para>
  !, ASCII 33
</para></listitem><listitem><para>
  #, ASCII 35
</para></listitem><listitem><para>
  $, ASCII 36
</para></listitem><listitem><para>
  %, ASCII 37
</para></listitem><listitem><para>
  &amp;, ASCII 38
</para></listitem><listitem><para>
  *, ASCII 42
</para></listitem><listitem><para>
  @, ASCII 64
</para></listitem><listitem><para>
  ^, ASCII 94
</para></listitem><listitem><para>
  ~, ASCII 126
</para></listitem></itemize>
    </para><varlist><varlistentry><term>
	  <code>esc</code>
	  (<samp>char</samp>, input)
	</term><listitem><para>
            Escape character.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plsetopt; Set any command-line option&#10;    " previous="&#10;      plsesc; Set the escape character for text strings&#10;    " next="&#10;      plsfam; Set family file parameters&#10;    " up="The Common API for PLplot"/><section>
      plsetopt: Set any command-line option
    </section><para>
      <quotation><para><t>
           <b>plsetopt</b>
        (<i>opt</i>, <i>optarg</i>);</t></para></quotation>
    </para><para>
      Set any command-line option internally from a program before it invokes
      <code>plinit</code> (<pxref node="&#10;      plinit; Initialize PLplot&#10;    " file=""/>). <samp>opt</samp> is the name of the command-line
      option and <samp>optarg</samp> is the corresponding command-line
      option argument.
    </para><varlist><varlistentry><term>
	  <code>opt</code>
	  (<samp>const char *</samp>, output)
	</term><listitem><para>
            Pointer to string containing the command-line option.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>optarg</code>
	  (<samp>const char *</samp>, output)
	</term><listitem><para>
            Pointer to string containing the argument of the command-line
	    option.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plsfam; Set family file parameters&#10;    " previous="&#10;      plsetopt; Set any command-line option&#10;    " next="&#10;      plsfci; Set FCI [font characterization integer]&#10;    " up="The Common API for PLplot"/><section>
      plsfam: Set family file parameters
    </section><para>
      <quotation><para><t>
	  <b>plsfam</b>
	(<i>fam</i>, <i>num</i>, <i>bmax</i>);</t></para></quotation>
    </para><para>
      Sets variables dealing with output file familying.  Does nothing if
      familying not supported by the driver.  This routine, if used, must
      be called before initializing PLplot.  See <ref node="Family File Output" file="">Family File Output</ref>
      for more information.
    </para><varlist><varlistentry><term>
	  <code>fam</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Family flag (Boolean).  If nonzero, familying is enabled.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>num</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Current family file number.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>bmax</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Maximum file size (in bytes) for a family file.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plsfci; Set FCI [font characterization integer]&#10;    " previous="&#10;      plsfam; Set family file parameters&#10;    " next="&#10;      plsfnam; Set output file name&#10;    " up="The Common API for PLplot"/><section>
      plsfci: Set FCI (font characterization integer)
    </section><para>
      <quotation><para><t>
	  <b>plsfci</b>
	(<i>fci</i>);</t></para></quotation>
    </para><para>
      Sets font characteristics to be used at the start of the next string
      using the FCI approach.
      See <ref node="FCI" file="">FCI</ref> for more information.
    </para><varlist><varlistentry><term>
	  <code>fci</code>
	  (<samp>PLUNICODE</samp>, input)
	</term><listitem><para>
	    PLUNICODE (unsigned 32-bit integer) value of FCI.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plsfnam; Set output file name&#10;    " previous="&#10;      plsfci; Set FCI [font characterization integer]&#10;    " next="&#10;      plshades; Shade regions on the basis of value&#10;    " up="The Common API for PLplot"/><section>
      plsfnam: Set output file name
    </section><para>
      <quotation><para><t>
	  <b>plsfnam</b>
	(<i>fnam</i>);</t></para></quotation>
    </para><para>
      Sets the current output file name, if applicable.  If the file name
      has not been specified and is required by the driver, the user will
      be prompted for it.  If using the X-windows output driver, this sets
      the display name.  This routine, if used, must be called before
      initializing PLplot.
    </para><varlist><varlistentry><term>
	  <code>fnam</code>
	  (<samp>const char *</samp>, input)
	</term><listitem><para>
	    Pointer to file name string.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plshades; Shade regions on the basis of value&#10;    " previous="&#10;      plsfnam; Set output file name&#10;    " next="&#10;      plshade;  Shade individual region on the basis of value&#10;    " up="The Common API for PLplot"/><section>
      plshades: Shade regions on the basis of value
    </section><para>
      <quotation><para><t>
           <b>plshades</b>
        (<i>a</i>, <i>nx</i>, <i>ny</i>, <i>defined</i>, <i>xmin</i>, <i>xmax</i>, <i>ymin</i>, <i>ymax</i>, <i>clevel</i>, <i>nlevel</i>, <i>fill_width</i>, <i>cont_color</i>, <i>cont_width</i>, <i>fill</i>, <i>rectangular</i>, <i>pltr</i>, <i>pltr_data</i>);</t></para></quotation>
    </para><para>
      Shade regions on the basis of value.  This is the high-level routine
      for making continuous color shaded plots with cmap1 while
      <code>plshade</code> (<pxref node="&#10;      plshade;  Shade individual region on the basis of value&#10;    " file=""/>) (or <code>plshade1</code> (<pxref node="&#10;      plshade1; Shade individual region on the basis of value&#10;    " file=""/>)) are used for individual shaded regions
      using either cmap0 or cmap1.
      <file>examples/c/x16c.c</file> shows a number of examples
      for using this function.
      See the following discussion of the
      arguments and <ref node="Contour and Shade Plots" file="">Contour and Shade Plots</ref> for
      more information.    </para><varlist><varlistentry><term>
	  <code>a</code>
	  (<samp>PLFLT **</samp>, input)
	</term><listitem><para>
             Contains ** pointer to array to be plotted. The array must have been declared
	     as PLFLT a[nx][ny].
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nx</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            First dimension of array "a".
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ny</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Second dimension of array "a".
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>defined</code>
	  (<samp>PLINT (*) (PLFLT, PLFLT)</samp>, input)
	</term><listitem><para>
	    User function specifying regions excluded from the shading
            plot.  This function accepts x and y coordinates as input
            arguments and must return 0 if the point is in the excluded
            region or 1 otherwise. This argument can be NULL if all the
            values are valid.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xmin</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
             Defines the "grid" coordinates.  The data a[0][0] has a
	     position of (xmin,ymin), a[nx-1][0] has a position at (xmax,ymin)
	     and so on.
(xmax,ymin)
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xmax</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
             Defines the "grid" coordinates.  The data a[0][0] has a
	     position of (xmin,ymin), a[nx-1][0] has a position at (xmax,ymin)
	     and so on.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ymin</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
             Defines the "grid" coordinates.  The data a[0][0] has a
	     position of (xmin,ymin), a[nx-1][0] has a position at (xmax,ymin)
	     and so on.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ymax</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
             Defines the "grid" coordinates.  The data a[0][0] has a
	     position of (xmin,ymin), a[nx-1][0] has a position at (xmax,ymin)
	     and so on.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>clevel</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
            Pointer to array containing the data levels corresponding to
	    the edges of each shaded region that will be plotted by this
	    function.  To work properly the levels should be monotonic.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nlevel</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Number of shades plus 1 (i.e., the number of shade edge values
	    in <samp><code>clevel</code></samp>).
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>fill_width</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Defines width used by the fill pattern.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>cont_color</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Defines pen color used for contours defining edges of shaded
	    regions.  The pen color is only temporary set for the
	    contour drawing.  Set this value to zero or less if no shade edge contours are wanted.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>cont_width</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Defines pen width used for contours defining edges of shaded
	    regions.  This value may not be honored by all drivers.
	    The pen width is only temporary set for the
	    contour drawing.  Set this value to zero or less if no shade edge contours are wanted.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>fill</code>
	  (<samp>void (*) (PLINT, PLFLT *, PLFLT *)</samp>, input)
	</term><listitem><para>
            Routine used to fill the region.  Use <code>plfill</code> (<pxref node="&#10;      plfill; Draw filled polygon&#10;    " file=""/>).  Future version of
	    PLplot may have other fill routines.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>rectangular</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	  Set <samp><code>rectangular</code></samp> to 1
	  if rectangles map to rectangles after coordinate transformation
	  with <samp><code>pltrl</code></samp>.  Otherwise,
	  set <samp><code>rectangular</code></samp> to 0.
	  If <samp><code>rectangular</code></samp>
	  is set to 1, plshade tries to save time by
	  filling large rectangles.  This optimization fails if
	  the coordinate transformation distorts the shape of rectangles.
	  For example a plot in polor coordinates has to have rectangular
	  set to 0.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>pltr</code>
	  (<samp>void (*) (PLFLT, PLFLT, PLFLT *, PLFLT *, PLPointer)
           </samp>, input)
	</term><listitem><para>
	    Pointer to function that defines transformation between indices
	    in array <samp><code>z</code></samp> and the
	    world coordinates (C only).  Transformation functions are
	    provided in the PLplot library:
	    <code>pltr0</code> (<pxref node="&#10;      pltr0; Identity transformation for grid to world&#10;mapping&#10;    " file=""/>) for identity mapping, and <code>pltr1</code> (<pxref node="&#10;      pltr1; Linear interpolation for grid to world&#10;mapping using singly dimensioned coord arrays&#10;    " file=""/>) and <code>pltr2</code> (<pxref node="&#10;      pltr2; Linear interpolation for grid to world&#10;      mapping using doubly dimensioned coord arrays [column&#10;      dominant; as per normal C 2d arrays]&#10;    " file=""/>) for
	    arbitrary mappings respectively defined by one- and
	    two-dimensional arrays.  In addition, user-supplied routines
	    for the transformation can be used as well.  Examples of
	    all of these approaches are given in
	    <ref node="Contour Plots from C" file="">Contour Plots from C</ref>.
	    The transformation function should
	    have the form given by any of <code>pltr0</code> (<pxref node="&#10;      pltr0; Identity transformation for grid to world&#10;mapping&#10;    " file=""/>), <code>pltr1</code> (<pxref node="&#10;      pltr1; Linear interpolation for grid to world&#10;mapping using singly dimensioned coord arrays&#10;    " file=""/>), or <code>pltr2</code> (<pxref node="&#10;      pltr2; Linear interpolation for grid to world&#10;      mapping using doubly dimensioned coord arrays [column&#10;      dominant; as per normal C 2d arrays]&#10;    " file=""/>).
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>pltr_data</code>
	  (<samp>PLPointer</samp>, input)
	</term><listitem><para>
	    Extra parameter to help
	    pass information to <code>pltr0</code> (<pxref node="&#10;      pltr0; Identity transformation for grid to world&#10;mapping&#10;    " file=""/>), <code>pltr1</code> (<pxref node="&#10;      pltr1; Linear interpolation for grid to world&#10;mapping using singly dimensioned coord arrays&#10;    " file=""/>), <code>pltr2</code> (<pxref node="&#10;      pltr2; Linear interpolation for grid to world&#10;      mapping using doubly dimensioned coord arrays [column&#10;      dominant; as per normal C 2d arrays]&#10;    " file=""/>), or whatever routine
	    that is externally supplied.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plshade;  Shade individual region on the basis of value&#10;    " previous="&#10;      plshades; Shade regions on the basis of value&#10;    " next="&#10;      plshade1; Shade individual region on the basis of value&#10;    " up="The Common API for PLplot"/><section>
      plshade:  Shade individual region on the basis of value
    </section><para>
      <quotation><para><t>
           <b>plshade</b>
        (<i>a</i>, <i>nx</i>, <i>ny</i>, <i>defined</i>, <i>xmin</i>, <i>xmax</i>, <i>ymin</i>, <i>ymax</i>, <i>shade_min</i>, <i>shade_max</i>, <i>sh_cmap</i>, <i>sh_color</i>, <i>sh_width</i>, <i>min_color</i>, <i>min_width</i>, <i>max_color</i>, <i>max_width</i>, <i>fill</i>, <i>rectangular</i>, <i>pltr</i>, <i>pltr_data</i>);</t></para></quotation>
    </para><para>
      Shade individual region on the basis of value.  Use <code>plshades</code> (<pxref node="&#10;      plshades; Shade regions on the basis of value&#10;    " file=""/>) if you want to
      shade a number of regions using continuous colors.
      <code>plshade</code> (<pxref node="&#10;      plshade;  Shade individual region on the basis of value&#10;    " file=""/>) is identical to <code>plshade1</code> (<pxref node="&#10;      plshade1; Shade individual region on the basis of value&#10;    " file=""/>)
      except for the type of the first parameter.
      See <code>plshade1</code> (<pxref node="&#10;      plshade1; Shade individual region on the basis of value&#10;    " file=""/>) for further discussion.
    </para><varlist><varlistentry><term>
	  <code>a</code>
	  (<samp>PLFLT **</samp>, input)
	</term><listitem><para>
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nx</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ny</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>defined</code>
	  (<samp>PLINT (*) (PLFLT, PLFLT)</samp>, input)
	</term><listitem><para>
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xmin</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xmax</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ymin</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ymax</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>shade_min</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>shade_max</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>sh_cmap</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>sh_color</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>sh_width</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>min_color</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>min_width</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>max_color</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>max_width</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>fill</code>
	  (<samp>void (*) (PLINT, PLFLT *, PLFLT *)</samp>, input)
	</term><listitem><para>
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>rectangular</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>pltr</code>
	  (<samp>void (*) (PLFLT, PLFLT, PLFLT *, PLFLT *, PLPointer)
           </samp>, input)
	</term><listitem><para>
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>pltr_data</code>
	  (<samp>PLPointer</samp>, input)
	</term><listitem><para>
	  </para></listitem></varlistentry></varlist><node name="&#10;      plshade1; Shade individual region on the basis of value&#10;    " previous="&#10;      plshade;  Shade individual region on the basis of value&#10;    " next="&#10;      plsmaj; Set length of major ticks&#10;    " up="The Common API for PLplot"/><section>
      plshade1: Shade individual region on the basis of value
    </section><para>
      <quotation><para><t>
           <b>plshade1</b>
        (<i>a</i>, <i>nx</i>, <i>ny</i>, <i>defined</i>, <i>xmin</i>, <i>xmax</i>, <i>ymin</i>, <i>ymax</i>, <i>shade_min</i>, <i>shade_max</i>, <i>sh_cmap</i>, <i>sh_color</i>, <i>sh_width</i>, <i>min_color</i>, <i>min_width</i>, <i>max_color</i>, <i>max_width</i>, <i>fill</i>, <i>rectangular</i>, <i>pltr</i>, <i>pltr_data</i>);</t></para></quotation>
    </para><para>
      Shade individual region on the basis of value.  Use <code>plshades</code> (<pxref node="&#10;      plshades; Shade regions on the basis of value&#10;    " file=""/>) if you want to
      shade a number of contiguous regions using continuous colors.  In
      particular the edge contours are treated properly in <code>plshades</code> (<pxref node="&#10;      plshades; Shade regions on the basis of value&#10;    " file=""/>).
      If you attempt to do contiguous regions with <code>plshade1</code> (<pxref node="&#10;      plshade1; Shade individual region on the basis of value&#10;    " file=""/>) (or <code>plshade</code> (<pxref node="&#10;      plshade;  Shade individual region on the basis of value&#10;    " file=""/>))
      the contours at the edge of the shade are partially obliterated by subsequent
      plots of contiguous shaded regions.
      <code>plshade1</code> (<pxref node="&#10;      plshade1; Shade individual region on the basis of value&#10;    " file=""/>) differs from <code>plshade</code> (<pxref node="&#10;      plshade;  Shade individual region on the basis of value&#10;    " file=""/>) by the type of the first
      argument.  Look at the argument list below, <code>plcont</code> (<pxref node="&#10;      plcont; Contour plot&#10;    " file=""/>) and
      <ref node="Contour and Shade Plots" file="">Contour and Shade Plots</ref> for
      more information about the transformation from grid to world
      coordinates.  Shading NEEDS DOCUMENTATION, but
      as a stopgap look at how <code>plshade</code> (<pxref node="&#10;      plshade;  Shade individual region on the basis of value&#10;    " file=""/>) is used in
      <file>examples/c/x15c.c</file>
    </para><varlist><varlistentry><term>
	  <code>a</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
             Contains array to be plotted. The array must have been declared
	     as PLFLT a[nx][ny].
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nx</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            First dimension of array "a".
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ny</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Second dimension of array "a".
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>defined</code>
	  (<samp>PLINT (*) (PLFLT, PLFLT)</samp>, input)
	</term><listitem><para>
	    User function specifying regions excluded from the shading
            plot.  This function accepts x and y coordinates as input
            arguments and must return 0 if the point is in the excluded
            region or 1 otherwise. This argument can be NULL if all the
            values are valid.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xmin</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
              Defines the "grid" coordinates.  The data a[0][0] has a
	     position of (xmin,ymin), a[nx-1][0] has a position at (xmax,ymin)
	     and so on.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xmax</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
             Defines the "grid" coordinates.  The data a[0][0] has a
	     position of (xmin,ymin), a[nx-1][0] has a position at (xmax,ymin)
	     and so on.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ymin</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
             Defines the "grid" coordinates.  The data a[0][0] has a
	     position of (xmin,ymin), a[nx-1][0] has a position at (xmax,ymin)
	     and so on.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ymax</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
             Defines the "grid" coordinates.  The data a[0][0] has a
	     position of (xmin,ymin), a[nx-1][0] has a position at (xmax,ymin)
	     and so on.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>shade_min</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            Defines the lower end of the interval to be shaded. If
	shade_max &lt;= shade_min, <code>plshade1</code> (<pxref node="&#10;      plshade1; Shade individual region on the basis of value&#10;    " file=""/>) does nothing.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>shade_max</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            Defines the upper end of the interval to be shaded. If
            shade_max &lt;= shade_min,
	    <code>plshade1</code> (<pxref node="&#10;      plshade1; Shade individual region on the basis of value&#10;    " file=""/>) does nothing.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>sh_cmap</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Defines color map.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>sh_color</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            Defines color map index if cmap0 or color map input value (ranging
	    from 0. to 1.) if cmap1.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>sh_width</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Defines width used by the fill pattern.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>min_color</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Defines pen color, width used by the boundary of shaded region.
	    The min values are used for the shade_min boundary, and the max
	    values are used on the shade_max boundary.  Set color and width
	    to zero for no plotted boundaries.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>min_width</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Defines pen color, width used by the boundary of shaded region.
	    The min values are used for the shade_min boundary, and the max
	    values are used on the shade_max boundary.  Set color and width
	    to zero for no plotted boundaries.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>max_color</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Defines pen color, width used by the boundary of shaded region.
	    The min values are used for the shade_min boundary, and the max
	    values are used on the shade_max boundary.  Set color and width
	    to zero for no plotted boundaries.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>max_width</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Defines pen color, width used by the boundary of shaded region.
	    The min values are used for the shade_min boundary, and the max
	    values are used on the shade_max boundary.  Set color and width
	    to zero for no plotted boundaries.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>fill</code>
	  (<samp>void (*) (PLINT, PLFLT *, PLFLT *)</samp>, input)
	</term><listitem><para>
            Routine used to fill the region.  Use <code>plfill</code> (<pxref node="&#10;      plfill; Draw filled polygon&#10;    " file=""/>).  Future version of
	    plplot may have other fill routines.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>rectangular</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	  Set <samp><code>rectangular</code></samp> to 1
	  if rectangles map to rectangles after coordinate transformation
	  with <samp><code>pltrl</code></samp>.  Otherwise,
	  set <samp><code>rectangular</code></samp> to 0.
	  If <samp><code>rectangular</code></samp>
	  is set to 1, plshade tries to save time by
	  filling large rectangles.  This optimization fails if
	  the coordinate transformation distorts the shape of rectangles.
	  For example a plot in polor coordinates has to have rectangular
	  set to 0.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>pltr</code>
	  (<samp>void (*) (PLFLT, PLFLT, PLFLT *, PLFLT *, PLPointer)
           </samp>, input)
	</term><listitem><para>
	    Pointer to function that defines transformation between indices
	    in array <samp><code>z</code></samp> and the
	    world coordinates (C only).  Transformation functions are
	    provided in the PLplot library:
	    <code>pltr0</code> (<pxref node="&#10;      pltr0; Identity transformation for grid to world&#10;mapping&#10;    " file=""/>) for identity mapping, and <code>pltr1</code> (<pxref node="&#10;      pltr1; Linear interpolation for grid to world&#10;mapping using singly dimensioned coord arrays&#10;    " file=""/>) and <code>pltr2</code> (<pxref node="&#10;      pltr2; Linear interpolation for grid to world&#10;      mapping using doubly dimensioned coord arrays [column&#10;      dominant; as per normal C 2d arrays]&#10;    " file=""/>) for
	    arbitrary mappings respectively defined by one- and
	    two-dimensional arrays.  In addition, user-supplied routines
	    for the transformation can be used as well.  Examples of
	    all of these approaches are given in
	    <ref node="Contour Plots from C" file="">Contour Plots from C</ref>.
	    The transformation function should
	    have the form given by any of <code>pltr0</code> (<pxref node="&#10;      pltr0; Identity transformation for grid to world&#10;mapping&#10;    " file=""/>), <code>pltr1</code> (<pxref node="&#10;      pltr1; Linear interpolation for grid to world&#10;mapping using singly dimensioned coord arrays&#10;    " file=""/>), or <code>pltr2</code> (<pxref node="&#10;      pltr2; Linear interpolation for grid to world&#10;      mapping using doubly dimensioned coord arrays [column&#10;      dominant; as per normal C 2d arrays]&#10;    " file=""/>).
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>pltr_data</code>
	  (<samp>PLPointer</samp>, input)
	</term><listitem><para>
	    Extra parameter to help
	    pass information to <code>pltr0</code> (<pxref node="&#10;      pltr0; Identity transformation for grid to world&#10;mapping&#10;    " file=""/>), <code>pltr1</code> (<pxref node="&#10;      pltr1; Linear interpolation for grid to world&#10;mapping using singly dimensioned coord arrays&#10;    " file=""/>), <code>pltr2</code> (<pxref node="&#10;      pltr2; Linear interpolation for grid to world&#10;      mapping using doubly dimensioned coord arrays [column&#10;      dominant; as per normal C 2d arrays]&#10;    " file=""/>), or whatever routine
	    that is externally supplied.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plsmaj; Set length of major ticks&#10;    " previous="&#10;      plshade1; Shade individual region on the basis of value&#10;    " next="&#10;      plsmem; Set the memory area to be plotted&#10;    " up="The Common API for PLplot"/><section>
      plsmaj: Set length of major ticks
    </section><para>
      <quotation><para><t>
	  <b>plsmaj</b>
	(<i>def</i>, <i>scale</i>);</t></para></quotation>
    </para><para>
      This sets up the length of the major ticks.  The actual length is the
      product of the default length and a scaling factor as for character
      height.
    </para><varlist><varlistentry><term>
	  <code>def</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The default length of a major tick in millimeters, should be
	    set to zero if the default length is to remain unchanged.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>scale</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    Scale factor to be applied to default to get actual tick
	    length.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plsmem; Set the memory area to be plotted&#10;    " previous="&#10;      plsmaj; Set length of major ticks&#10;    " next="&#10;      plsmin; Set length of minor ticks&#10;    " up="The Common API for PLplot"/><section>
      plsmem: Set the memory area to be plotted
    </section><para>
      <quotation><para><t>
	  <b>plsmem</b>
	(<i>maxx</i>, <i>maxy</i>, <i>plotmem</i>);</t></para></quotation>
    </para><para>
      Set the memory area to be plotted (with the mem driver)
      as the <samp>dev</samp> member of the stream structure.  Also
      set the number of pixels in the memory passed in
      <code>plotmem</code>, which is a block of memory
      <code>maxy</code> by <code>maxx</code> by 3 bytes
      long, say: 480 x 640 x 3 (Y, X, RGB)
    </para><para>
      This memory will have to be freed by the user!
    </para><varlist><varlistentry><term>
	  <code>maxx</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Size of memory area in the X coordinate.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>maxy</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Size of memory area in the Y coordinate.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>plotmem</code>
	  (<samp>void *</samp>, input)
	</term><listitem><para>
	    Pointer to the beginning of the user-supplied memory area.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plsmin; Set length of minor ticks&#10;    " previous="&#10;      plsmem; Set the memory area to be plotted&#10;    " next="&#10;      plsori; Set orientation&#10;    " up="The Common API for PLplot"/><section>
      plsmin: Set length of minor ticks
    </section><para>
      <quotation><para><t>
	  <b>plsmin</b>
	(<i>def</i>, <i>scale</i>);</t></para></quotation>
    </para><para>
      This sets up the length of the minor ticks and the length of the
      terminals on error bars.  The actual length is the product of the
      default length and a scaling factor as for character height.
    </para><varlist><varlistentry><term>
	  <code>def</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The default length of a minor tick in millimeters, should be
	    set to zero if the default length is to remain unchanged.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>scale</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    Scale factor to be applied to default to get actual tick
	    length.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plsori; Set orientation&#10;    " previous="&#10;      plsmin; Set length of minor ticks&#10;    " next="&#10;      plspage; Set page parameters&#10;    " up="The Common API for PLplot"/><section>
      plsori: Set orientation
    </section><para>
      <quotation><para><t>
	  <b>plsori</b>
	(<i>ori</i>);</t></para></quotation>
    </para><para>
      Sets the current orientation.  If
      <samp><code>ori</code></samp> is equal to zero
      (default) then landscape is used (x axis is parallel to the longest
      edge of the page), otherwise portrait is used.  This option is not
      supported by all output drivers (in particular, most interactive
      screen drivers ignore the orientation).  This routine, if used, must
      be called before initializing PLplot.
    </para><varlist><varlistentry><term>
	  <code>ori</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Orientation value (0 for landscape, 1 for portrait; the value is
	    multiplied by 90 degrees to get the angle)
	  </para></listitem></varlistentry></varlist><node name="&#10;      plspage; Set page parameters&#10;    " previous="&#10;      plsori; Set orientation&#10;    " next="&#10;      plspause; Set the pause [on end-of-page] status&#10;    " up="The Common API for PLplot"/><section>
      plspage: Set page parameters
    </section><para>
      <quotation><para><t>
	  <b>plspage</b>
	(<i>xp</i>, <i>yp</i>, <i>xleng</i>, <i>yleng</i>, <i>xoff</i>, <i>yoff</i>);</t></para></quotation>
    </para><para>
      Sets the page configuration (optional).  Not all parameters are
      recognized by all drivers and the interpretation is device-dependent.
      The X-window driver uses the length and offset parameters to determine
      the window size and location.  This routine, if used, must be called
      before initializing PLplot.
    </para><varlist><varlistentry><term>
	  <code>xp</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    Number of pixels, x.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>yp</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    Number of pixels, y.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xleng</code>
	  (<samp>PLINT </samp>, input)
	</term><listitem><para>
	    Page length, x.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>yleng</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Page length, y.
          </para></listitem></varlistentry><varlistentry><term>
          <code>xoff</code>
          (<samp>PLINT</samp>, input)
        </term><listitem><para>
            Page offset, x.
          </para></listitem></varlistentry><varlistentry><term>
          <code>yoff</code>
          (<samp>PLINT</samp>, input)
        </term><listitem><para>
            Page offset, y.
          </para></listitem></varlistentry></varlist><node name="&#10;      plspause; Set the pause [on end-of-page] status&#10;    " previous="&#10;      plspage; Set page parameters&#10;    " next="&#10;      plsstrm; Set current output stream&#10;    " up="The Common API for PLplot"/><section>
      plspause: Set the pause (on end-of-page) status
    </section><para>
      <quotation><para><t>
           <b>plspause</b>
        (<i>pause</i>);</t></para></quotation>
    </para><para>
      Set the pause (on end-of-page) status.
    </para><varlist><varlistentry><term>
	  <code>pause</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            If <samp><code>pause</code></samp> = 1 there
	    will be a pause on end-of-page for those drivers which support
	    this.  Otherwise there is no pause.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plsstrm; Set current output stream&#10;    " previous="&#10;      plspause; Set the pause [on end-of-page] status&#10;    " next="&#10;      plssub; Set the number of subpages in x and y&#10;    " up="The Common API for PLplot"/><section>
      plsstrm: Set current output stream
    </section><para>
      <quotation><para><t>
	  <b>plsstrm</b>
	(<i>strm</i>);</t></para></quotation>
    </para><para>
      Sets the number of the current output stream.  The stream number
      defaults to 0 unless changed by this routine.  The first use of this
      routine must be followed by a call initializing PLplot
      (e.g. <code>plstar</code> (<pxref node="&#10;      plstar; Initialization&#10;    " file=""/>)).
    </para><varlist><varlistentry><term>
	  <code>strm</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    The current stream number.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plssub; Set the number of subpages in x and y&#10;    " previous="&#10;      plsstrm; Set current output stream&#10;    " next="&#10;      plssym; Set symbol size&#10;    " up="The Common API for PLplot"/><section>
      plssub: Set the number of subpages in x and y
    </section><para>
      <quotation><para><t>
           <b>plssub</b>
        (<i>nx</i>, <i>ny</i>);</t></para></quotation>
    </para><para>
      Set the number of subpages in x and y.
    </para><varlist><varlistentry><term>
	  <code>nx</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Number of windows in x direction (i.e., number of window columns).
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ny</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Number of windows in y direction (i.e., number of window rows).
	  </para></listitem></varlistentry></varlist><node name="&#10;      plssym; Set symbol size&#10;    " previous="&#10;      plssub; Set the number of subpages in x and y&#10;    " next="&#10;      plstar; Initialization&#10;    " up="The Common API for PLplot"/><section>
      plssym: Set symbol size
    </section><para>
      <quotation><para><t>
	  <b>plssym</b>
	(<i>def</i>, <i>scale</i>);</t></para></quotation>
    </para><para>
      This sets up the size of all subsequent symbols drawn by <code>plpoin</code> (<pxref node="&#10;      plpoin; Plots a character at the specified points&#10;    " file=""/>) and
      <code>plsym</code> (<pxref node="&#10;      plsym; Plots a symbol at the specified points&#10;    " file=""/>).  The actual height of a symbol is the product of the default
      symbol size and a scaling factor as for the character height.
    </para><varlist><varlistentry><term>
	  <code>def</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The default height of a symbol in millimeters, should be set to
	    zero if the default height is to remain unchanged.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>scale</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    Scale factor to be applied to default to get actual symbol
	    height.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plstar; Initialization&#10;    " previous="&#10;      plssym; Set symbol size&#10;    " next="&#10;      plstart; Initialization&#10;    " up="The Common API for PLplot"/><section>
      plstar: Initialization
    </section><para>
      <quotation><para><t>
	  <b>plstar</b>
	(<i>nx</i>, <i>ny</i>);</t></para></quotation>
    </para><para>
      Initializing the plotting package.  The program prompts for the
      device keyword or number of the desired output device.  Hitting a
      RETURN in response to the prompt is the same as selecting the first
      device.  If only one device is enabled when PLplot is installed,
      <code>plstar</code> (<pxref node="&#10;      plstar; Initialization&#10;    " file=""/>) will issue no prompt.  The output device is divided into
      <samp><code>nx</code></samp> by
      <samp><code>ny</code></samp> subpages, each of which
      may be used independently.  The subroutine <code>pladv</code> (<pxref node="pladv; Advance the [sub-]page" file=""/>) is used to advance
      from one subpage to the next.
    </para><varlist><varlistentry><term>
	  <code>nx</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of subpages to divide output page in the horizontal
	    direction.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ny</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of subpages to divide output page in the vertical
	    direction.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plstart; Initialization&#10;    " previous="&#10;      plstar; Initialization&#10;    " next="&#10;      plstripa; Add a point to a stripchart&#10;    " up="The Common API for PLplot"/><section>
      plstart: Initialization
    </section><para>
      <quotation><para><t>
	  <b>plstart</b>
	(<i>device</i>, <i>nx</i>, <i>ny</i>);</t></para></quotation>
    </para><para>
      Alternative to <code>plstar</code> (<pxref node="&#10;      plstar; Initialization&#10;    " file=""/>) for initializing the plotting package.  The
      <samp><code>device</code></samp> name keyword for the
      desired output device must be supplied as an argument.  The device
      keywords are the same as those printed out by <code>plstar</code> (<pxref node="&#10;      plstar; Initialization&#10;    " file=""/>).  If the
      requested device is not available, or if the input string is empty or
      begins with ``?'', the prompted startup of <code>plstar</code> (<pxref node="&#10;      plstar; Initialization&#10;    " file=""/>) is used.  This
      routine also divides the output device into
      <samp><code>nx</code></samp> by
      <samp><code>ny</code></samp> subpages, each of which
      may be used independently.  The subroutine <code>pladv</code> (<pxref node="pladv; Advance the [sub-]page" file=""/>) is used to advance
      from one subpage to the next.
    </para><varlist><varlistentry><term>
	  <code>device</code>
	  (<samp>const char *</samp>, input)
	</term><listitem><para>
	    Device name (keyword) of the required output device.  If NULL
	    or if the first character is a ``?'', the normal (prompted)
	    startup is used.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nx</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of subpages to divide output page in the horizontal
	    direction.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ny</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of subpages to divide output page in the vertical
	    direction.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plstripa; Add a point to a stripchart&#10;    " previous="&#10;      plstart; Initialization&#10;    " next="&#10;      plstripc; Create a 4-pen stripchart&#10;    " up="The Common API for PLplot"/><section>
      plstripa: Add a point to a stripchart
    </section><para>
      <quotation><para><t>
           <b>plstripa</b>
        (<i>id</i>, <i>p</i>, <i>x</i>, <i>y</i>);</t></para></quotation>
    </para><para>
      Add a point to a given pen of a given stripchart.
      There is no need for all pens to have the same number of
      points or to be equally sampled in the x coordinate.
      Allocates memory and rescales as
      necessary.
    </para><varlist><varlistentry><term>
	  <code>id</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Identification number (set up in <code>plstripc</code> (<pxref node="&#10;      plstripc; Create a 4-pen stripchart&#10;    " file=""/>)) of the stripchart.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>p</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Pen number (ranges from 0 to 3).
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>x</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            X coordinate of point to plot.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>y</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            Y coordinate of point to plot.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plstripc; Create a 4-pen stripchart&#10;    " previous="&#10;      plstripa; Add a point to a stripchart&#10;    " next="&#10;      plstripd; Deletes and releases memory used by a&#10;stripchart&#10;    " up="The Common API for PLplot"/><section>
      plstripc: Create a 4-pen stripchart
    </section><para>
      <quotation><para><t>
           <b>plstripc</b>
        (<i>id</i>, <i>xspec</i>, <i>yspec</i>, <i>xmin</i>, <i>xmax</i>, <i>xjump</i>, <i>ymin</i>, <i>ymax</i>, <i>xlpos</i>, <i>ylpos</i>, <i>y_ascl</i>, <i>acc</i>, <i>colbox</i>, <i>collab</i>, <i>colline</i>, <i>styline</i>, <i>legline[]</i>, <i>labx</i>, <i>laby</i>, <i>labtop</i>);</t></para></quotation>
    </para><para>
      Create a 4-pen stripchart, to be used afterwards by <code>plstripa</code> (<pxref node="&#10;      plstripa; Add a point to a stripchart&#10;    " file=""/>)
    </para><varlist><varlistentry><term>
	  <code>id</code>
	  (<samp>PLINT *</samp>, output)
	</term><listitem><para>
            Identification number of stripchart to use on <code>plstripa</code> (<pxref node="&#10;      plstripa; Add a point to a stripchart&#10;    " file=""/>) and <code>plstripd</code> (<pxref node="&#10;      plstripd; Deletes and releases memory used by a&#10;stripchart&#10;    " file=""/>).
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xspec</code>
	  (<samp>char *</samp>, input)
	</term><listitem><para>
            X-axis specification as in <code>plbox</code> (<pxref node="plbox; Draw a box with axes; etc" file=""/>).
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>yspec</code>
	  (<samp>char *</samp>, input)
	</term><listitem><para>
            Y-axis specification as in <code>plbox</code> (<pxref node="plbox; Draw a box with axes; etc" file=""/>).
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xmin</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            Initial coordinates of plot box; they will change as data are
	    added.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xmax</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            Initial coordinates of plot box; they will change as data are
	    added.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xjump</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	  When x attains <samp><code>xmax</code></samp>,
	  the length of the plot is multiplied by the
	  factor <samp>(1 + <code>xjump</code>)</samp>.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ymin</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            Initial coordinates of plot box; they will change as data are
	    added.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ymax</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            Initial coordinates of plot box; they will change as data are
	    added.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xlpos</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            X legend box position (range from 0 to 1).
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ylpos</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            Y legend box position (range from 0 to 1).
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>y_ascl</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	  Autoscale y between x jumps (1) or not (0).
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>acc</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Accumulate strip plot (1) or slide (0).
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>colbox</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Plot box color index (cmap0).
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>collab</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Legend color index (cmap0).
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>colline</code>
	  (<samp>PLINT *</samp>, input)
	</term><listitem><para>
            Pointer to array with color indices (cmap0) for the 4 pens.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>styline</code>
	  (<samp>PLINT *</samp>, input)
	</term><listitem><para>
            Pointer to array with line styles for the 4 pens.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>legline</code>
	  (<samp>char **</samp>, input)
	</term><listitem><para>
            Pointer to character array containing legends for the 4 pens.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>labx</code>
	  (<samp>char *</samp>, input)
	</term><listitem><para>
            X-axis label.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>laby</code>
	  (<samp>char *</samp>, input)
	</term><listitem><para>
            Y-axis label.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>labtop</code>
	  (<samp>char *</samp>, input)
	</term><listitem><para>
            Plot title.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plstripd; Deletes and releases memory used by a&#10;stripchart&#10;    " previous="&#10;      plstripc; Create a 4-pen stripchart&#10;    " next="&#10;      plstyl; Set line style&#10;    " up="The Common API for PLplot"/><section>
      plstripd: Deletes and releases memory used by a
stripchart
    </section><para>
      <quotation><para><t>
           <b>plstripd</b>
        (<i>id</i>);</t></para></quotation>
    </para><para>
      Deletes and releases memory used by a stripchart.
    </para><varlist><varlistentry><term>
	  <code>id</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            Identitification number of stripchart to delete.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plstyl; Set line style&#10;    " previous="&#10;      plstripd; Deletes and releases memory used by a&#10;stripchart&#10;    " next="&#10;      plsurf3d; Plot shaded 3-d surface plot&#10;    " up="The Common API for PLplot"/><section>
      plstyl: Set line style
    </section><para>
      <quotation><para><t>
	  <b>plstyl</b>
	(<i>nels</i>, <i>mark</i>, <i>space</i>);</t></para></quotation>
    </para><para>
      This sets up the line style for all lines subsequently drawn.  A line
      consists of segments in which the pen is alternately down and up.
      The lengths of these segments are passed in the arrays
      <samp><code>mark</code></samp> and
      <samp><code>space</code></samp> respectively.  The
      number of mark-space pairs is specified by
      <samp><code>nels</code></samp>.  In order to return
      the line style to the default continuous line, <code>plstyl</code> (<pxref node="&#10;      plstyl; Set line style&#10;    " file=""/>) should be
      called with <samp><code>nels</code>=0</samp>.(see
      also <code>pllsty</code> (<pxref node="&#10;      pllsty; Select line style&#10;    " file=""/>))
    </para><varlist><varlistentry><term>
	  <code>nels</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    The number of <samp><code>mark</code></samp>
	    and <samp><code>space</code></samp> elements in
	    a line.  Thus a simple broken line can be obtained by setting
	    <samp><code>nels</code>=1</samp>.  A continuous
	    line is specified by setting
	    <samp><code>nels</code>=0</samp>.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>mark</code>
	  (<samp>PLINT *</samp>, input)
	</term><listitem><para>
	    Pointer to array with the lengths of the segments during which
	    the pen is down, measured in micrometers.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>space</code>
	  (<samp>PLINT *</samp>, input)
	</term><listitem><para>
	    Pointer to array with the lengths of the segments during which
	    the pen is up, measured in micrometers.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plsurf3d; Plot shaded 3-d surface plot&#10;    " previous="&#10;      plstyl; Set line style&#10;    " next="&#10;      plsvect; Set arrow style for vector plots&#10;    " up="The Common API for PLplot"/><section>
      plsurf3d: Plot shaded 3-d surface plot
    </section><para>
      <quotation><para><t>
	  <b>plsurf3d</b>
	(<i>x</i>, <i>y</i>, <i>z</i>, <i>nx</i>, <i>ny</i>, <i>opt</i>, <i>clevel</i>, <i>nlevel</i>);</t></para></quotation>
    </para><para>
      Plots a three dimensional shaded surface plot within the environment set up
      by <code>plw3d</code> (<pxref node="&#10;      plw3d; Set up window for 3-d plotting&#10;    " file=""/>).  The surface is defined by the two-dimensional array
      <samp><code>z</code>[<code>nx</code>][<code>ny</code>]</samp>,
      the point <samp><code>z</code>[i][j]</samp> being the
      value of the function at <samp>(<code>x</code>[i],
      <code>y</code>[j])</samp>.  Note that the points in
      arrays <samp><code>x</code></samp> and
      <samp><code>y</code></samp> do not need to be equally
      spaced, but must be stored in ascending order.
      For further details see <ref node="Three Dimensional Surface Plots" file="">Three Dimensional Surface Plots</ref>.
    </para><varlist><varlistentry><term>
	  <code>x</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to set of x coordinate values at which the function is
	    evaluated.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>y</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to set of y coordinate values at which the function is
	    evaluated.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>z</code>
	  (<samp>PLFLT **</samp>, input)
	</term><listitem><para>
	    Pointer to a vectored two-dimensional array with set of
	    function values.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nx</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of <samp><code>x</code></samp> values at
	    which function is evaluated.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ny</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of <samp><code>y</code></samp> values at
	    which function is evaluated.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>opt</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Determines the way in which the surface is represented. To specify
            more than one option just add the options, e.g. FACETED + SURF_CONT
	    <itemize markchar="•"><listitem><para>
		  <samp><code>opt</code>=FACETED</samp>: Network
		  of lines is drawn connecting points at which function is
		  defined.
		</para></listitem><listitem><para>
		  <samp><code>opt</code>=BASE_CONT</samp>: A contour
                  plot is drawn at the base XY plane using parameters
                  <code>nlevel</code> and <code>clevel</code>.
		</para></listitem><listitem><para>
		  <samp><code>opt</code>=SURF_CONT</samp>: A contour
                  plot is drawn at the surface plane using parameters
                  <code>nlevel</code> and <code>clevel</code>.
		</para></listitem><listitem><para>
		  <samp><code>opt</code>=DRAW_SIDES</samp>: draws a curtain
                  between the base XY plane and the borders of the plotted function.
		</para></listitem><listitem><para>
		  <samp><code>opt</code>=MAG_COLOR</samp>:
		  the surface is colored according to the value of Z; if
		  <samp>MAG_COLOR</samp> is not used, then the default
		  the surface is colored according to the intensity of the
		  reflected light in the surface from a light source whose
		  position is set using <code>pllightsource</code> (<pxref node="&#10;      pllightsource; Sets the 3D position of the light&#10;source&#10;    " file=""/>).
		</para></listitem></itemize>
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>clevel</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to the array that defines the contour level spacing.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nlevel</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
          Number of elements in the <samp>clevel</samp> array.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plsvect; Set arrow style for vector plots&#10;    " previous="&#10;      plsurf3d; Plot shaded 3-d surface plot&#10;    " next="&#10;      plsvpa; Specify viewport in absolute coordinates&#10;    " up="The Common API for PLplot"/><section>
      plsvect: Set arrow style for vector plots
    </section><para>
      <quotation><para><t>
	  <b>plsvect</b>
	(<i>arrowx</i>, <i>arrowy</i>, <i>npts</i>, <i>fill</i>);</t></para></quotation>
    </para><para>
      Set the style for the arrow used by <code>plvect</code> (<pxref node="&#10;      plvect; Vector plot&#10;    " file=""/>) to plot vectors.
    </para><varlist><varlistentry><term>
	  <code>arrowx, arrowy</code>
	  (<samp>PLFLT *</samp>,input)
	</term><listitem><para>
	    Pointers to a pair of arrays containing the x and y points
	    which make up the arrow. The arrow is plotted by joining these
	    points to form a polygon. The scaling assumes that the x and y
	    points in the arrow lie in the range
	    <samp>-0.5 &lt;= x,y &lt;= 0.5</samp>.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>npts</code>
	  (<samp>PLINT</samp>,input)
	</term><listitem><para>
	    Number of points in the arrays
	    <samp><code>arrowx</code></samp> and
	    <samp><code>arrowy</code></samp>.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>fill</code>
	  (<samp>PLINT</samp>,input)
	</term><listitem><para>
	    If <samp><code>fill</code> = 0</samp> then the
	    arrow is open, if <samp><code>fill</code> = 1</samp>
	    then the arrow is filled.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plsvpa; Specify viewport in absolute coordinates&#10;    " previous="&#10;      plsvect; Set arrow style for vector plots&#10;    " next="&#10;      plsxax; Set x axis parameters&#10;    " up="The Common API for PLplot"/><section>
      plsvpa: Specify viewport in absolute coordinates
    </section><para>
      <quotation><para><t>
	  <b>plsvpa</b>
	(<i>xmin</i>, <i>xmax</i>, <i>ymin</i>, <i>ymax</i>);</t></para></quotation>
    </para><para>
      Alternate routine to <code>plvpor</code> (<pxref node="&#10;      plvpor; Specify viewport using coordinates&#10;    " file=""/>) for setting up the viewport.  This
      routine should be used only if the viewport is required to have a
      definite size in millimeters.  The routine <code>plgspa</code> (<pxref node="&#10;      plgspa; Get current subpage parameters&#10;    " file=""/>) is useful for
      finding out the size of the current subpage.
    </para><varlist><varlistentry><term>
	  <code>xmin</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The distance of the left-hand edge of the viewport from the
	    left-hand edge of the subpage in millimeters.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xmax</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The distance of the right-hand edge of the viewport from the
	    left-hand edge of the subpage in millimeters.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ymin</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The distance of the bottom edge of the viewport from the bottom
	    edge of the subpage in millimeters.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ymax</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The distance of the top edge of the viewport from the bottom edge
	    of the subpage in millimeters.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plsxax; Set x axis parameters&#10;    " previous="&#10;      plsvpa; Specify viewport in absolute coordinates&#10;    " next="&#10;      plsyax; Set y axis parameters&#10;    " up="The Common API for PLplot"/><section>
      plsxax: Set x axis parameters
    </section><para>
      <quotation><para><t>
	  <b>plsxax</b>
	(<i>digmax</i>, <i>digits</i>);</t></para></quotation>
    </para><para>
      Sets values of the
      <samp><code>digmax</code></samp> and
      <samp><code>digits</code></samp> flags for the x
      axis.  See <ref node="Annotating the Viewport" file="">Annotating the Viewport</ref> for more information.
    </para><varlist><varlistentry><term>
	  <code>digmax</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Variable to set the maximum number of digits for the x axis.  If nonzero, the
	    printed label will be switched to a floating point
	    representation when the number of digits exceeds
	    <samp><code>digmax</code></samp>.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>digits</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Field digits value.  Currently, changing its value here has no
	    effect since it is set only by <code>plbox</code> (<pxref node="plbox; Draw a box with axes; etc" file=""/>) or <code> plbox3</code> (<pxref node="&#10;      plbox3; Draw a box with axes; etc; in 3-d&#10;    " file=""/>).  However,
	    the user may obtain its value after a call to either of these functions by
	    calling <code>plgxax</code> (<pxref node="&#10;      plgxax; Get x axis parameters&#10;    " file=""/>).
	  </para></listitem></varlistentry></varlist><node name="&#10;      plsyax; Set y axis parameters&#10;    " previous="&#10;      plsxax; Set x axis parameters&#10;    " next="&#10;      plsym; Plots a symbol at the specified points&#10;    " up="The Common API for PLplot"/><section>
      plsyax: Set y axis parameters
    </section><para>
      <quotation><para><t>
	  <b>plsyax</b>
	(<i>digmax</i>, <i>digits</i>);</t></para></quotation>
    </para><para>
      Identical to <code>plsxax</code> (<pxref node="&#10;      plsxax; Set x axis parameters&#10;    " file=""/>), except that arguments are flags for y axis.
      See the description of <code>plsxax</code> (<pxref node="&#10;      plsxax; Set x axis parameters&#10;    " file=""/>) for more detail.
    </para><varlist><varlistentry><term>
	  <code>digmax</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Variable to set the maximum number of digits for the y axis.  If nonzero, the
	    printed label will be switched to a floating point
	    representation when the number of digits exceeds
	    <samp><code>digmax</code></samp>.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>digits</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Field digits value.  Currently, changing its value here has no
	    effect since it is set only by <code>plbox</code> (<pxref node="plbox; Draw a box with axes; etc" file=""/>) or <code> plbox3</code> (<pxref node="&#10;      plbox3; Draw a box with axes; etc; in 3-d&#10;    " file=""/>).  However,
	    the user may obtain its value after a call to either of these functions by
	    calling <code>plgyax</code> (<pxref node="&#10;      plgyax; Get y axis parameters&#10;    " file=""/>).
	  </para></listitem></varlistentry></varlist><node name="&#10;      plsym; Plots a symbol at the specified points&#10;    " previous="&#10;      plsyax; Set y axis parameters&#10;    " next="&#10;      plszax; Set z axis parameters&#10;    " up="The Common API for PLplot"/><section>
      plsym: Plots a symbol at the specified points
    </section><para>
      <quotation><para><t>
	  <b>plsym</b>
	(<i>n</i>, <i>x</i>, <i>y</i>, <i>code</i>);</t></para></quotation>
    </para><para>
      Marks out a set of <samp><code>n</code></samp> points
      at positions <samp>(<code>x</code>[i],
      <code>y</code>[i])</samp>, using the symbol defined by
      <samp><code>code</code></samp>.  The code is
      interpreted as an index in the Hershey font tables.
    </para><varlist><varlistentry><term>
	  <code>n</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of points to be marked.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>x</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array with set of x coordinate values for the
	    points.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>y</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array with set of y coordinate values for the
	    points.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>code</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Code number for the symbol to be plotted.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plszax; Set z axis parameters&#10;    " previous="&#10;      plsym; Plots a symbol at the specified points&#10;    " next="&#10;      pltext; Switch to text screen&#10;    " up="The Common API for PLplot"/><section>
      plszax: Set z axis parameters
    </section><para>
      <quotation><para><t>
	  <b>plszax</b>
	(<i>digmax</i>, <i>digits</i>);</t></para></quotation>
    </para><para>
      Identical to <code>plsxax</code> (<pxref node="&#10;      plsxax; Set x axis parameters&#10;    " file=""/>), except that arguments are flags for z axis.
      See the description of <code>plsxax</code> (<pxref node="&#10;      plsxax; Set x axis parameters&#10;    " file=""/>) for more detail.
    </para><varlist><varlistentry><term>
	  <code>digmax</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Variable to set the maximum number of digits for the z axis.  If nonzero, the
	    printed label will be switched to a floating point
	    representation when the number of digits exceeds
	    <samp><code>digmax</code></samp>.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>digits</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Field digits value.  Currently, changing its value here has no
	    effect since it is set only by <code>plbox</code> (<pxref node="plbox; Draw a box with axes; etc" file=""/>) or <code> plbox3</code> (<pxref node="&#10;      plbox3; Draw a box with axes; etc; in 3-d&#10;    " file=""/>).  However,
	    the user may obtain its value after a call to either of these functions by
	    calling <code>plgzax</code> (<pxref node="&#10;      plgzax; Get z axis parameters&#10;    " file=""/>).
	  </para></listitem></varlistentry></varlist><node name="&#10;      pltext; Switch to text screen&#10;    " previous="&#10;      plszax; Set z axis parameters&#10;    " next="&#10;      plvasp; Specify viewport using aspect ratio only&#10;    " up="The Common API for PLplot"/><section>
      pltext: Switch to text screen
    </section><para>
      <quotation><para><t>
	  <b>pltext</b>
	();</t></para></quotation>
    </para><para>
      Sets an interactive device to text mode, used in conjunction with
      <code>plgra</code> (<pxref node="&#10;      plgra; Switch to graphics screen&#10;    " file=""/>) to allow graphics and text to be interspersed.  On a device
      which supports separate text and graphics windows, this command
      causes control to be switched to the text window.  This can be useful
      for printing diagnostic messages or getting user input, which would
      otherwise interfere with the plots.  The program
      <i>must</i> switch back to the graphics window before
      issuing plot commands, as the text (or console) device will probably
      become quite confused otherwise.  If already in text mode, this
      command is ignored.  It is also ignored on devices which only support
      a single window or use a different method for shifting focus (see
      also <code>plgra</code> (<pxref node="&#10;      plgra; Switch to graphics screen&#10;    " file=""/>)).
    </para><node name="&#10;      plvasp; Specify viewport using aspect ratio only&#10;    " previous="&#10;      pltext; Switch to text screen&#10;    " next="&#10;      plvect; Vector plot&#10;    " up="The Common API for PLplot"/><section>
      plvasp: Specify viewport using aspect ratio only
    </section><para>
      <quotation><para><t>
	  <b>plvasp</b>
	(<i>aspect</i>);</t></para></quotation>
    </para><para>
      Sets the viewport so that the ratio of the length of the y axis to
      that of the x axis is equal to
      <samp><code>aspect</code></samp>.
    </para><varlist><varlistentry><term>
	  <code>aspect</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    Ratio of length of y axis to length of x axis.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plvect; Vector plot&#10;    " previous="&#10;      plvasp; Specify viewport using aspect ratio only&#10;    " next="&#10;      plvpas; Specify viewport using coordinates and aspect ratio&#10;    " up="The Common API for PLplot"/><section>
      plvect: Vector plot
    </section><para>
      <quotation><para><t>
	  <b>plvect</b>
	(<i>u</i>, <i>v</i>, <i>nx</i>, <i>ny</i>, <i>scale</i>, <i>pltr</i>, <i>pltr_data</i>);</t></para></quotation>
    </para><para>
      Draws a vector plot of the vector
      <samp>(<code>u</code>[<code>nx</code>][<code>ny</code>],<code>v</code>[<code>nx</code>][<code>ny</code>])</samp>.
      The scaling factor for the vectors is given by
      <samp><code>scale</code></samp>. A
      transformation routine pointed to by <samp><code>pltr</code></samp>
      with a pointer <samp><code>pltr_data</code></samp>
      for additional data required by the transformation routine
      is used to map indices within the array
      to the world coordinates. The style of the vector arrow may be set using
      <code>plsvect</code> (<pxref node="&#10;      plsvect; Set arrow style for vector plots&#10;    " file=""/>).
    </para><varlist><varlistentry><term>
	  <code>u, v</code>
	  (<samp>PLFLT **</samp>, input)
	</term><listitem><para>
	   Pointers to a pair of vectored two-dimensional arrays
	   containing the x and y components of the vector data to be
	   plotted.
	   </para></listitem></varlistentry><varlistentry><term>
 	  <code>nx, ny</code>
 	  (<samp>PLINT</samp>, input)
 	</term><listitem><para>
 	    Physical dimensions of the arrays
 	    <samp><code>u</code></samp> and
 	    <samp><code>v</code></samp>.
 	  </para></listitem></varlistentry><varlistentry><term>
	   <code>scale</code>
	   (<samp>PLFLT</samp>, input)
	 </term><listitem><para>
	     Parameter to control the scaling factor of the vectors for plotting.
	     If <samp><code>scale</code> = 0</samp> then
	     the scaling factor is automatically calculated for the data.
	     If <samp><code>scale</code> &lt; 0</samp> then
	     the scaling factor is automatically calculated for the data and
	     then multiplied by <samp>-<code>scale</code></samp>.
	     If <samp><code>scale</code> &gt; 0</samp> then
	     the scaling factor is set to <samp><code>scale</code></samp>.
	   </para></listitem></varlistentry><varlistentry><term>
	  <code>pltr</code>
	  (<samp>void (*) (PLFLT, PLFLT, PLFLT *, PLFLT *, PLPointer)
           </samp>, input)
	</term><listitem><para>
	    Pointer to function that defines transformation between indices
	    in array <samp><code>z</code></samp> and the
	    world coordinates (C only).  Transformation functions are
	    provided in the PLplot library:
	    <code>pltr0</code> (<pxref node="&#10;      pltr0; Identity transformation for grid to world&#10;mapping&#10;    " file=""/>) for identity mapping, and <code>pltr1</code> (<pxref node="&#10;      pltr1; Linear interpolation for grid to world&#10;mapping using singly dimensioned coord arrays&#10;    " file=""/>) and <code>pltr2</code> (<pxref node="&#10;      pltr2; Linear interpolation for grid to world&#10;      mapping using doubly dimensioned coord arrays [column&#10;      dominant; as per normal C 2d arrays]&#10;    " file=""/>) for
	    arbitrary mappings respectively defined by one- and
	    two-dimensional arrays.  In addition, user-supplied routines
	    for the transformation can be used as well.  Examples of
	    all of these approaches are given in
	    <ref node="Contour Plots from C" file="">Contour Plots from C</ref>.
	    The transformation function should
	    have the form given by any of <code>pltr0</code> (<pxref node="&#10;      pltr0; Identity transformation for grid to world&#10;mapping&#10;    " file=""/>), <code>pltr1</code> (<pxref node="&#10;      pltr1; Linear interpolation for grid to world&#10;mapping using singly dimensioned coord arrays&#10;    " file=""/>), or <code>pltr2</code> (<pxref node="&#10;      pltr2; Linear interpolation for grid to world&#10;      mapping using doubly dimensioned coord arrays [column&#10;      dominant; as per normal C 2d arrays]&#10;    " file=""/>).
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>pltr_data</code>
	  (<samp>PLPointer</samp>, input)
	</term><listitem><para>
	    Extra parameter to help
	    pass information to <code>pltr0</code> (<pxref node="&#10;      pltr0; Identity transformation for grid to world&#10;mapping&#10;    " file=""/>), <code>pltr1</code> (<pxref node="&#10;      pltr1; Linear interpolation for grid to world&#10;mapping using singly dimensioned coord arrays&#10;    " file=""/>), <code>pltr2</code> (<pxref node="&#10;      pltr2; Linear interpolation for grid to world&#10;      mapping using doubly dimensioned coord arrays [column&#10;      dominant; as per normal C 2d arrays]&#10;    " file=""/>), or whatever routine
	    that is externally supplied.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plvpas; Specify viewport using coordinates and aspect ratio&#10;    " previous="&#10;      plvect; Vector plot&#10;    " next="&#10;      plvpor; Specify viewport using coordinates&#10;    " up="The Common API for PLplot"/><section>
      plvpas: Specify viewport using coordinates and aspect ratio
    </section><para>
      <quotation><para><t>
	  <b>plvpas</b>
	(<i>xmin</i>, <i>xmax</i>, <i>ymin</i>, <i>ymax</i>, <i>aspect</i>);</t></para></quotation>
    </para><para>
      Device-independent routine for setting up the viewport.  The viewport
      is chosen to be the largest with the given aspect ratio that fits
      within the specified region (in terms of normalized subpage
      coordinates).  This routine is functionally equivalent to <code>plvpor</code> (<pxref node="&#10;      plvpor; Specify viewport using coordinates&#10;    " file=""/>)
      when a ``natural'' aspect ratio (0.0) is chosen.  Unlike <code>plvasp</code> (<pxref node="&#10;      plvasp; Specify viewport using aspect ratio only&#10;    " file=""/>),
      this routine reserves no extra space at the edges for labels.
    </para><varlist><varlistentry><term>
	  <code>xmin</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The normalized subpage coordinate of the left-hand edge of the
	    viewport.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xmax</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The normalized subpage coordinate of the right-hand edge of the
	    viewport.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ymin</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The normalized subpage coordinate of the bottom edge of the
	    viewport.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ymax</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The normalized subpage coordinate of the top edge of the
	    viewport.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>aspect</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    Ratio of length of y axis to length of x axis.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plvpor; Specify viewport using coordinates&#10;    " previous="&#10;      plvpas; Specify viewport using coordinates and aspect ratio&#10;    " next="&#10;      plvsta; Select standard viewport&#10;    " up="The Common API for PLplot"/><section>
      plvpor: Specify viewport using coordinates
    </section><para>
      <quotation><para><t>
	  <b>plvpor</b>
	(<i>xmin</i>, <i>xmax</i>, <i>ymin</i>, <i>ymax</i>);</t></para></quotation>
    </para><para>
      Device-independent routine for setting up the viewport.  This defines
      the viewport in terms of normalized subpage coordinates which run
      from 0.0 to 1.0 (left to right and bottom to top) along each edge of
      the current subpage.  Use the alternate routine <code>plsvpa</code> (<pxref node="&#10;      plsvpa; Specify viewport in absolute coordinates&#10;    " file=""/>) in order to
      create a viewport of a definite size.
    </para><varlist><varlistentry><term>
	  <code>xmin</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The normalized subpage coordinate of the left-hand edge of the
	    viewport.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xmax</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The normalized subpage coordinate of the right-hand edge of the
	    viewport.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ymin</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The normalized subpage coordinate of the bottom edge of the
	    viewport.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ymax</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The normalized subpage coordinate of the top edge of the
	    viewport.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plvsta; Select standard viewport&#10;    " previous="&#10;      plvpor; Specify viewport using coordinates&#10;    " next="&#10;      plw3d; Set up window for 3-d plotting&#10;    " up="The Common API for PLplot"/><section>
      plvsta: Select standard viewport
    </section><para>
      <quotation><para><t>
	  <b>plvsta</b>
	();</t></para></quotation>
    </para><para>
      Sets up a standard viewport, leaving a left-hand margin of seven
      character heights, and four character heights around the other three
      sides.
    </para><node name="&#10;      plw3d; Set up window for 3-d plotting&#10;    " previous="&#10;      plvsta; Select standard viewport&#10;    " next="&#10;      plwid; Set pen width&#10;    " up="The Common API for PLplot"/><section>
      plw3d: Set up window for 3-d plotting
    </section><para>
      <quotation><para><t>
	  <b>plw3d</b>
	(<i>basex</i>, <i>basey</i>, <i>height</i>, <i>xmin</i>, <i>xmax</i>, <i>ymin</i>, <i>ymax</i>, <i>zmin</i>, <i>zmax</i>, <i>alt</i>, <i>az</i>);</t></para></quotation>
    </para><para>
      Sets up a window for a three-dimensional surface plot within the
      currently defined two-dimensional window.  The enclosing box for the
      surface plot defined by
      <samp><code>xmin</code></samp>,
      <samp><code>xmax</code></samp>,
      <samp><code>ymin</code></samp>,
      <samp><code>ymax</code></samp>,
      <samp><code>zmin</code></samp> and
      <samp><code>zmax</code></samp> in user-coordinate
      space is mapped into a box of world coordinate size
      <samp><code>basex</code></samp> by
      <samp><code>basey</code></samp> by
      <samp><code>height</code></samp> so that
      <samp><code>xmin</code></samp> maps to
      <samp>-<code>basex</code>/2</samp>,
      <samp><code>xmax</code></samp> maps to
      <samp><code>basex</code>/2</samp>,
      <samp><code>ymin</code></samp> maps to
      <samp>-<code>basey</code>/2</samp>,
      <samp><code>ymax</code></samp> maps to
      <samp><code>basey</code>/2</samp>,
      <samp><code>zmin</code></samp> maps to
      <samp>0</samp> and
      <samp><code>zmax</code></samp> maps to
      <samp><code>height</code></samp>.  The resulting
      world-coordinate box is then viewed by an observer at altitude
      <samp><code>alt</code></samp> and azimuth
      <samp><code>az</code></samp>.  This routine must be
      called before <code> plbox3</code> (<pxref node="&#10;      plbox3; Draw a box with axes; etc; in 3-d&#10;    " file=""/>) or <code>plot3d</code> (<pxref node="&#10;      plot3d; Plot 3-d surface plot&#10;    " file=""/>).  For a more complete description
      of three-dimensional plotting see <ref node="Three Dimensional Surface Plots" file="">Three Dimensional Surface Plots</ref>.
    </para><varlist><varlistentry><term>
	  <code>basex</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The x coordinate size of the world-coordinate box.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>basey</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The y coordinate size of the world-coordinate box.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>height</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The z coordinate size of the world-coordinate box.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xmin</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The minimum user x coordinate value.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xmax</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The maximum user x coordinate value.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ymin</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The minimum user y coordinate value.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ymax</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The maximum user y coordinate value.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>zmin</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The minimum user z coordinate value.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>zmax</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The maximum user z coordinate value.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>alt</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The viewing altitude in degrees above the xy plane.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>az</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The viewing azimuth in degrees.  When
	    <samp><code>az</code>=0</samp>, the observer is
	    looking face onto the zx plane, and as
	    <samp><code>az</code></samp> is increased, the
	    observer moves clockwise around the box when viewed from above
	    the xy plane.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plwid; Set pen width&#10;    " previous="&#10;      plw3d; Set up window for 3-d plotting&#10;    " next="&#10;      plwind; Specify world coordinates of viewport boundaries&#10;    " up="The Common API for PLplot"/><section>
      plwid: Set pen width
    </section><para>
      <quotation><para><t>
	  <b>plwid</b>
	(<i>width</i>);</t></para></quotation>
    </para><para>
      Sets the pen width.
    </para><varlist><varlistentry><term>
	  <code>width</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
The desired pen width.  If <samp><code>width</code></samp>
is negative or the same as the previous value no action is taken.
<samp><code>width</code> = 0</samp> should be interpreted as
as the minimum valid pen width for the device.  The interpretation of positive
<samp><code>width</code></samp> values is also device
dependent.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plwind; Specify world coordinates of viewport boundaries&#10;    " previous="&#10;      plwid; Set pen width&#10;    " next="&#10;      plxormod; Enter or leave xor mode&#10;    " up="The Common API for PLplot"/><section>
      plwind: Specify world coordinates of viewport boundaries
    </section><para>
      <quotation><para><t>
	  <b>plwind</b>
	(<i>xmin</i>, <i>xmax</i>, <i>ymin</i>, <i>ymax</i>);</t></para></quotation>
    </para><para>
      Sets up the world coordinates of the edges of the viewport.
    </para><varlist><varlistentry><term>
	  <code>xmin</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The world x coordinate of the left-hand edge of the viewport.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xmax</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The world x coordinate of the right-hand edge of the viewport.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ymin</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The world y coordinate of the bottom edge of the viewport.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ymax</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    The world y coordinate of the top edge of the viewport.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plxormod; Enter or leave xor mode&#10;    " previous="&#10;      plwind; Specify world coordinates of viewport boundaries&#10;    " up="The Common API for PLplot"/><section>
      plxormod: Enter or leave xor mode
    </section><para>
      <quotation><para><t>
	  <b>plxormod</b>
	(<i>mode</i>, <i>status</i>);</t></para></quotation>
    </para><para>
      Enter (mode !=0) or leave (mode == 0) xor mode for those drivers
      (e.g., the xwin driver) that support it.  Enables erasing plots by
      drawing twice the same line, symbol, etc.  If driver is not capable
      of xor operation returns status of 0.
    </para><varlist><varlistentry><term>
	  <code>mode</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	  mode != 0 means enter xor mode and mode == 0 means leave xor
	  mode.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>status</code>
	  (<samp>PLINT *</samp>, output)
	</term><listitem><para>
	  Pointer to status. Returned status == 1 (0) means driver is capable
	  (incapable) of xor mode.
	  </para></listitem></varlistentry></varlist><node name="The Specialized C API for PLplot" previous="The Common API for PLplot" next="The Specialized Fortran API for PLplot" up="Top"/><chapter>The Specialized C API for PLplot</chapter><para>
  The purpose of this chapter is to document the API for every C function
  in PLplot (other than language bindings) that
  is <i>not</i> part of the common API that has already been
  documented in <ref node="The Common API for PLplot" file="">The Common API for PLplot</ref>.
  </para><para>
  This chapter is a work that is just starting.  There are many C functions
  in the code base that are not part of the common API, and we haven't even
  gotten to the point of listing them all.  What gets documented here now
  is whatever C-explicit code we are trying to understand at the time.
  </para><menu><menuentry node="&#10;      plP_checkdriverinit; Checks to see if any&#10;      of the specified drivers have been initialized&#10;    "><menuentrytitle>
      plP_checkdriverinit: Checks to see if any
      of the specified drivers have been initialized
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plP_getinitdriverlist; Get the initialized-driver&#10;      list&#10;    "><menuentrytitle>
      plP_getinitdriverlist: Get the initialized-driver
      list
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plabort; Error abort&#10;    "><menuentrytitle>
      plabort: Error abort
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plexit; Error exit&#10;    "><menuentrytitle>
      plexit: Error exit
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plgfile; Get output file handle&#10;    "><menuentrytitle>
      plgfile: Get output file handle
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsabort; Set abort handler&#10;    "><menuentrytitle>
      plsabort: Set abort handler
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsexit; Set exit handler&#10;    "><menuentrytitle>
      plsexit: Set exit handler
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsfile; Set output file handle&#10;    "><menuentrytitle>
      plsfile: Set output file handle
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      pltr0; Identity transformation for grid to world&#10;mapping&#10;    "><menuentrytitle>
      pltr0: Identity transformation for grid to world
mapping
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      pltr1; Linear interpolation for grid to world&#10;mapping using singly dimensioned coord arrays&#10;    "><menuentrytitle>
      pltr1: Linear interpolation for grid to world
mapping using singly dimensioned coord arrays
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      pltr2; Linear interpolation for grid to world&#10;      mapping using doubly dimensioned coord arrays [column&#10;      dominant; as per normal C 2d arrays]&#10;    "><menuentrytitle>
      pltr2: Linear interpolation for grid to world
      mapping using doubly dimensioned coord arrays (column
      dominant, as per normal C 2d arrays)
    </menuentrytitle><menuentrydescrip/></menuentry></menu><node name="&#10;      plP_checkdriverinit; Checks to see if any&#10;      of the specified drivers have been initialized&#10;    " next="&#10;      plP_getinitdriverlist; Get the initialized-driver&#10;      list&#10;    " up="The Specialized C API for PLplot"/><section>
      plP_checkdriverinit: Checks to see if any
      of the specified drivers have been initialized
    </section><para>
      <quotation><para><t>
	  <b>plP_checkdriverinit</b>
	(<i>list</i>);</t></para></quotation>
    </para><para> Checks to see if any of the specified drivers have been
     initialized. Function tests a space-delimited list of driver names to
     see how many of the given drivers have been initialized, and how often.
     The return code of the function is: <samp>0</samp> if no matching
     drivers were found to have been initialized; <samp>-1</samp> if
     an error occurred allocating the internal buffer; or, a positive number
     indicating the number of streams encountered that belong to drivers on
     the provided list. This function invokes <code>plP_getinitdriverlist</code> (<pxref node="&#10;      plP_getinitdriverlist; Get the initialized-driver&#10;      list&#10;    " file=""/>)
     internally to get a <i>complete</i> list of drivers that have been initialized
     in order to compare with the driver names specified in the argument list
     to <code>plP_checkdriverinit</code> (<pxref node="&#10;      plP_checkdriverinit; Checks to see if any&#10;      of the specified drivers have been initialized&#10;    " file=""/>).
     </para><varlist><varlistentry><term>
	  <code>list</code>
	  (<samp>char *</samp>, input)
	</term><listitem><para>
	   Pointer to character string specifying a space-delimited
	   list of driver names, e.g., <samp>"bmp jpeg tiff"</samp>.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plP_getinitdriverlist; Get the initialized-driver&#10;      list&#10;    " previous="&#10;      plP_checkdriverinit; Checks to see if any&#10;      of the specified drivers have been initialized&#10;    " next="&#10;      plabort; Error abort&#10;    " up="The Specialized C API for PLplot"/><section>
      plP_getinitdriverlist: Get the initialized-driver
      list
    </section><para>
      <quotation><para><t>
	  <b>plP_getinitdriverlist</b>
	(<i>text_buffer</i>);</t></para></quotation>
    </para><para> Get the initialized-driver list. Function returns a
    space-delimited list of the currently initialized drivers or streams. If more
    than one stream is using the same driver, then its name will be returned
    more than once. The function can be analogously thought of as also
    returning the names of the active streams.  Invoked internally by
    <code>plP_checkdriverinit</code> (<pxref node="&#10;      plP_checkdriverinit; Checks to see if any&#10;      of the specified drivers have been initialized&#10;    " file=""/>). </para><varlist><varlistentry><term>
	  <code>text_buffer</code>
	  (<samp>char *</samp>, output)
	</term><listitem><para>
	    Pointer to a user-allocated buffer to hold the result. The user
            must ensure the buffer is big enough to hold the result.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plabort; Error abort&#10;    " previous="&#10;      plP_getinitdriverlist; Get the initialized-driver&#10;      list&#10;    " next="&#10;      plexit; Error exit&#10;    " up="The Specialized C API for PLplot"/><section>
      plabort: Error abort
    </section><para>
      <quotation><para><t>
	  <b>plabort</b>
	(<i>message</i>);</t></para></quotation>
    </para><para>
      This routine is to be used when something goes wrong that doesn't
      require calling <code>plexit</code> (<pxref node="&#10;      plexit; Error exit&#10;    " file=""/>) but for which there is no useful recovery.
      It calls the abort handler defined via <code>plsabort</code> (<pxref node="&#10;      plsabort; Set abort handler&#10;    " file=""/>), does some cleanup
      and returns. The user can supply his/her own abort handler and pass it
      in via <code>plsabort</code> (<pxref node="&#10;      plsabort; Set abort handler&#10;    " file=""/>).
    </para><varlist><varlistentry><term>
	  <code>message</code>
	  (<samp>char *</samp>, input)
	</term><listitem><para>
	    Abort message.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plexit; Error exit&#10;    " previous="&#10;      plabort; Error abort&#10;    " next="&#10;      plgfile; Get output file handle&#10;    " up="The Specialized C API for PLplot"/><section>
      plexit: Error exit
    </section><para>
      <quotation><para><t>
	  <b>plexit</b>
	(<i>message</i>);</t></para></quotation>
    </para><para>
      This routine is called in case an error is encountered during
      execution of a PLplot routine.  It prints the error message, tries to
      release allocated resources, calls the handler prvided by <code>plsexit</code> (<pxref node="&#10;      plsexit; Set exit handler&#10;    " file=""/>)
      and then exits.  If cleanup needs to be done in the driver program
      then the user may want to supply his/her own exit handler and pass it
      in via <code>plsexit</code> (<pxref node="&#10;      plsexit; Set exit handler&#10;    " file=""/>).  This function should either call <code>plend</code> (<pxref node="&#10;      plend; End plotting session&#10;    " file=""/>) before
      exiting, or simply return.
    </para><varlist><varlistentry><term>
	  <code>message</code>
	  (<samp>char *</samp>, input)
	</term><listitem><para>
	    Error message.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plgfile; Get output file handle&#10;    " previous="&#10;      plexit; Error exit&#10;    " next="&#10;      plsabort; Set abort handler&#10;    " up="The Specialized C API for PLplot"/><section>
      plgfile: Get output file handle
    </section><para>
      <quotation><para><t>
	  <b>plgfile</b>
	(<i>file</i>);</t></para></quotation>
    </para><para>
      Gets the current output file handle, if applicable.
    </para><varlist><varlistentry><term>
	  <code>file</code>
	  (<samp>FILE **</samp>, output)
	</term><listitem><para>
	    File pointer to current output file.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plsabort; Set abort handler&#10;    " previous="&#10;      plgfile; Get output file handle&#10;    " next="&#10;      plsexit; Set exit handler&#10;    " up="The Specialized C API for PLplot"/><section>
      plsabort: Set abort handler
    </section><para>
      <quotation><para><t>
	  <b>plsabort</b>
	(<i>handler</i>);</t></para></quotation>
    </para><para>
      Sets an optional user abort handler.  See <code>plabort</code> (<pxref node="&#10;      plabort; Error abort&#10;    " file=""/>) for details.
    </para><varlist><varlistentry><term>
	  <code>handler</code>
	  (<samp>void (*) (char *)</samp>, input)
	</term><listitem><para>
	    Error abort handler.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plsexit; Set exit handler&#10;    " previous="&#10;      plsabort; Set abort handler&#10;    " next="&#10;      plsfile; Set output file handle&#10;    " up="The Specialized C API for PLplot"/><section>
      plsexit: Set exit handler
    </section><para>
      <quotation><para><t>
	  <b>plsexit</b>
	(<i>handler</i>);</t></para></quotation>
    </para><para>
      Sets an optional user exit handler.  See <code>plexit</code> (<pxref node="&#10;      plexit; Error exit&#10;    " file=""/>) for details.
    </para><varlist><varlistentry><term>
	  <code>handler</code>
	  (<samp>int (*) (char *)</samp>, input)
	</term><listitem><para>
	    Error exit handler.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plsfile; Set output file handle&#10;    " previous="&#10;      plsexit; Set exit handler&#10;    " next="&#10;      pltr0; Identity transformation for grid to world&#10;mapping&#10;    " up="The Specialized C API for PLplot"/><section>
      plsfile: Set output file handle
    </section><para>
      <quotation><para><t>
	  <b>plsfile</b>
	(<i>file</i>);</t></para></quotation>
    </para><para>
      Sets the current output file handle, if applicable.  If the file has
      has not been previously opened and is required by the driver, the
      user will be prompted for the file name.  This routine, if used, must
      be called before initializing PLplot.
    </para><varlist><varlistentry><term>
	  <code>file</code>
	  (<samp>FILE *</samp>, input)
	</term><listitem><para>
	    File pointer.
	  </para></listitem></varlistentry></varlist><node name="&#10;      pltr0; Identity transformation for grid to world&#10;mapping&#10;    " previous="&#10;      plsfile; Set output file handle&#10;    " next="&#10;      pltr1; Linear interpolation for grid to world&#10;mapping using singly dimensioned coord arrays&#10;    " up="The Specialized C API for PLplot"/><section>
      pltr0: Identity transformation for grid to world
mapping
    </section><para>
      <quotation><para><t>
	  <b>pltr0</b>
	(<i>x</i>, <i>y</i>, <i>tx</i>, <i>ty</i>, <i>pltr_data</i>);</t></para></quotation>
    </para><para>
    Identity transformation for grid to world mapping.
    This routine can be used both for <code>plcont</code> (<pxref node="&#10;      plcont; Contour plot&#10;    " file=""/>) and <code>plshade</code> (<pxref node="&#10;      plshade;  Shade individual region on the basis of value&#10;    " file=""/>).
    See also <ref node="Contour Plots from C" file="">Contour Plots from C</ref> and
    <ref node="Shade Plots from C" file="">Shade Plots from C</ref>.
    </para><varlist><varlistentry><term>
	  <code>x</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    X-position in grid coordinates.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>y</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    Y-position in grid coordinates.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>tx</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
	    X-position in world coordinates.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ty</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
	    Y-position in world coordinates.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>pltr_data</code>
	  (<samp>PLPointer</samp>, input)
	</term><listitem><para>
	    Pointer to additional input data that is passed as an argument
	    to <code>plcont</code> (<pxref node="&#10;      plcont; Contour plot&#10;    " file=""/>) or <code>plshade</code> (<pxref node="&#10;      plshade;  Shade individual region on the basis of value&#10;    " file=""/>) and then on to the grid to world
	    transformation routine.
	  </para></listitem></varlistentry></varlist><node name="&#10;      pltr1; Linear interpolation for grid to world&#10;mapping using singly dimensioned coord arrays&#10;    " previous="&#10;      pltr0; Identity transformation for grid to world&#10;mapping&#10;    " next="&#10;      pltr2; Linear interpolation for grid to world&#10;      mapping using doubly dimensioned coord arrays [column&#10;      dominant; as per normal C 2d arrays]&#10;    " up="The Specialized C API for PLplot"/><section>
      pltr1: Linear interpolation for grid to world
mapping using singly dimensioned coord arrays
    </section><para>
      <quotation><para><t>
	  <b>pltr1</b>
	(<i>x</i>, <i>y</i>, <i>tx</i>, <i>ty</i>, <i>pltr_data</i>);</t></para></quotation>
    </para><para>
    Linear interpolation for grid to world mapping using singly
    dimensioned coord arrays.
    This routine can be used both for <code>plcont</code> (<pxref node="&#10;      plcont; Contour plot&#10;    " file=""/>) and <code>plshade</code> (<pxref node="&#10;      plshade;  Shade individual region on the basis of value&#10;    " file=""/>).
    See also <ref node="Contour Plots from C" file="">Contour Plots from C</ref> and
    <ref node="Shade Plots from C" file="">Shade Plots from C</ref>.
    </para><varlist><varlistentry><term>
	  <code>x</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    X-position in grid coordinates.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>y</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    Y-position in grid coordinates.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>tx</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
	    X-position in world coordinates.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ty</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
	    Y-position in world coordinates.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>pltr_data</code>
	  (<samp>PLPointer</samp>, input)
	</term><listitem><para>
	    Pointer to additional input data that is passed as an argument
	    to <code>plcont</code> (<pxref node="&#10;      plcont; Contour plot&#10;    " file=""/>) or <code>plshade</code> (<pxref node="&#10;      plshade;  Shade individual region on the basis of value&#10;    " file=""/>) and then on to the grid to world
	    transformation routine.
	  </para></listitem></varlistentry></varlist><node name="&#10;      pltr2; Linear interpolation for grid to world&#10;      mapping using doubly dimensioned coord arrays [column&#10;      dominant; as per normal C 2d arrays]&#10;    " previous="&#10;      pltr1; Linear interpolation for grid to world&#10;mapping using singly dimensioned coord arrays&#10;    " up="The Specialized C API for PLplot"/><section>
      pltr2: Linear interpolation for grid to world
      mapping using doubly dimensioned coord arrays (column
      dominant, as per normal C 2d arrays)
    </section><para>
      <quotation><para><t>
	  <b>pltr2</b>
	(<i>x</i>, <i>y</i>, <i>tx</i>, <i>ty</i>, <i>pltr_data</i>);</t></para></quotation>
    </para><para>
    Linear interpolation for grid to world mapping using doubly
    dimensioned coord arrays (column dominant, as per normal C 2d arrays).
    This routine can be used both for <code>plcont</code> (<pxref node="&#10;      plcont; Contour plot&#10;    " file=""/>) and <code>plshade</code> (<pxref node="&#10;      plshade;  Shade individual region on the basis of value&#10;    " file=""/>).
    See also <ref node="Contour Plots from C" file="">Contour Plots from C</ref> and
    <ref node="Shade Plots from C" file="">Shade Plots from C</ref>.
    </para><varlist><varlistentry><term>
	  <code>x</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    X-position in grid coordinates.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>y</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
	    Y-position in grid coordinates.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>tx</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
	    X-position in world coordinates.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ty</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
	    Y-position in world coordinates.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>pltr_data</code>
	  (<samp>PLPointer</samp>, input)
	</term><listitem><para>
	    Pointer to additional input data that is passed as an argument
	    to <code>plcont</code> (<pxref node="&#10;      plcont; Contour plot&#10;    " file=""/>) or <code>plshade</code> (<pxref node="&#10;      plshade;  Shade individual region on the basis of value&#10;    " file=""/>) and then on to the grid to world
	    transformation routine.
	  </para></listitem></varlistentry></varlist><node name="The Specialized Fortran API for PLplot" previous="The Specialized C API for PLplot" next="API compatibility definition" up="Top"/><chapter>The Specialized Fortran API for PLplot</chapter><para>
  The purpose of this Chapter is to document the API for each Fortran function
  in PLplot that differs substantially (usually in argument lists)
  from the common API that has already been
  documented in <ref node="The Common API for PLplot" file="">The Common API for PLplot</ref>.
  </para><para>
  Normally, the common API is wrapped in such a way for Fortran that there is
  and one-to-one correspondence between each fortran and C argument
  (see <ref node="Fortran Language" file="">Fortran Language</ref>
  for discussion).  However, for certain routines documented in this
  chapter the fortran argument lists
  necessarily differ substantially from the C versions.
  </para><para>
  This chapter is incomplete and NEEDS DOCUMENTATION of, e.g., the fortran
  equivalent of the plshade C routines.
  </para><menu><menuentry node="&#10;      plcon0; Contour plot; identity mapping for fortran&#10;    "><menuentrytitle>
      plcon0: Contour plot, identity mapping for fortran
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plcon1; Contour plot; general 1-d mapping for&#10;fortran&#10;    "><menuentrytitle>
      plcon1: Contour plot, general 1-d mapping for
fortran
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plcon2; Contour plot; general 2-d mapping for&#10;fortran&#10;    "><menuentrytitle>
      plcon2: Contour plot, general 2-d mapping for
fortran
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plcont; Contour plot; fixed linear mapping for&#10;fortran&#10;    "><menuentrytitle>
      plcont: Contour plot, fixed linear mapping for
fortran
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plvec0; Vector plot; identity mapping for fortran&#10;    "><menuentrytitle>
      plvec0: Vector plot, identity mapping for fortran
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plvec1; Vector plot; general 1-d mapping for&#10;fortran&#10;    "><menuentrytitle>
      plvec1: Vector plot, general 1-d mapping for
fortran
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plvec2; Vector plot; general 2-d mapping for&#10;fortran&#10;    "><menuentrytitle>
      plvec2: Vector plot, general 2-d mapping for
fortran
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plvect; Vector plot; fixed linear mapping for&#10;fortran&#10;    "><menuentrytitle>
      plvect: Vector plot, fixed linear mapping for
fortran
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plmesh; Plot surface mesh for fortran&#10;    "><menuentrytitle>
      plmesh: Plot surface mesh for fortran
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plot3d; Plot 3-d surface plot for fortran&#10;    "><menuentrytitle>
      plot3d: Plot 3-d surface plot for fortran
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plparseopts; parse arguments for fortran&#10;    "><menuentrytitle>
      plparseopts: parse arguments for fortran
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plsesc; Set the escape character for text strings&#10;for fortran&#10;    "><menuentrytitle>
      plsesc: Set the escape character for text strings
for fortran
    </menuentrytitle><menuentrydescrip/></menuentry></menu><node name="&#10;      plcon0; Contour plot; identity mapping for fortran&#10;    " next="&#10;      plcon1; Contour plot; general 1-d mapping for&#10;fortran&#10;    " up="The Specialized Fortran API for PLplot"/><section>
      plcon0: Contour plot, identity mapping for fortran
    </section><para>
      <quotation><para><t>
	  <b>plcon0</b>
	(<i>z</i>, <i>nx</i>, <i>ny</i>, <i>kx</i>, <i>lx</i>, <i>ky</i>, <i>ly</i>, <i>clevel</i>, <i>nlevel</i>);</t></para></quotation>
    </para><para>
      Draws a contour plot of the data in
      <samp><code>z</code>[<code>nx</code>][<code>ny</code>]</samp>,
      using the <samp><code>nlevel</code></samp> contour
      levels specified by <samp><code>clevel</code></samp>.
      Only the region of the array from
      <samp><code>kx</code></samp> to
      <samp><code>lx</code></samp> and from
      <samp><code>ky</code></samp> to
      <samp><code>ly</code></samp> is plotted out.  See
      <ref node="Contour and Shade Plots" file="">Contour and Shade Plots</ref> for more information.
    </para><varlist><varlistentry><term>
	  <code>z</code>
	  (<samp>PLFLT **</samp>, input)
	</term><listitem><para>
	    Pointer to a vectored two-dimensional array containing data to
	    be contoured.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nx, ny</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Physical dimensions of array
	    <samp><code>z</code></samp>.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>kx, lx</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Range of <samp>x</samp> indices to consider.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ky, ly</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Range of <samp>y</samp> indices to consider.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>clevel</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array specifying levels at which to draw contours.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nlevel</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of contour levels to draw.
	  </para></listitem></varlistentry></varlist><para>
      NOTE: this function is intended for use from a Fortran caller only.
      The C user should instead call <code>plcont</code> (<pxref node="&#10;      plcont; Contour plot&#10;    " file=""/>) using the built-in
      transformation function <code>pltr0</code> for the same
      capability.
    </para><node name="&#10;      plcon1; Contour plot; general 1-d mapping for&#10;fortran&#10;    " previous="&#10;      plcon0; Contour plot; identity mapping for fortran&#10;    " next="&#10;      plcon2; Contour plot; general 2-d mapping for&#10;fortran&#10;    " up="The Specialized Fortran API for PLplot"/><section>
      plcon1: Contour plot, general 1-d mapping for
fortran
    </section><para>
      <quotation><para><t>
	  <b>plcon1</b>
	(<i>z</i>, <i>nx</i>, <i>ny</i>, <i>kx</i>, <i>lx</i>, <i>ky</i>, <i>ly</i>, <i>clevel</i>, <i>nlevel</i>, <i>xg</i>, <i>yg</i>);</t></para></quotation>
    </para><para>
      Draws a contour plot of the data in
      <samp><code>z</code>[<code>nx</code>][<code>ny</code>]</samp>,
      using the <samp><code>nlevel</code></samp> contour
      levels specified by <samp><code>clevel</code></samp>.
      Only the region of the array from
      <samp><code>kx</code></samp> to
      <samp><code>lx</code></samp> and from
      <samp><code>ky</code></samp> to
      <samp><code>ly</code></samp> is plotted out.  The
      arrays <samp><code>xg</code></samp> and
      <samp><code>yg</code></samp> are used to specify the
      transformation between array indices and world coordinates.  See
      <ref node="Contour and Shade Plots" file="">Contour and Shade Plots</ref> for more information.
    </para><varlist><varlistentry><term>
	  <code>z</code>
	  (<samp>PLFLT **</samp>, input)
	</term><listitem><para>
	    Pointer to a vectored two-dimensional array containing data to
	    be contoured.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nx, ny</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Physical dimensions of array
	    <samp><code>z</code></samp>.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>kx, lx</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Range of <samp>x</samp> indices to consider.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ky, ly</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Range of <samp>y</samp> indices to consider.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>clevel</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array specifying levels at which to draw contours.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nlevel</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of contour levels to draw.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xg, yg</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointers to arrays which specify the transformation from array
	    indices to world coordinates.  These must be one-dimensional
	    arrays, used for a transformation of the form:
	    <samp>tx</samp> = <samp>f(x)</samp>,
	    <samp>ty</samp> = <samp>f(y)</samp>.  Function
	    values at locations between grid points are obtained via linear
	    interpolation.
	  </para></listitem></varlistentry></varlist><para>
      NOTE: this function is intended for use from a Fortran caller only.
      The C user should instead call <code>plcont</code> (<pxref node="&#10;      plcont; Contour plot&#10;    " file=""/>) using the built-in
      transformation function <code>pltr1</code> for the same
      capability.
    </para><node name="&#10;      plcon2; Contour plot; general 2-d mapping for&#10;fortran&#10;    " previous="&#10;      plcon1; Contour plot; general 1-d mapping for&#10;fortran&#10;    " next="&#10;      plcont; Contour plot; fixed linear mapping for&#10;fortran&#10;    " up="The Specialized Fortran API for PLplot"/><section>
      plcon2: Contour plot, general 2-d mapping for
fortran
    </section><para>
      <quotation><para><t>
	  <b>plcon2</b>
	(<i>z</i>, <i>nx</i>, <i>ny</i>, <i>kx</i>, <i>lx</i>, <i>ky</i>, <i>ly</i>, <i>clevel</i>, <i>nlevel</i>, <i>xg</i>, <i>yg</i>);</t></para></quotation>
    </para><para>
      Draws a contour plot of the data in
      <samp><code>z</code>[<code>nx</code>][<code>ny</code>]</samp>,
      using the <samp><code>nlevel</code></samp> contour
      levels specified by <samp><code>clevel</code></samp>.
      Only the region of the array from
      <samp><code>kx</code></samp> to
      <samp><code>lx</code></samp> and from
      <samp><code>ky</code></samp> to
      <samp><code>ly</code></samp> is plotted out.  The
      arrays <samp><code>xg</code></samp> and
      <samp><code>yg</code></samp> are used to specify the
      transformation between array indices and world coordinates.  See
      <ref node="Contour and Shade Plots" file="">Contour and Shade Plots</ref> for more information.
    </para><varlist><varlistentry><term>
	  <code>z</code>
	  (<samp>PLFLT **</samp>, input)
	</term><listitem><para>
	    Pointer to a vectored two-dimensional array containing data to
	    be contoured.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nx, ny</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Physical dimensions of array
	    <samp><code>z</code></samp>.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>kx, lx</code> (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Range of <samp>x</samp> indices to consider.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>ky, ly</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Range of <samp>y</samp> indices to consider.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>clevel</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointer to array specifying levels at which to draw contours.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nlevel</code> (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Number of contour levels to draw.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xg, yg</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointers to arrays which specify the transformation from array
	    indices to world coordinates.  These must be two-dimensional
	    arrays, used for a transformation of the form:
	    <samp>tx</samp> = <samp>f(x, y)</samp>,
	    <samp>ty</samp> = <samp>f(x, y)</samp>.  Function
	    values at locations between grid points are obtained via linear
	    interpolation.
	  </para></listitem></varlistentry></varlist><para>
      NOTE: this function is intended for use from a Fortran caller only.
      The C user should instead call <code>plcont</code> (<pxref node="&#10;      plcont; Contour plot&#10;    " file=""/>) using the built-in
      transformation function <code>pltr2</code> for the same
      capability.
    </para><node name="&#10;      plcont; Contour plot; fixed linear mapping for&#10;fortran&#10;    " previous="&#10;      plcon2; Contour plot; general 2-d mapping for&#10;fortran&#10;    " next="&#10;      plvec0; Vector plot; identity mapping for fortran&#10;    " up="The Specialized Fortran API for PLplot"/><section>
      plcont: Contour plot, fixed linear mapping for
fortran
    </section><para>
      <quotation><para><t>
	  <b>plcont</b>
	(<i>z</i>, <i>nx</i>, <i>ny</i>, <i>kx</i>, <i>lx</i>, <i>ky</i>, <i>ly</i>, <i>clevel</i>, <i>nlevel</i>);</t></para></quotation>
    </para><para>
      When called from Fortran, this routine has the same effect as when
      invoked from C.  The interpretation of all parameters (see <code>plcont</code> (<pxref node="&#10;      plcont; Contour plot&#10;    " file=""/>))
      is also the same except there is no transformation function supplied
      as the last parameter.  Instead, a 6-element array specifying
      coefficients to use in the transformation is supplied via the named
      common block <samp>plplot</samp> (see code). Since this
      approach is somewhat inflexible, the user is recommended to call
      either of <code>plcon0</code> (<pxref node="&#10;      plcon0; Contour plot; identity mapping for fortran&#10;    " file=""/>), <code>plcon1</code> (<pxref node="&#10;      plcon1; Contour plot; general 1-d mapping for&#10;fortran&#10;    " file=""/>), or <code>plcon2</code> (<pxref node="&#10;      plcon2; Contour plot; general 2-d mapping for&#10;fortran&#10;    " file=""/>) instead.
    </para><node name="&#10;      plvec0; Vector plot; identity mapping for fortran&#10;    " previous="&#10;      plcont; Contour plot; fixed linear mapping for&#10;fortran&#10;    " next="&#10;      plvec1; Vector plot; general 1-d mapping for&#10;fortran&#10;    " up="The Specialized Fortran API for PLplot"/><section>
      plvec0: Vector plot, identity mapping for fortran
    </section><para>
      <quotation><para><t>
	  <b>plvec0</b>
	(<i>u</i>, <i>v</i>, <i>nx</i>, <i>ny</i>, <i>scale</i>);</t></para></quotation>
    </para><para>
      Draws a vector plot of the data in
      <samp>(<code>u</code>[<code>nx</code>][<code>ny</code>], <code>v</code>[<code>nx</code>][<code>ny</code>])</samp>.
    </para><varlist><varlistentry><term>
	  <code>u, v</code>
	  (<samp>PLFLT **</samp>, input)
	</term><listitem><para>
	    Pointer to a pair of vectored two-dimensional arrays containing
	    the x and y components of the vector to be plotted.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nx, ny</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Physical dimensions of the arrays
	    <samp><code>u</code></samp> and
	    <samp><code>v</code></samp>.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>scale</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
             Parameter to control the scaling factor of the vectors for plotting.
             If <samp><code>scale</code> = 0</samp> then
	     the scaling factor is automatically calculated for the data.
	     If <samp><code>scale</code> &lt; 0</samp> then
	     the scaling factor is automatically calculated for the data and
             then multiplied by <samp>-<code>scale</code></samp>.
             If <samp><code>scale</code> &gt; 0</samp> then
             the scaling factor is set to <samp><code>scale</code></samp>.
	  </para></listitem></varlistentry></varlist><para>
      NOTE: this function is intended for use from a Fortran caller only.
      The C user should instead call <code>plvect</code> (<pxref node="&#10;      plvect; Vector plot&#10;    " file=""/>) using the built-in
      transformation function <code>pltr0</code> for the same
      capability.
    </para><node name="&#10;      plvec1; Vector plot; general 1-d mapping for&#10;fortran&#10;    " previous="&#10;      plvec0; Vector plot; identity mapping for fortran&#10;    " next="&#10;      plvec2; Vector plot; general 2-d mapping for&#10;fortran&#10;    " up="The Specialized Fortran API for PLplot"/><section>
      plvec1: Vector plot, general 1-d mapping for
fortran
    </section><para>
      <quotation><para><t>
	  <b>plvec1</b>
	(<i>u</i>, <i>v</i>, <i>nx</i>, <i>ny</i>, <i>scale</i>, <i>xg</i>, <i>yg</i>);</t></para></quotation>
    </para><para>
      Draws a vector plot of the data in
      <samp>(<code>u</code>[<code>nx</code>][<code>ny</code>], <code>v</code>[<code>nx</code>][<code>ny</code>])</samp>.
    </para><varlist><varlistentry><term>
	  <code>u, v</code>
	  (<samp>PLFLT **</samp>, input)
	</term><listitem><para>
	    Pointer to a pair of vectored two-dimensional arrays containing
	    the x and y components of the vector to be plotted.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nx, ny</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Physical dimensions of the arrays
	    <samp><code>u</code></samp> and
	    <samp><code>v</code></samp>.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>scale</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
             Parameter to control the scaling factor of the vectors for plotting.
             If <samp><code>scale</code> = 0</samp> then
	     the scaling factor is automatically calculated for the data.
	     If <samp><code>scale</code> &lt; 0</samp> then
	     the scaling factor is automatically calculated for the data and
             then multiplied by <samp>-<code>scale</code></samp>.
             If <samp><code>scale</code> &gt; 0</samp> then
             the scaling factor is set to <samp><code>scale</code></samp>.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xg, yg</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointers to arrays which specify the transformation from array
	    indices to world coordinates.  These must be one-dimensional
	    arrays, used for a transformation of the form:
	    <samp>tx</samp> = <samp>f(x)</samp>,
	    <samp>ty</samp> = <samp>f(y)</samp>.  Function
	    values at locations between grid points are obtained via linear
	    interpolation.
	  </para></listitem></varlistentry></varlist><para>
      NOTE: this function is intended for use from a Fortran caller only.
      The C user should instead call <code>plvect</code> (<pxref node="&#10;      plvect; Vector plot&#10;    " file=""/>) using the built-in
      transformation function <code>pltr1</code> for the same
      capability.
    </para><node name="&#10;      plvec2; Vector plot; general 2-d mapping for&#10;fortran&#10;    " previous="&#10;      plvec1; Vector plot; general 1-d mapping for&#10;fortran&#10;    " next="&#10;      plvect; Vector plot; fixed linear mapping for&#10;fortran&#10;    " up="The Specialized Fortran API for PLplot"/><section>
      plvec2: Vector plot, general 2-d mapping for
fortran
    </section><para>
      <quotation><para><t>
	  <b>plvec2</b>
	(<i>u</i>, <i>v</i>, <i>nx</i>, <i>ny</i>, <i>scale</i>, <i>xg</i>, <i>yg</i>);</t></para></quotation>
    </para><para>
      Draws a vector plot of the data in
      <samp>(<code>u</code>[<code>nx</code>][<code>ny</code>], <code>v</code>[<code>nx</code>][<code>ny</code>])</samp>.
    </para><varlist><varlistentry><term>
	  <code>u, v</code>
	  (<samp>PLFLT **</samp>, input)
	</term><listitem><para>
	    Pointer to a pair of vectored two-dimensional arrays containing
	    the x and y components of the vector to be plotted.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>nx, ny</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Physical dimensions of the arrays
	    <samp><code>u</code></samp> and
	    <samp><code>v</code></samp>.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>scale</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
             Parameter to control the scaling factor of the vectors for plotting.
             If <samp><code>scale</code> = 0</samp> then
	     the scaling factor is automatically calculated for the data.
	     If <samp><code>scale</code> &lt; 0</samp> then
	     the scaling factor is automatically calculated for the data and
             then multiplied by <samp>-<code>scale</code></samp>.
             If <samp><code>scale</code> &gt; 0</samp> then
             the scaling factor is set to <samp><code>scale</code></samp>.
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>xg, yg</code>
	  (<samp>PLFLT *</samp>, input)
	</term><listitem><para>
	    Pointers to arrays which specify the transformation from array
	    indices to world coordinates.  These must be two-dimensional
	    arrays, used for a transformation of the form:
	    <samp>tx</samp> = <samp>f(x, y)</samp>,
	    <samp>ty</samp> = <samp>f(x, y)</samp>.  Function
	    values at locations between grid points are obtained via linear
	    interpolation.
	  </para></listitem></varlistentry></varlist><para>
      NOTE: this function is intended for use from a Fortran caller only.
      The C user should instead call <code>plvect</code> (<pxref node="&#10;      plvect; Vector plot&#10;    " file=""/>) using the built-in
      transformation function <code>pltr2</code> for the same
      capability.
    </para><node name="&#10;      plvect; Vector plot; fixed linear mapping for&#10;fortran&#10;    " previous="&#10;      plvec2; Vector plot; general 2-d mapping for&#10;fortran&#10;    " next="&#10;      plmesh; Plot surface mesh for fortran&#10;    " up="The Specialized Fortran API for PLplot"/><section>
      plvect: Vector plot, fixed linear mapping for
fortran
    </section><para>
      <quotation><para><t>
	  <b>plvect</b>
	(<i>u</i>, <i>v</i>, <i>nx</i>, <i>ny</i>, <i>scale</i>);</t></para></quotation>
    </para><para>
      When called from Fortran, this routine has the same effect as when
      invoked from C.  The interpretation of all parameters (see <code>plvect</code> (<pxref node="&#10;      plvect; Vector plot&#10;    " file=""/>))
      is also the same except there is no transformation function supplied
      as the last parameter.  Instead, a 6-element array specifying
      coefficients to use in the transformation is supplied via the named
      common block <samp>plplot</samp> (see code). Since this
      approach is somewhat inflexible, the user is recommended to call
      either of <code>plvec0</code> (<pxref node="&#10;      plvec0; Vector plot; identity mapping for fortran&#10;    " file=""/>), <code>plvec1</code> (<pxref node="&#10;      plvec1; Vector plot; general 1-d mapping for&#10;fortran&#10;    " file=""/>), or <code>plvec2</code> (<pxref node="&#10;      plvec2; Vector plot; general 2-d mapping for&#10;fortran&#10;    " file=""/>) instead.
    </para><node name="&#10;      plmesh; Plot surface mesh for fortran&#10;    " previous="&#10;      plvect; Vector plot; fixed linear mapping for&#10;fortran&#10;    " next="&#10;      plot3d; Plot 3-d surface plot for fortran&#10;    " up="The Specialized Fortran API for PLplot"/><section>
      plmesh: Plot surface mesh for fortran
    </section><para>
      <quotation><para><t>
	  <b>plmesh</b>
	(<i>x</i>, <i>y</i>, <i>z</i>, <i>nx</i>, <i>ny</i>, <i>opt</i>, <i>mx</i>);</t></para></quotation>
    </para><para>
      When called from Fortran, this routine has the same effect as when
      invoked from C.  The interpretation of all parameters (see <code>plmesh</code> (<pxref node="&#10;      plmesh; Plot surface mesh&#10;    " file=""/>))
      is also the same except there is an additional parameter given by:
    </para><varlist><varlistentry><term>
	  <code>mx</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Length of array in x direction, for plotting subarrays.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plot3d; Plot 3-d surface plot for fortran&#10;    " previous="&#10;      plmesh; Plot surface mesh for fortran&#10;    " next="&#10;      plparseopts; parse arguments for fortran&#10;    " up="The Specialized Fortran API for PLplot"/><section>
      plot3d: Plot 3-d surface plot for fortran
    </section><para>
      <quotation><para><t>
	  <b>plot3d</b>
	(<i>x</i>, <i>y</i>, <i>z</i>, <i>nx</i>, <i>ny</i>, <i>opt</i>, <i>side</i>, <i>mx</i>);</t></para></quotation>
    </para><para>
      When called from Fortran, this routine has the same effect as when
      invoked from C.  The interpretation of all parameters (see <code>plot3d</code> (<pxref node="&#10;      plot3d; Plot 3-d surface plot&#10;    " file=""/>))
      is also the same except there is an additional parameter given by:
    </para><varlist><varlistentry><term>
	  <code>mx</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Length of array in x direction, for plotting subarrays.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plparseopts; parse arguments for fortran&#10;    " previous="&#10;      plot3d; Plot 3-d surface plot for fortran&#10;    " next="&#10;      plsesc; Set the escape character for text strings&#10;for fortran&#10;    " up="The Specialized Fortran API for PLplot"/><section>
      plparseopts: parse arguments for fortran
    </section><para>
      <quotation><para><t>
	  <b>plparseopts</b>
	(<i>mode</i>);</t></para></quotation>
    </para><para> When called from Fortran, this routine has the same effect as
      when invoked from C (see <code>plparseopts</code> (<pxref node="&#10;      plparseopts; Parse command-line arguments&#10;    " file=""/>)) except that the argument list
      just contains the parsing mode and the fortran system routines
      <code>iargc</code> and <code>getarg</code> 
      are used internally to obtain the number of arguments and
      argument values.  (Note, during configuration, the user's
      fortran compiler
      is checked to see whether it supports 
      <code>iargc</code> and <code>getarg</code>.  If it
      does not, the fortran plparseopts simply writes a warning message
      and returns.
    </para><varlist><varlistentry><term>
	  <code>mode</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
	    Parsing mode; see <code>plparseopts</code> (<pxref node="&#10;      plparseopts; Parse command-line arguments&#10;    " file=""/>) for details.
	  </para></listitem></varlistentry></varlist><node name="&#10;      plsesc; Set the escape character for text strings&#10;for fortran&#10;    " previous="&#10;      plparseopts; parse arguments for fortran&#10;    " up="The Specialized Fortran API for PLplot"/><section>
      plsesc: Set the escape character for text strings
for fortran
    </section><para>
      <quotation><para><t>
           <b>plsesc</b>
        (<i>esc</i>);</t></para></quotation>
    </para><para>
    Set the escape character for text strings.  From
    Fortran it needs to be the decimal ASCII value.  Only
    selected characters are allowed to prevent the user from shooting
    himself in the foot (For example, a \ isn't allowed since it conflicts with C's use
    of backslash as a character escape).  Here are the allowed escape
characters and their corresponding decimal ASCII values:
<itemize markchar="•"><listitem><para>
  !, ASCII 33
</para></listitem><listitem><para>
  #, ASCII 35
</para></listitem><listitem><para>
  $, ASCII 36
</para></listitem><listitem><para>
  %, ASCII 37
</para></listitem><listitem><para>
  &amp;, ASCII 38
</para></listitem><listitem><para>
  *, ASCII 42
</para></listitem><listitem><para>
  @, ASCII 64
</para></listitem><listitem><para>
  ^, ASCII 94
</para></listitem><listitem><para>
  ~, ASCII 126
</para></listitem></itemize>
    </para><varlist><varlistentry><term>
	  <code>esc</code>
	  (<samp>char</samp>, input)
	</term><listitem><para>
            NEEDS DOCUMENTATION
	  </para></listitem></varlistentry></varlist><node name="API compatibility definition" previous="The Specialized Fortran API for PLplot" next="Obsolete/Deprecated API for PLplot" up="Top"/><chapter>API compatibility definition</chapter><para>
    This chapter presents the formal definition of what is considered to be
    in the PLplot library API.  It is assumed that major new releases of
    PLplot will have substantial backwards incompatible changes in the API,
    but the PLplot developers commit to introducing as few as possible of
    such incompatibilities between minor releases such that stability
    across those minor releases is practically guaranteed.  In all cases
    where backwards incompatible changes have been introduced, then the
    library soname will be changed (for operating systems such as Linux
    that support versioned shared libraries).
  </para><para>
    The information in this chapter regards version 5.5.3 of
    PLplot, released on 2005-05-13.
  </para><menu><menuentry node="&#10;      What is in the API?&#10;    "><menuentrytitle>
      What is in the API?
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      Regression test for backwards compatibility&#10;    "><menuentrytitle>
      Regression test for backwards compatibility
    </menuentrytitle><menuentrydescrip/></menuentry></menu><node name="&#10;      What is in the API?&#10;    " next="&#10;      Regression test for backwards compatibility&#10;    " up="API compatibility definition"/><section>
      What is in the API?
    </section><para>
      The formal definition of the PLplot C API is everything that is defined
      in the include file <file>plplot.h</file>.  This includes all
      the function prototypes, the defined structures and the semantics of
      the constants.  The list of symbols currently exported by the shared
      library <file>libplplot.h</file> that are declared in
      <file>plplot.h</file> is the following:
    </para><para>
      <example>plAlloc2dGrid          plgdidev               plscmap1n
plClearOpts            plgdiori               plscol0
plFindCommand          plgdiplt               plscolbg
plFindName             plgesc                 plscolor
plFree2dGrid           plgfam                 plscompression
plGetCursor            plgfci                 plsdev
plGetFlt               plgfile                plsdidev
plGetInt               plgfnam                plsdimap
plGetName              plglevel               plsdiori
plHLS_RGB              plgpage                plsdiplt
plMergeOpts            plgra                  plsdiplz
plMinMax2dGrid         plgriddata             plseopH
plOptUsage             plgspa                 plsesc
plParseOpts            plgstrm                plsetopt
plRGB_HLS              plgver                 plsexit
plResetOpts            plgvpd                 plsfam
plSetOpt               plgvpw                 plsfci
plSetUsage             plgxax                 plsfile
plTranslateCursor      plgyax                 plsfnam
pl_cmd                 plgzax                 plshade
pl_setcontlabelformat  plhist                 plshade1
pl_setcontlabelparam   plhls                  plshades
pladv                  plhlsrgb               plsmaj
plarrows               plimage                plsmem
plaxes                 plinit                 plsmin
plbin                  pljoin                 plsori
plbop                  pllab                  plspage
plbox                  pllightsource          plspause
plbox3                 plline                 plsstrm
plcalc_world           plline3                plssub
plclear                pllsty                 plssym
plcol0                 plmap                  plstar
plcol1                 plmeridians            plstart
plcont                 plmesh                 plstr
plcpstrm               plmeshc                plstripa
pldid2pc               plmkstrm               plstripc
pldip2dc               plmtex                 plstripd
plend                  plot3d                 plstyl
plend1                 plot3dc                plsurf3d
plenv                  plot3dcl               plsurf3dl
plenv0                 plparseopts            plsvect
pleop                  plpat                  plsvpa
plerrx                 plpoin                 plsxax
plerry                 plpoin3                plsxwin
plf2eval               plpoly3                plsyax
plf2eval2              plprec                 plsym
plf2evalr              plpsty                 plszax
plfamadv               plptex                 pltext
plfcont                plreplot               pltr0
plfill                 plrgb                  pltr1
plfill3                plrgb1                 pltr2
plflush                plrgbhls               pltr2p
plfont                 plsButtonEH            plvasp
plfontld               plsError               plvect
plfshade               plsKeyEH               plvpas
plgDevs                plsabort               plvpor
plgFileDevs            plsbopH                plvsta
plgchr                 plschr                 plw3d
plgcol0                plscmap0               plwid
plgcolbg               plscmap0n              plwind
plgcompression         plscmap1               plxormod
plgdev                 plscmap1l              
</example>
    </para><para>
      Another important aspect of compatibility regard the Application
      Binary Interface (ABI).  Backwards compatibility can be broken by
      changes in the C structures made public through
      <file>plplot.h</file>.  Currently, they are:
    </para><para>
      <example>typedef struct {
    char *opt;
    int  (*handler)	(char *, char *, void *);
    void *client_data;
    void *var;
    long mode;
    char *syntax;
    char *desc;
} PLOptionTable;

typedef struct {
    int type;			/* of event (CURRENTLY UNUSED) */
    unsigned int state;		/* key or button mask */
    unsigned int keysym;	/* key selected */
    unsigned int button;	/* mouse button selected */
    PLINT subwindow;            /* subwindow (alias subpage, alias subplot) number */
    char string[PL_MAXKEY];	/* translated string */
    int pX, pY;			/* absolute device coordinates of pointer */
    PLFLT dX, dY;		/* relative device coordinates of pointer */
    PLFLT wX, wY;		/* world coordinates of pointer */
} PLGraphicsIn;

typedef struct {
    PLFLT dxmi, dxma, dymi, dyma;	/* min, max window rel dev coords */
    PLFLT wxmi, wxma, wymi, wyma;	/* min, max window world coords */
} PLWindow;

typedef struct {
    unsigned int x, y;			/* upper left hand corner */
    unsigned int width, height;		/* window dimensions */
} PLDisplay;

typedef struct {
    PLFLT *f;
    PLINT nx, ny, nz;
} PLfGrid;

typedef struct {
    PLFLT **f;
    PLINT nx, ny;
} PLfGrid2;

typedef struct {
    PLFLT *xg, *yg, *zg;
    PLINT nx, ny, nz;
} PLcGrid;

typedef struct {
    PLFLT **xg, **yg, **zg;
    PLINT nx, ny;
} PLcGrid2;

typedef struct {
    unsigned char r;		/* red */
    unsigned char g;		/* green */
    unsigned char b;		/* blue */
    char *name;
} PLColor;

typedef struct {
    PLFLT h;			/* hue */
    PLFLT l;			/* lightness */
    PLFLT s;			/* saturation */
    PLFLT p;			/* position */
    int rev;			/* if set, interpolate through h=0 */
} PLControlPt;

typedef struct {
    PLINT cmd;
    PLINT result;
} PLBufferingCB;

</example>
    </para><node name="&#10;      Regression test for backwards compatibility&#10;    " previous="&#10;      What is in the API?&#10;    " up="API compatibility definition"/><section>
      Regression test for backwards compatibility
    </section><para>
      Since PLplot is developed by so many people, the task of checking for
      backwards compatiblity of the library is very hard.  As for the 5.3.1
      release, we do not have any rigorous regression test for check
      whether the library is really backwards compatible.
    </para><para>
      However, here are some rules to be followed by the Release Manager
      prior to releasing a new version of PLplot:
      <itemize markchar="•"><listitem><para>
            Check if there are any changes in
            <file>plplot.h</file>.  If no prototype is changed,
            then the chances are high that no backwards compatibilities
            have been introduced.  If new functions has been added, then
            the library soname will be kept, although the libtool soversion
            string in <file>configure.ac</file> must be changed
            from <samp>x:y:z</samp> to
            <samp>(x+1):0:(z+1)</samp>.  See the
            libtool manual for details.
        </para></listitem><listitem><para>
            A necessary, but not sufficient test consists of the following:
            first, install the previous released version of PLplot in the
            system and compile all the examples
            <file>examples/c/x??c.</file>.  After that, install the
            to-be-released version of PLplot and try to run the previously
            compiled examples.  If they either link or run incorrectly,
            then backwards incompatibilities have been introduced and the
            soversion string must be upgraded from <samp>x:y:z</samp>
            to <samp>(x+1):0:0</samp>.
          </para></listitem></itemize>
    </para><node name="Obsolete/Deprecated API for PLplot" previous="API compatibility definition" next="Notes for each Operating System that We Support" up="Top"/><chapter>Obsolete/Deprecated API for PLplot</chapter><para>
  The purpose of this chapter is to provide minimal documentation for
  obsolete/deprecated API that appears in our C library to provide backwards
  compatibility until our next major release, PLplot-6, where these functions
  will disappear.  Do not use these functions, and if you already use them
  in legacy PLplot applications, replace them by the suggested
  equivalents so you won't be caught out by the next major PLplot release.
  </para><menu><menuentry node="&#10;      plclr; Eject current page&#10;    "><menuentrytitle>
      plclr: Eject current page
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plcol; Set color&#10;    "><menuentrytitle>
      plcol: Set color
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plhls; Set current color by HLS&#10;    "><menuentrytitle>
      plhls: Set current color by HLS
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plHLS_RGB; Convert HLS color to RGB&#10;    "><menuentrytitle>
      plHLS_RGB: Convert HLS color to RGB
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plpage; Begin a new page&#10;    "><menuentrytitle>
      plpage: Begin a new page
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plrgb; Set line color by red; green&#10;    "><menuentrytitle>
      plrgb: Set line color by red, green
    </menuentrytitle><menuentrydescrip/></menuentry><menuentry node="&#10;      plrgb1; Set line color by 8-bit RGB values&#10;    "><menuentrytitle>
      plrgb1: Set line color by 8-bit RGB values
    </menuentrytitle><menuentrydescrip/></menuentry></menu><node name="&#10;      plclr; Eject current page&#10;    " next="&#10;      plcol; Set color&#10;    " up="Obsolete/Deprecated API for PLplot"/><section>
      plclr: Eject current page
    </section><para>
      <quotation><para><t>
	  <b>plclr</b>
	();</t></para></quotation>
    </para><para>
      Deprecated.  Use the new name, <code>pleop</code> (<pxref node="&#10;      pleop; Eject current page&#10;    " file=""/>), for this function instead.
    </para><node name="&#10;      plcol; Set color&#10;    " previous="&#10;      plclr; Eject current page&#10;    " next="&#10;      plhls; Set current color by HLS&#10;    " up="Obsolete/Deprecated API for PLplot"/><section>
      plcol: Set color
    </section><para>
      <quotation><para><t>
	  <b>plcol</b>
	(<i>color</i>);</t></para></quotation>
    </para><para>
      Deprecated.  Use the new name, <code>plcol0</code> (<pxref node="&#10;      plcol0; Set color; map0&#10;    " file=""/>), for this function instead.
    </para><varlist><varlistentry><term>
	  <code>color</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            See <code>plcol0</code> (<pxref node="&#10;      plcol0; Set color; map0&#10;    " file=""/>).
	  </para></listitem></varlistentry></varlist><node name="&#10;      plhls; Set current color by HLS&#10;    " previous="&#10;      plcol; Set color&#10;    " next="&#10;      plHLS_RGB; Convert HLS color to RGB&#10;    " up="Obsolete/Deprecated API for PLplot"/><section>
      plhls: Set current color by HLS
    </section><para>
      <quotation><para><t>
           <b>plhls</b>
        (<i>h</i>, <i>l</i>, <i>s</i>);</t></para></quotation>
    </para><para>
      Set current color by hue, lightness, and saturation.
      Convert hls color coordinates to rgb, then call plrgb.
      Do <i>not</i> use this.  Only retained for backward compatibility.
      Use <code>plhlsrgb</code> (<pxref node="&#10;      plhlsrgb; Convert HLS color to RGB&#10;    " file=""/>) and <code>plscol0</code> (<pxref node="&#10;      plscol0;  Set a given color from color map0 by 8&#10;bit RGB value&#10;    " file=""/>) instead.
    </para><varlist><varlistentry><term>
	  <code>h</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            NEEDS DOCUMENTATION
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>l</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            NEEDS DOCUMENTATION
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>s</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            NEEDS DOCUMENTATION
	  </para></listitem></varlistentry></varlist><node name="&#10;      plHLS_RGB; Convert HLS color to RGB&#10;    " previous="&#10;      plhls; Set current color by HLS&#10;    " next="&#10;      plpage; Begin a new page&#10;    " up="Obsolete/Deprecated API for PLplot"/><section>
      plHLS_RGB: Convert HLS color to RGB
    </section><para>
      <quotation><para><t>
           <b>plHLS_RGB</b>
        (<i>h</i>, <i>l</i>, <i>s</i>, <i>p_r</i>, <i>p_g</i>, <i>p_b</i>);</t></para></quotation>
    </para><para>
      Use <code>plhlsrgb</code> (<pxref node="&#10;      plhlsrgb; Convert HLS color to RGB&#10;    " file=""/>) from the common API instead of this deprecated C-only
      function.
    </para><varlist><varlistentry><term>
	  <code>h</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            Hue, in degrees on the colour cone (0.0-360.0)
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>l</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            Lightness, expressed as a fraction of the axis of the colour
            cone (0.0-1.0)
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>s</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            Saturation, expressed as a fraction of the radius of the
            colour cone (0.0-1.0)
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>p_r</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
            Pointer to red intensity (0.0-1.0) of the colour
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>p_g</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
            Pointer to green intensity (0.0-1.0) of the colour
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>p_b</code>
	  (<samp>PLFLT *</samp>, output)
	</term><listitem><para>
            Pointer to blue intensity (0.0-1.0) of the colour
	  </para></listitem></varlistentry></varlist><node name="&#10;      plpage; Begin a new page&#10;    " previous="&#10;      plHLS_RGB; Convert HLS color to RGB&#10;    " next="&#10;      plrgb; Set line color by red; green&#10;    " up="Obsolete/Deprecated API for PLplot"/><section>
      plpage: Begin a new page
    </section><para>
      <quotation><para><t>
	  <b>plpage</b>
	();</t></para></quotation>
    </para><para>
      Deprecated.  Use the new name, <code>plbop</code> (<pxref node="plbop; Begin a new page" file=""/>), for this function instead.
    </para><node name="&#10;      plrgb; Set line color by red; green&#10;    " previous="&#10;      plpage; Begin a new page&#10;    " next="&#10;      plrgb1; Set line color by 8-bit RGB values&#10;    " up="Obsolete/Deprecated API for PLplot"/><section>
      plrgb: Set line color by red, green
    </section><para>
      <quotation><para><t>
           <b>plrgb</b>
        (<i>r</i>, <i>g</i>, <i>b</i>);</t></para></quotation>
    </para><para>
      Set line color by red, green, blue from  0. to 1.  Do
<i>not</i> use this.
Only retained for backward compatibility. Use the function <code>plscol0</code> (<pxref node="&#10;      plscol0;  Set a given color from color map0 by 8&#10;bit RGB value&#10;    " file=""/>)
instead.
    </para><varlist><varlistentry><term>
	  <code>r</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            NEEDS DOCUMENTATION
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>g</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            NEEDS DOCUMENTATION
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>b</code>
	  (<samp>PLFLT</samp>, input)
	</term><listitem><para>
            NEEDS DOCUMENTATION
	  </para></listitem></varlistentry></varlist><node name="&#10;      plrgb1; Set line color by 8-bit RGB values&#10;    " previous="&#10;      plrgb; Set line color by red; green&#10;    " up="Obsolete/Deprecated API for PLplot"/><section>
      plrgb1: Set line color by 8-bit RGB values
    </section><para>
      <quotation><para><t>
           <b>plrgb1</b>
        (<i>r</i>, <i>g</i>, <i>b</i>);</t></para></quotation>
    </para><para>
      Set line color by 8-bit RGB values.  Do <i>not</i> use this.
Only retained for backward compatibility. Use the function <code>plscol0</code> (<pxref node="&#10;      plscol0;  Set a given color from color map0 by 8&#10;bit RGB value&#10;    " file=""/>)
instead.
    </para><varlist><varlistentry><term>
	  <code>r</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            NEEDS DOCUMENTATION
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>g</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            NEEDS DOCUMENTATION
	  </para></listitem></varlistentry><varlistentry><term>
	  <code>b</code>
	  (<samp>PLINT</samp>, input)
	</term><listitem><para>
            NEEDS DOCUMENTATION
	  </para></listitem></varlistentry></varlist><node name="Notes for each Operating System that We Support" previous="Obsolete/Deprecated API for PLplot" up="Top"/><chapter>Notes for each Operating System that We Support</chapter><para>
  The purpose of this Chapter is to present notes for
  each operating system that we support.  Although we have some
  support for a number of operating systems,
  we only have notes for Linux/Unix systems at this point.
  NEEDS DOCUMENTATION
  </para><menu><menuentry node="Linux/Unix Notes"><menuentrytitle>Linux/Unix Notes</menuentrytitle><menuentrydescrip/></menuentry></menu><node name="Linux/Unix Notes" up="Notes for each Operating System that We Support"/><section>Linux/Unix Notes</section><menu><menuentry node="Linux/Unix Configure; Build; and Installation"><menuentrytitle>Linux/Unix Configure, Build, and Installation</menuentrytitle><menuentrydescrip/></menuentry><menuentry node="Linux/Unix Building of C Programmes that Use the &#10;    Installed PLplot Libraries"><menuentrytitle>Linux/Unix Building of C Programmes that Use the 
    Installed PLplot Libraries</menuentrytitle><menuentrydescrip/></menuentry></menu><node name="Linux/Unix Configure; Build; and Installation" next="Linux/Unix Building of C Programmes that Use the &#10;    Installed PLplot Libraries" up="Linux/Unix Notes"/><subsection>Linux/Unix Configure, Build, and Installation</subsection><para>
    Here is the short story:
<example>
./configure
make
make install
</example>
    </para><para>
    The longer story is there are a lot of possible configure options.
    Two of the more important configure options are 
    <samp>--prefix</samp> and <samp>--with-double</samp>.
    Here is the complete list of configuration options:
<example>
./configure --help
No defaults file found, performing full configure.
Usage: configure [options] [host]
Options: [defaults in brackets after descriptions]
Configuration:
  --cache-file=FILE       cache test results in FILE
  --help                  print this message
  --no-create             do not create output files
  --quiet, --silent       do not print `checking...' messages
  --version               print the version of autoconf that created configure
Directory and file names:
  --prefix=PREFIX         install architecture-independent files in PREFIX
                          [/usr/local/plplot]
  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
                          [same as prefix]
  --bindir=DIR            user executables in DIR [EPREFIX/bin]
  --sbindir=DIR           system admin executables in DIR [EPREFIX/sbin]
  --libexecdir=DIR        program executables in DIR [EPREFIX/libexec]
  --datadir=DIR           read-only architecture-independent data in DIR
                          [PREFIX/share]
  --sysconfdir=DIR        read-only single-machine data in DIR [PREFIX/etc]
  --sharedstatedir=DIR    modifiable architecture-independent data in DIR
                          [PREFIX/com]
  --localstatedir=DIR     modifiable single-machine data in DIR [PREFIX/var]
  --libdir=DIR            object code libraries in DIR [EPREFIX/lib]
  --includedir=DIR        C header files in DIR [PREFIX/include]
  --oldincludedir=DIR     C header files for non-gcc in DIR [/usr/include]
  --infodir=DIR           info documentation in DIR [PREFIX/info]
  --mandir=DIR            man documentation in DIR [PREFIX/man]
  --srcdir=DIR            find the sources in DIR [configure dir or ..]
  --program-prefix=PREFIX prepend PREFIX to installed program names
  --program-suffix=SUFFIX append SUFFIX to installed program names
  --program-transform-name=PROGRAM
                          run sed PROGRAM on installed program names
Host type:
  --build=BUILD           configure for building on BUILD [BUILD=HOST]
  --host=HOST             configure for HOST [guessed]
  --target=TARGET         configure for TARGET [TARGET=HOST]
Features and packages:
  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
  --x-includes=DIR        X include files are in DIR
  --x-libraries=DIR       X library files are in DIR
--enable and --with options recognized:
  --with-defaults         source defaults file at startup (yes)
  --with-debug            compile with debugging (no)
  --with-opt              compile with optimization (yes)
  --with-double           use double precision floats (no)
  --with-profile          turn on profiling option (no)
  --with-shlib            build shared libraries (yes)
  --with-gcc              use gcc to compile C and C++ code (yes)
  --with-warn             enable all compilation warnings (no)
  --with-dbmalloc         link with libdbmalloc (no)
  --with-pkgdir=DIR       locate libraries and includes under DIR
  --with-fseek            use fseek/ftell rather than fsetpos/fgetpos (no)
  --with-rpath            link libraries with -rpath option (yes)
  --enable-f77            compile Fortran-77 interface code (yes)
  --enable-cxx            compile C++ interface code (yes)
  --enable-python         compile python interface code (yes)
  --enable-tcl            compile Tcl interface code (yes)
  --enable-itcl           enable incr Tcl interface code (yes)
  --with-x                use the X Window System
  --with-gtk-prefix=PFX   Prefix where GTK is installed (optional)
  --with-gtk-exec-prefix=PFX Exec prefix where GTK is installed (optional)
  --disable-gtktest       Do not try to compile and run a test GTK program
  --with-gnome-includes   Specify location of GNOME headers
  --with-gnome-libs       Specify location of GNOME libs
  --with-gnome            Specify prefix for GNOME files
  --enable-plmeta         enable plmeta device driver ()
  --enable-null           enable null device driver ()
  --enable-xterm          enable xterm device driver ()
  --enable-tek4010        enable tek4010 device driver ()
  --enable-tek4107        enable tek4107 device driver ()
  --enable-mskermit       enable mskermit device driver ()
  --enable-conex          enable conex device driver ()
  --enable-linuxvga       enable linuxvga device driver ()
  --enable-vlt            enable vlt device driver ()
  --enable-versaterm      enable versaterm device driver ()
  --enable-dg300          enable dg300 device driver ()
  --enable-ps             enable ps device driver ()
  --enable-xfig           enable xfig device driver ()
  --enable-ljii           enable ljii device driver ()
  --enable-hp7470         enable hp7470 device driver ()
  --enable-hp7580         enable hp7580 device driver ()
  --enable-lj_hpgl        enable lj_hpgl device driver ()
  --enable-imp            enable imp device driver ()
  --enable-xwin           enable xwin device driver (yes)
  --enable-tk             enable tk device driver (yes)
  --enable-pbm            enable pbm device driver ()
  --enable-gnome          enable gnome device driver (no)
</example>
    </para><para>
    The configure script looks for default
    configuration options first in <file>./cf_plplot.in</file>.
    If that file is not found, the script then looks in
    <file>$HOME/config/cf_plplot.in</file>.
    Finally, if neither file is found or if the found file
    does not have a particular default option, then the script
    uses the above defaults.  Here is one example of a default
    configuration file.  Adapt this for your needs or else use
    the command-line parameters for the configuration file.
<example>
# --*-sh-*---------------------------------------------------------------
#
# PLplot configure script default variables.
#
#
# Note: the internal representation of the --with-&lt;option&gt; and
# --enable-&lt;option&gt; command line switches actually uses an underscore,
# e.g. with_&lt;option&gt; and enable_&lt;option&gt;.  Don't forget!
#
# -----------------------------------------------------------------------

# Method to turn off Fortran and C++ bindings.
 
enable_cxx="no" 
enable_f77="no" 
  
# Devices are selected by --enable or --disable on the command line, but 
# only shell variables of the form enable_&lt;option&gt; are recognized here. 
   
enable_tek4010="no" 
enable_mskermit="no" 
enable_conex="no" 
enable_vlt="no" 
enable_versaterm="no" 
enable_xfig="no" 
    
enable_dg300="no" 
enable_imp="no" 
enable_tek4107="no" 
enable_hp7470="no" 
enable_hp7580="no"
</example>
    </para><node name="Linux/Unix Building of C Programmes that Use the &#10;    Installed PLplot Libraries" previous="Linux/Unix Configure; Build; and Installation" up="Linux/Unix Notes"/><subsection>Linux/Unix Building of C Programmes that Use the 
    Installed PLplot Libraries</subsection><para> This is incomplete.  NEEDS DOCUMENTATION. 
    <file>$prefix/bin/plplot-config</file> is a
    useful tool for helping with building of C programmes that use 
    the PLplot libraries.
<example>
./plplot-config --help
Usage: plplot-config [OPTIONS]
Options:
        [--prefix[=DIR]]
	[--version]
	[--libs]
	[--cflags]
	[--with-c++]
	[--help]
</example>

For example, the <samp>--cflags</samp> parameter displays the
flags for compiling, and the <samp>--libs</samp> parameter
displays the flags for linking your application.  The displayed flags
are exactly consistent with the configuration specified when PLplot
was last built and installed.
    </para></texinfo>
