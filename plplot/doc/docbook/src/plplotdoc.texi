\input texinfo
@setfilename plplotdoc.info
@documentencoding us-ascii
@direntry
* The PLplot Plotting Library: .   ??? 
@end direntry

@node Top, Introduction, , (dir)
@top The PLplot Plotting Library

@menu
* Introduction::
* Simple Use of PLplot::
* Advanced Use of PLplot::
* Deploying programs that use PLplot::
* The PLplot Display Driver Family::
* The PLplot Output Driver Family::
* C Language::
* Fortran Language::
* A C++ Interface for PLplot::
* Using PLplot from Tcl::
* Building an Extended WISH::
* Embedding Plots in Graphical User Interfaces::
* Using PLplot from Perl::
* Using PLplot from Python::
* Bibliography::
* The Common API for PLplot::
* The Specialized C API for PLplot::
* The Specialized Fortran API for PLplot::
* API compatibility definition::
* Obsolete/Deprecated API for PLplot::
* Notes for each Operating System that We Support::

@detailmenu
--- The Detailed Node Listing ---

Introduction

* The PLplot Plotting Library::
* Getting a Copy of the PLplot Package::
* Installing and Using the PLplot Library::
* Organization of this Manual::
* Copyrights::
* Credits::

Simple Use of PLplot

* Plotting a Simple Graph::
* Initializing PLplot::
* Defining Plot Scales and Axes::
* Labeling the Graph::
* Drawing the Graph::
* Finishing Up::
* In Case of Error::

Advanced Use of PLplot

* Command Line Arguments::
* Output Devices::
* Adding FreeType Library Support to Bitmap Drivers::
* View Surfaces; [Sub-]Pages; Viewports and Windows::
* Setting Line Attributes::
* Setting the Area Fill Pattern::
* Setting Color::
* Setting Character Attributes::
* Three Dimensional Surface Plots::
* Contour and Shade Plots::

The PLplot Display Driver Family

* The Xwin Driver [X-Windows]::
* The GCW Driver [Gnome 2]::
* The Tk Driver::
* The AquaTerm Driver [Mac OS X]::

The PLplot Output Driver Family

* The Postscript Driver::
* The GD Driver::

A C++ Interface for PLplot

* Motivation for the C++ Interface::
* Design of the PLplot C++ Interface::
* Specializing the PLplot C++ Interface::
* Status of the C++ Interface::

Using PLplot from Tcl

* Motivation for the Tcl Interface to PLplot::
* Overview of the Tcl Language Binding::
* The PLplot Tcl Matrix Extension::
* Contouring and Shading from Tcl::
* Understanding the Performance Characteristics of Tcl::

Building an Extended WISH

* Introduction to Tcl::
* Introduction to Tk::
* Introduction to [incr Tcl]::
* PLplot Extensions to Tcl::
* Custom Extensions to Tcl::

Embedding Plots in Graphical User Interfaces

* The PlplotCanvas Widget for Gnome/GTK Applications::

Bibliography

* References::

The Common API for PLplot

* pl_setcontlabelformat; Set format of numerical label for contours::
* pl_setcontlabelparam; Set parameters of contour labelling other than format of numerical label::
* pladv; Advance the [sub-]page::
* plaxes; Draw a box with axes; etc_ with arbitrary origin::
* plbin; Plot a histogram from binned data::
* plbop; Begin a new page::
* plbox; Draw a box with axes; etc::
* plbox3; Draw a box with axes; etc; in 3-d::
* plcalc_world; Calculate world coordinates and corresponding window index from relative device coordinates::
* plclear; Clear current [sub]page::
* plcol0; Set color; map0::
* plcol1; Set color; map1::
* plcont; Contour plot::
* plcpstrm; Copy state parameters from the reference stream to the current stream::
* plend; End plotting session::
* plend1; End plotting session for current stream::
* plenv0; Same as plenv but if in multiplot mode does not advance the subpage; instead clears it_::
* plenv; Set up standard window and draw box::
* pleop; Eject current page::
* plerrx; Draw x error bar::
* plerry; Draw y error bar::
* plfamadv; Advance to the next family file on the next new page::
* plfill; Draw filled polygon::
* plfill3; Draw filled polygon in 3D::
* plflush; Flushes the output stream::
* plfont; Set character font::
* plfontld; Load character font::
* plgchr; Get character default height and current [scaled] height::
* plgcol0; Returns 8-bit RGB values for given color from color map0::
* plgcolbg; Returns the background color [cmap0[0]] by 8-bit RGB value::
* plgcompression; Get the current device-compression setting::
* plgdev; Get the current device [keyword] name::
* plgdidev; Get parameters that define current device-space window::
* plgdiori; Get plot orientation::
* plgdiplt; Get parameters that define current plot-space window::
* plgfam; Get family file parameters::
* plgfci; Get FCI [font characterization integer]::
* plgfnam; Get output file name::
* plglevel; Get the [current] run level::
* plgpage; Get page parameters::
* plgra; Switch to graphics screen::
* plgriddata; Grid data from irregularly sampled data::
* plgspa; Get current subpage parameters::
* plgstrm; Get current stream number::
* plgver; Get the current library version number::
* plgvpd; Get viewport limits in normalized device coordinates::
* plgvpw; Get viewport limits in world coordinates::
* plgxax; Get x axis parameters::
* plgyax; Get y axis parameters::
* plgzax; Get z axis parameters::
* plhist; Plot a histogram from unbinned data::
* plhlsrgb; Convert HLS color to RGB::
* plinit; Initialize PLplot::
* pljoin; Draw a line between two points::
* pllab; Simple routine to write labels::
* pllightsource; Sets the 3D position of the light source::
* plline; Draw a line::
* plline3; Draw a line in 3 space::
* pllsty; Select line style::
* plmesh; Plot surface mesh::
* plmeshc; Magnitude colored plot surface mesh with contour_::
* plmkstrm; Creates a new stream and makes it the default::
* plmtex; Write text relative to viewport boundaries::
* plot3d; Plot 3-d surface plot::
* plot3dc; Magnitude colored plot surface with contour_::
* plparseopts; Parse command-line arguments::
* plpat; Set area fill pattern::
* plpoin; Plots a character at the specified points::
* plpoin3; Plots a character at the specified points in 3 space::
* plpoly3; Draw a polygon in 3 space::
* plprec; Set precision in numeric labels::
* plpsty; Select area fill pattern::
* plptex; Write text inside the viewport::
* plreplot; Replays contents of plot buffer to current device/file::
* plrgbhls; Convert RGB color to HLS::
* plschr; Set character size::
* plscmap0; Set color map0 colors by 8-bit RGB values::
* plscmap0n; Set number of colors in color map0::
* plscmap1; Set color map1 colors using 8-bit RGB values::
* plscmap1l; Set color map1 colors using a piece-wise linear relationship::
* plscmap1n; Set number of colors in color map1::
* plscol0; Set a given color from color map0 by 8 bit RGB value::
* plscolbg; Set the background color by 8-bit RGB value::
* plscolor; Used to globally turn color output on/off::
* plscompression; Set device-compression level::
* plsdev; Set the device [keyword] name::
* plsdidev; Set parameters that define current device-space window::
* plsdimap; Set up transformation from metafile coordinates::
* plsdiori; Set plot orientation::
* plsdiplt; Set parameters that define current plot-space window::
* plsdiplz; Set parameters incrementally [zoom mode] that define current plot-space window::
* plsesc; Set the escape character for text strings::
* plsetopt; Set any command-line option::
* plsfam; Set family file parameters::
* plsfci; Set FCI [font characterization integer]::
* plsfnam; Set output file name::
* plshades; Shade regions on the basis of value::
* plshade; Shade individual region on the basis of value::
* plshade1; Shade individual region on the basis of value::
* plsmaj; Set length of major ticks::
* plsmem; Set the memory area to be plotted::
* plsmin; Set length of minor ticks::
* plsori; Set orientation::
* plspage; Set page parameters::
* plspause; Set the pause [on end-of-page] status::
* plsstrm; Set current output stream::
* plssub; Set the number of subpages in x and y::
* plssym; Set symbol size::
* plstar; Initialization::
* plstart; Initialization::
* plstripa; Add a point to a stripchart::
* plstripc; Create a 4-pen stripchart::
* plstripd; Deletes and releases memory used by a stripchart::
* plstyl; Set line style::
* plsurf3d; Plot shaded 3-d surface plot::
* plsvect; Set arrow style for vector plots::
* plsvpa; Specify viewport in absolute coordinates::
* plsxax; Set x axis parameters::
* plsyax; Set y axis parameters::
* plsym; Plots a symbol at the specified points::
* plszax; Set z axis parameters::
* pltext; Switch to text screen::
* plvasp; Specify viewport using aspect ratio only::
* plvect; Vector plot::
* plvpas; Specify viewport using coordinates and aspect ratio::
* plvpor; Specify viewport using coordinates::
* plvsta; Select standard viewport::
* plw3d; Set up window for 3-d plotting::
* plwid; Set pen width::
* plwind; Specify world coordinates of viewport boundaries::
* plxormod; Enter or leave xor mode::

The Specialized C API for PLplot

* plP_checkdriverinit; Checks to see if any of the specified drivers have been initialized::
* plP_getinitdriverlist; Get the initialized-driver list::
* plabort; Error abort::
* plexit; Error exit::
* plgfile; Get output file handle::
* plsabort; Set abort handler::
* plsexit; Set exit handler::
* plsfile; Set output file handle::
* pltr0; Identity transformation for grid to world mapping::
* pltr1; Linear interpolation for grid to world mapping using singly dimensioned coord arrays::
* pltr2; Linear interpolation for grid to world mapping using doubly dimensioned coord arrays [column dominant; as per normal C 2d arrays]::

The Specialized Fortran API for PLplot

* plcon0; Contour plot; identity mapping for fortran::
* plcon1; Contour plot; general 1-d mapping for fortran::
* plcon2; Contour plot; general 2-d mapping for fortran::
* plcont; Contour plot; fixed linear mapping for fortran::
* plvec0; Vector plot; identity mapping for fortran::
* plvec1; Vector plot; general 1-d mapping for fortran::
* plvec2; Vector plot; general 2-d mapping for fortran::
* plvect; Vector plot; fixed linear mapping for fortran::
* plmesh; Plot surface mesh for fortran::
* plot3d; Plot 3-d surface plot for fortran::
* plparseopts; parse arguments for fortran::
* plsesc; Set the escape character for text strings for fortran::

API compatibility definition

* What is in the API?::
* Regression test for backwards compatibility::

Obsolete/Deprecated API for PLplot

* plclr; Eject current page::
* plcol; Set color::
* plhls; Set current color by HLS::
* plHLS_RGB; Convert HLS color to RGB::
* plpage; Begin a new page::
* plrgb; Set line color by red; green::
* plrgb1; Set line color by 8-bit RGB values::

Notes for each Operating System that We Support

* Linux/Unix Notes::

@end detailmenu
@end menu

@node Introduction, Simple Use of PLplot, Top, Top
@chapter Introduction

@menu
* The PLplot Plotting Library::
* Getting a Copy of the PLplot Package::
* Installing and Using the PLplot Library::
* Organization of this Manual::
* Copyrights::
* Credits::
@end menu

@node The PLplot Plotting Library, Getting a Copy of the PLplot Package, , Introduction
@section The PLplot Plotting Library

PLplot is a library of C functions that are useful for making
scientific plots from programs written in C, C++, Fortran, Octave, Python,
and Tcl/Tk. The PLplot project is being developed by a world-wide team who
interact via the facilities provided by SourceForge (@uref{http://sourceforge.net/projects/plplot,http://sourceforge.net/projects/plplot})

The PLplot library can be used to create standard x-y plots, semi-log
plots, log-log plots, contour plots, 3D plots, shade (gray-scale and color)
plots, mesh plots, bar charts and pie charts. Multiple graphs (of the same
or different sizes) may be placed on a single page with multiple lines in
each graph. Different line styles, widths and colors are supported. A
virtually infinite number of distinct area fill patterns may be used. There
are almost 1000 characters in the extended character set. This includes
four different fonts, the Greek alphabet and a host of mathematical,
musical, and other symbols. The fonts can be scaled to any desired size. A
variety of output devices and file formats are supported including a
metafile format which can be subsequently rendered to any device/file. New
devices and file formats can be easily added by writing a driver routine.
For example, we have recently added PNG and JPEG file drivers, and a GNOME
interactive driver is being developed. 

PLplot was originally developed by Sze Tan of the University of
Auckland in Fortran-77. Many of the underlying concepts used in the
PLplot package are based on ideas used in Tim Pearson's PGPLOT
package. Sze Tan writes:

@quotation

I'm rather amazed how far PLPLOT has traveled given its origins
etc. I first used PGPLOT on the Starlink VAX computers while I was
a graduate student at the Mullard Radio Astronomy Observatory in
Cambridge from 1983-1987. At the beginning of 1986, I was to give a
seminar within the department at which I wanted to have a computer
graphics demonstration on an IBM PC which was connected to a
completely non-standard graphics card. Having about a week to do
this and not having any drivers for the card, I started from the
back end and designed PLPLOT to be such that one only needed to be
able to draw a line or a dot on the screen in order to do arbitrary
graphics. The application programmer's interface was made as
similar as possible to PGPLOT so that I could easily port my
programs from the VAX to the PC. The kernel of PLPLOT was modeled
on PGPLOT but the code is not derived from it.
@end quotation

The C version of PLplot was developed by Tony Richardson on a
Commodore Amiga. In the process, several of the routines were
rewritten to improve efficiency and some new features added. The
program structure was changed somewhat to make it easier to
incorporate new devices. Additional features were added to allow
three-dimensional plotting and better access to low-level routines.

PLplot 5.0 is a continuation of our work on PLplot 4.0, which never
got widely distributed. It became clear during the work on 4.0 that
in order to support an interactive driver under Unix (using Tcl/Tk),
many additions to the basic capabilities of the package were needed.
So without stopping to fully document and bug-fix the 4.0 additions,
work on 5.0 was begun. The result is that a very capable
PLplot-based widget for the Tk toolkit has been written. This widget
can manipulate the plot (zoom/pan, scale, orient, change colors), as
well dump it to any supported device. There are help menus and user
customization options. These are still in the process of being
documented.

Other changes include the introduction of a new color palette (cmap1)
for smooth color shaded images (typically for 2d or 3d plots --
in which color represents function intensity), support for color fill
plots, and lots more cool stuff. The manual has been rewritten in
LaTeXinfo, so that there is now a printed version and an online
(info) version of the document. The manual is still in a state of
flux and will be fleshed out in more detail in later updates.

Some of the improvements in PLplot 5.0 include: the addition of
several new routines to enhance usage from Fortran and design of a
portable C to Fortran interface. Additional support was added for
coordinate mappings in contour plots and some bugs fixed. New
labeling options were added. The font handling code was made more
flexible and portable. A portable PLplot metafile driver and
renderer was developed, allowing one to create a generic graphics
file and do the actual rendering later (even on a different
system). The ability to create family output files was added. The
internal code structure was dramatically reworked, with elimination
of global variables (for a more robust package), the drivers
rewritten to improve consistency, and the ability to maintain
multiple output streams added. An XFig driver was added. Other
contributions include Clair Nielsen's (LANL) X-window driver (very
nice for high-speed color graphics) and tektronix file viewer. At
present, Maurice LeBrun and Geoff Furnish are the active developers
and maintainers of PLplot.

We have attempted to keep PLplot 5.0 backward compatible with
previous versions of PLplot. However, some functions are now
obsolete, and many new ones have been added (e.g. new contouring
functions, variable get/set routines, functions that affect label
appearance). Codes written in C that use PLplot must be recompiled
including the new header file @file{plplot.h} before
linking to the new PLplot library.

PLplot is currently known to work on the following systems:
Unix/Linux, OS/2, Mac, MS-DOS, and Win9x. The Unix/Linux version is
the best supported of these possibilities.
The PLplot package is freely
distributable, but @i{not} in the public domain.
See @ref{Copyrights,,Copyrights}. for distribution criteria.

We welcome suggestions on how to improve this code, especially in
the form of user-contributed enhancements or bug fixes. If PLplot
is used in any published papers, please include an acknowledgment
or citation of our work, which will help us to continue improving
PLplot. Please direct all communication to the general PLplot
mailing list, plplot-general@@lists.sourceforge.net.

@node Getting a Copy of the PLplot Package, Installing and Using the PLplot Library, The PLplot Plotting Library, Introduction
@section Getting a Copy of the PLplot Package

At present, the only mechanism we are providing for distribution of
the PLplot is by electronic transmission over the Internet. We
encourage others to make it available to users without Internet
access. PLplot is a SourceForge project and may be obtained by
the usual SourceForge file release and anonymous cvs access that is made
available from links at
@uref{http://sourceforge.net/projects/plplot,http://sourceforge.net/projects/plplot}.

@node Installing and Using the PLplot Library, Organization of this Manual, Getting a Copy of the PLplot Package, Introduction
@section Installing and Using the PLplot Library

The installation procedure is by necessity system specific;
installation notes for each system are provided in
@ref{Notes for each Operating System that We Support,,Notes for each Operating System that We Support}..
The procedure requires that all of the routines be
compiled and they are then usually placed in a linkable
library.

After the library has been created, you can write your main program
to make the desired PLplot calls. Example programs in C, C++, and
Fortran are included as a guide.
Plots generated from the example programs are shown
@uref{http://plplot.sf.net/examples/index.html,here}.

You will then need to compile your program and link it with the
PLplot library(s). See
@ref{Notes for each Operating System that We Support,,Notes for each Operating System that We Support}. for more details).

You can also use Tcl/Tk scripts or Python scripts to generate plots
using the PLplot libraries. Examples of these possibilities are
also included as a guide.

@node Organization of this Manual, Copyrights, Installing and Using the PLplot Library, Introduction
@section Organization of this Manual

OLD DOCS, NEEDS UPDATING!

The PLplot library has been designed so that it is easy to write
programs producing graphical output without having to set up large
numbers of parameters. However, more precise control of the results
may be necessary, and these are accommodated by providing lower-level
routines which change the system defaults. The manual first describes
the overall process of producing a graph using the high-level
routines (see @ref{Plotting a Simple Graph,,Plotting a Simple Graph}.). For a discussion of
the underlying concepts of the plotting process and an introduction
to some of the more complex routines (see @ref{Advanced Use of PLplot,,Advanced Use of PLplot}.).
An alphabetical list of the user-accessible PLplot functions with
detailed descriptions is given in the reference section of the manual
(see @ref{The Common API for PLplot,,The Common API for PLplot}.).

Because the PLplot kernel is written in C, standard C syntax is used
in the description of each PLplot function. The C and Fortran
language interfaces are discussed in Appendix \ref@{ap:lang@}; look
there if you have difficulty interpreting the call syntax as
described in this manual. The meaning of function (subroutine)
arguments is typically the same regardless of whether you are calling
from C or Fortran (but there are some exceptions to this). The
arguments for each function are usually specified in terms of PLFLT
and PLINT---these are the internal PLplot representations for
integer and floating point, and are typically a long and a float (or
an INTEGER and a REAL, for Fortran programmers). See Appendix
\ref@{ap:lang@} for more detail.

Also, you can use PLplot from C++ just as you would from C. No
special classes are available at this time, just use it as any other
procedural type library. Simply include
@file{plplot.h}, and invoke as you would from C.

The output devices supported by PLplot are listed in Appendix
\ref@{ap:dev@}, along with description of the device driver--PLplot
interface, metafile output, family files, and vt100/tek4010
emulators. In Appendix\ref@{ap:sys@} the usage and installation for
each system supported by PLplot is described (not guaranteed to be
entirely up-to-date; check the release notes to be sure).

@node Copyrights, Credits, Organization of this Manual, Introduction
@section Copyrights

The PLplot package may be distributed under the following terms:

@example

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public
    License along with this library; if not, write to the Free
    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
    
@end example

The text of this license is given in the file COPYING.LIB in the
distribution directory. Exceptions are noted below.

The intent behind distributing PLplot under the LGPL is to ensure
that it continues to evolve in a positive way, while remaining freely
distributable. The package is considered a "library" even though
there are associated programs, such as plrender, pltek, plserver, and
pltcl. The ties between these programs and the library are so great
that I consider them as part of the library, so distribution under
the terms of the LGPL makes sense. Software developers are allowed
and encouraged to use PLplot as an integral part of their product,
even a commercial product. Under the conditions of the LGPL,
however, the PLplot source code must remain freely available,
including any modifications you make to it (if you distribute a
program based on the modified library). Please read the full license
for more info.

@menu
* Additional Copyrights::
@end menu

@node Additional Copyrights, , , Copyrights
@subsection Additional Copyrights

The startup code used in argument handling
(@file{utils/plrender.c} and
@file{src/plargs.c}) is partially derived from
@file{xterm.c} of the X11R5 distribution, and its
copyright is reproduced here:

@example

******************************************************************************
Copyright 1987, 1988 by Digital Equipment Corporation, Maynard,
Massachusetts, and the Massachusetts Institute of Technology, Cambridge,
Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the names of Digital or MIT not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.
******************************************************************************
      
@end example

Any file that is explicitly marked as "public domain" is free
from any restriction on distribution.

Any file that has a explicit copyright notice may be distributed
under the terms of both the LGPL and whatever stated conditions
accompany the copyright.

@node Credits, , Copyrights, Introduction
@section Credits

PLplot 5.0 was created through the effort of many individuals and
funding agencies. We would like to acknowledge the support
(financial and otherwise) of the following institutions:

@itemize @bullet{}

@item
The Institute for Fusion Studies, University of Texas at Austin

@item
The Scientific and Technology Agency of Japan

@item
Japan Atomic Energy Research Institute

@item
Duke University

@item
Universite de Nice

@item
National Energy Research Supercomputer Center

@item
Los Alamos National Labs
@end itemize

Thanks are also due to the many contributors to PLplot, including:

@itemize @bullet{}

@item
Tony Richardson: Creator of PLplot 2.6b, 3.0

@item
Sam Paolucci (postscript driver)

@item
Sam Paolucci (postscript driver)

@item
Tom Rokicki (IFF driver and Amiga printer driver)
@end itemize

Finally, thanks to all those who submitted bug reports and other
suggestions.

@node Simple Use of PLplot, Advanced Use of PLplot, Introduction, Top
@chapter Simple Use of PLplot

@menu
* Plotting a Simple Graph::
* Initializing PLplot::
* Defining Plot Scales and Axes::
* Labeling the Graph::
* Drawing the Graph::
* Finishing Up::
* In Case of Error::
@end menu

@node Plotting a Simple Graph, Initializing PLplot, , Simple Use of PLplot
@section Plotting a Simple Graph

We shall first consider plotting simple graphs showing the dependence
of one variable upon another. Such a graph may be composed of
several elements:

@itemize @bullet{}

@item
A box which defines the ranges of the variables, perhaps with
axes and numeric labels along its edges.

@item
A set of points or lines within the box showing the functional
dependence.

@item
A set of labels for the variables and a title for the graph.
@end itemize

In order to draw such a graph, it is necessary to call at least four
of the PLplot functions:

@enumerate 

@item
@code{plinit} (@pxref{plinit; Initialize PLplot}), to initialize PLplot.

@item
@code{plenv} (@pxref{plenv; Set up standard window and draw box}), to define the range and scale of the
graph, and draw labels, axes, etc.

@item
One or more calls to @code{plline} (@pxref{plline; Draw a line}) or @code{plpoin} (@pxref{plpoin; Plots a character at the specified points}) to draw lines or points
as needed. Other more complex routines include @code{plbin} (@pxref{plbin; Plot a histogram from binned data}) and
@code{plhist} (@pxref{plhist; Plot a histogram from unbinned data}) to draw histograms, @code{plerrx} (@pxref{plerrx; Draw x error bar}) and @code{plerry} (@pxref{plerry; Draw y error bar}) to draw
error-bars.

@item
@code{plend} (@pxref{plend; End plotting session}), to close the plot.
@end enumerate

More than one graph can be drawn on a single set of axes by making
repeated calls to the routines listed in item 3 above. PLplot only
needs to be initialized once unless plotting to multiple output
devices.

@node Initializing PLplot, Defining Plot Scales and Axes, Plotting a Simple Graph, Simple Use of PLplot
@section Initializing PLplot

Before any actual plotting calls are made, a graphics program must
call @code{plinit} (@pxref{plinit; Initialize PLplot}), is the main initialization routine for PLplot. It
sets up all internal data structures necessary for plotting and
initializes the output device driver. If the output device has not
already been specified when @code{plinit} (@pxref{plinit; Initialize PLplot}) is called, a list of valid
output devices is given and the user is prompted for a choice.
Either the device number or a device keyword is accepted.

There are several routines affecting the initialization that must
be called @i{before} @code{plinit} (@pxref{plinit; Initialize PLplot}), if they are used. The
function @code{plsdev} (@pxref{plsdev; Set the device [keyword] name}) allows you to set the device explicitly. The
function @code{plsetopt} (@pxref{plsetopt; Set any command-line option}) allows you to set any command-line option
internally in your code. The function @code{plssub} (@pxref{plssub; Set the number of subpages in x and y}) may be called to
divide the output device plotting area into several subpages of equal
size, each of which can be used separately. 

One advances to the next page (or screen) via @code{pladv} (@pxref{pladv; Advance the [sub-]page}). If subpages
are used, this can be used to advance to the next subpage or to a
particular subpage.

@node Defining Plot Scales and Axes, Labeling the Graph, Initializing PLplot, Simple Use of PLplot
@section Defining Plot Scales and Axes

The function @code{plenv} (@pxref{plenv; Set up standard window and draw box}) is used to define the scales and axes for simple
graphs. @code{plenv} (@pxref{plenv; Set up standard window and draw box}) starts a new picture on the next subpage (or a new
page if necessary), and defines the ranges of the variables required.
The routine will also draw a box, axes, and numeric labels if
requested. The syntax for @code{plenv} (@pxref{plenv; Set up standard window and draw box}) is:


@quotation

@t{
@b{plenv}
(@i{xmin}, @i{xmax}, @i{ymin}, @i{ymax}, @i{just}, @i{axis});}
@end quotation

@table @asis

@item   @code{xmin, xmax}  (@samp{PLFLT}, input)  
The left and right limits for the horizontal axis.

@item   @code{ymin, ymax}  (@samp{PLFLT}, input)  
The bottom and top limits for the vertical axis.

@item   @code{just}  (@samp{PLINT}, input)  
This should be zero or one. If @code{just} is
one, the scales of the x-axis and y-axis will be the same (in
units per millimeter); otherwise the axes are scaled
independently. This parameter is useful for ensuring that
objects such as circles have the correct aspect ratio in the
final plot.

@item   @code{axis}  (@samp{PLINT}, input)  
@code{axis} controls whether a box, tick marks,
labels, axes, and/or a grid are drawn.

@itemize @bullet{}

@item
@code{axis} = -2: No box or annotation.

@item
@code{axis} = -1: Draw box only.

@item
@code{axis} = 0: Draw box, labeled with
coordinate values around edge.

@item
@code{axis} = 1: In addition to box and labels,
draw the two axes X = 0 and Y = 0.

@item
@code{axis} = 2: Same as
@code{axis} = 1, but also draw a grid at the
major tick interval.

@item
@code{axis} = 10: Logarithmic X axis, linear Y
axis.

@item
@code{axis} = 11: Logarithmic X axis, linear Y
axis and draw line Y = 0.

@item
@code{axis} = 20: Linear X axis,
logarithmic Y axis.

@item
@code{axis} = 21: Linear X axis, logarithmic Y
axis and draw line X = 0.

@item
@code{axis} = 30: Logarithmic X and Y axes.
@end itemize
@end table

Note: Logarithmic axes only affect the appearance of the axes and
their labels, so it is up to the user to compute the logarithms prior
to passing them to @code{plenv} (@pxref{plenv; Set up standard window and draw box}) and any of the other routines. Thus, if a
graph has a 3-cycle logarithmic axis from 1 to 1000, we need to set
@code{xmin} =
@code{log_10}(1) = 0.0, and
@code{xmax} =
@code{log_10}(1000) = 3.0.

For greater control over the size of the plots, axis labeling and
tick intervals, more complex graphs should make use of the functions
@code{plvpor} (@pxref{plvpor; Specify viewport using coordinates}), @code{plvasp} (@pxref{plvasp; Specify viewport using aspect ratio only}), @code{plvpas} (@pxref{plvpas; Specify viewport using coordinates and aspect ratio}), @code{plwind} (@pxref{plwind; Specify world coordinates of viewport boundaries}), @code{plbox} (@pxref{plbox; Draw a box with axes; etc}), and routines for
manipulating axis labeling @code{plgxax} (@pxref{plgxax; Get x axis parameters}) through @code{plszax} (@pxref{plszax; Set z axis parameters}).

@node Labeling the Graph, Drawing the Graph, Defining Plot Scales and Axes, Simple Use of PLplot
@section Labeling the Graph

The function @code{pllab} (@pxref{pllab; Simple routine to write labels}) may be called after @code{plenv} (@pxref{plenv; Set up standard window and draw box}) to write labels on
the x and y axes, and at the top of the picture. All the variables
are character variables or constants. Trailing spaces are removed
and the label is centered in the appropriate field. The syntax for
@code{pllab} (@pxref{pllab; Simple routine to write labels}) is:


@quotation

@t{
@b{pllab}
(@i{xlbl}, @i{ylbl}, @i{toplbl});}
@end quotation

@table @asis

@item   @code{xlbl} (@samp{char *}, input)  
Pointer to string with label for the X-axis (bottom of graph).

@item   @code{ylbl} (@samp{char *}, input)  
Pointer to string with label for the Y-axis (left of graph).

@item   @code{toplbl} (@samp{char *}, input)  
Pointer to string with label for the plot (top of picture).@}
@end table

More complex labels can be drawn using the function @code{plmtex} (@pxref{plmtex; Write text relative to viewport boundaries}). For
discussion of writing text in a plot see @ref{Writing Text on a Graph,,Writing Text on a Graph}., and
for more detailed discussion about label generation see @ref{Writing Text on a Graph,,Writing Text on a Graph}..

@node Drawing the Graph, Finishing Up, Labeling the Graph, Simple Use of PLplot
@section Drawing the Graph

PLplot can draw graphs consisting of points with optional error bars,
line segments or histograms. Functions which perform each of these
actions may be called after setting up the plotting environment using
@code{plenv} (@pxref{plenv; Set up standard window and draw box}). All of the following functions draw within the box defined
by @code{plenv} (@pxref{plenv; Set up standard window and draw box}), and any lines crossing the boundary are clipped.
Functions are also provided for drawing surface and contour
representations of multi-dimensional functions. See @ref{Advanced Use of PLplot,,Advanced Use of PLplot}. for discussion of finer control of plot
generation.

@menu
* Drawing Points::
* Drawing Lines or Curves::
* Writing Text on a Graph::
* Area Fills::
* More Complex Graphs::
@end menu

@node Drawing Points, Drawing Lines or Curves, , Drawing the Graph
@subsection Drawing Points

@code{plpoin} (@pxref{plpoin; Plots a character at the specified points}) and @code{plsym} (@pxref{plsym; Plots a symbol at the specified points}) mark out @samp{n} points
@samp{(x[i], y[i])} with the specified symbol. The
routines differ only in the interpretation of the symbol codes.
@code{plpoin} (@pxref{plpoin; Plots a character at the specified points}) uses an extended ASCII representation, with the printable
ASCII codes mapping to the respective characters in the current
font, and the codes from 0--31 mapping to various useful
symbols. In @code{plsym} (@pxref{plsym; Plots a symbol at the specified points}) however, the code is a Hershey font code
number. Example programs are provided which display each of the
symbols available using these routines.


@quotation

@t{
@b{plpoin}(@i{n}, @i{x}, @i{y}, @i{code});}
@end quotation


@quotation

@t{
@b{plsym}
(@i{n}, @i{x}, @i{y}, @i{code});}
@end quotation

@table @asis

@item   @code{n} (@samp{PLINT}, input)  
The number of points to plot.

@item   @code{x, y} (@samp{PLFLT *}, input)  
Pointers to arrays of the coordinates of the
@samp{n} points.

@item  @code{code} (@samp{PLINT},  input)  
Code number of symbol to draw
@end table

@node Drawing Lines or Curves, Writing Text on a Graph, Drawing Points, Drawing the Graph
@subsection Drawing Lines or Curves

PLplot provides two functions for drawing line graphs. All lines are
drawn in the currently selected color, style and width. See @ref{Setting Line Attributes,,Setting Line Attributes}. for information about changing these
parameters.

@code{plline} (@pxref{plline; Draw a line}) draws a line or curve. The curve consists of
@samp{n-1} line segments joining the @samp{n}
points in the input arrays. For single line segments, @code{pljoin} (@pxref{pljoin; Draw a line between two points}) is
used to join two points.


@quotation

@t{
@b{plline}
(@i{n}, @i{x}, @i{y});}
@end quotation

@table @asis

@item   @code{n} (@samp{PLINT}, input)  
The number of points.

@item   @code{x, y} (@samp{PLFLT *}, input)  
Pointers to arrays with coordinates of the @samp{n}
points.
@end table


@quotation

@t{
@b{pljoin}
(@i{x1}, @i{y1}, @i{x2}, @i{y2});}
@end quotation

@table @asis

@item   @code{x1, y1} (@samp{PLFLT}, input)  
Coordinates of the first point.

@item   @code{x2, y2} (@samp{PLFLT}, input)  
Coordinates of the second point.
@end table

@node Writing Text on a Graph, Area Fills, Drawing Lines or Curves, Drawing the Graph
@subsection Writing Text on a Graph

@code{plptex} (@pxref{plptex; Write text inside the viewport}) allows text to be written within the limits set by @code{plenv} (@pxref{plenv; Set up standard window and draw box}).
The reference point of a text string may be located anywhere along an
imaginary horizontal line passing through the string at half the
height of a capital letter. The parameter
@code{just} specifies where along this line the
reference point is located. The string is then rotated about the
reference point through an angle specified by the parameters
@code{dx} and @code{dy}, so that the
string becomes parallel to a line joining @samp{(x, y)}
to @samp{(x+dx, y+dy)}.


@quotation

@t{
@b{plptex}
(@i{x}, @i{y}, @i{dx}, @i{dy}, @i{just}, @i{text});}
@end quotation

@table @asis

@item   @code{x, y} (@samp{PLFLT}, input)  
Coordinates of the reference point.

@item   @code{dx, dy} (@samp{PLFLT}, input)  
These specify the angle at which the text is to be printed.
The text is written parallel to a line joining the points
@samp{(x, y)} to @samp{(x+dx, y+dy)}
on the graph.

@item   @code{dx, dy} (@samp{PLFLT}, input)  
These specify the angle at which the text is to be printed.
The text is written parallel to a line joining the points
@samp{(x, y)} to @samp{(x+dx, y+dy)} on
the graph.

@item   @code{just} (@samp{PLFLT}, input)  
Determines justification of the string by specifying which
point within the string is placed at the reference point
@samp{(x, y)}. This parameter is a fraction of the
distance along the string. Thus if
@samp{@code{just} = 0.0}, the
reference point is at the left-hand edge of the string. If
@samp{@code{just} = 0.5}, it is at
the center and if @samp{@code{just} =
1.0}, it is at the right-hand edge.

@item   @code{text} (@samp{char *}, input)  
Pointer to the string of characters to be written.
@end table

@node Area Fills, More Complex Graphs, Writing Text on a Graph, Drawing the Graph
@subsection Area Fills

Area fills are done in the currently selected color, line style, line
width and pattern style.

@code{plfill} (@pxref{plfill; Draw filled polygon}) fills a polygon. The polygon consists of
@samp{n} vertices which define the polygon.


@quotation

@t{
@b{plfill}
(@i{n}, @i{x}, @i{y});}
@end quotation

@table @asis

@item   @code{n} (@samp{PLINT}, input)  
The number of vertices.

@item   @code{x, y} (@samp{PLFLT *}, input)  
Pointers to arrays with coordinates of the @samp{n}
vertices.
@end table

@node More Complex Graphs, , Area Fills, Drawing the Graph
@subsection More Complex Graphs

Functions @code{plbin} (@pxref{plbin; Plot a histogram from binned data}) and @code{plhist} (@pxref{plhist; Plot a histogram from unbinned data}) are provided for drawing histograms,
and functions @code{plerrx} (@pxref{plerrx; Draw x error bar}) and @code{plerry} (@pxref{plerry; Draw y error bar}) draw error bars about specified
points. There are lots more too (see @ref{The Common API for PLplot,,The Common API for PLplot}.).

@node Finishing Up, In Case of Error, Drawing the Graph, Simple Use of PLplot
@section Finishing Up

Before the end of the program, @i{always} call
@code{plend} (@pxref{plend; End plotting session}) to close any output plot files and to free up resources. For
devices that have separate graphics and text modes, @code{plend} (@pxref{plend; End plotting session}) resets
the device to text mode.

@node In Case of Error, , Finishing Up, Simple Use of PLplot
@section In Case of Error

If a fatal error is encountered during execution of a PLplot routine
then @code{plexit} (@pxref{plexit; Error exit}) is called. This routine prints an error message,
does resource recovery, and then exits. The user may specify an error
handler via @code{plsexit} that gets called before anything else is
done, allowing either the user to abort the error termination, or
clean up user-specific data structures before exit.

@node Advanced Use of PLplot, Deploying programs that use PLplot, Simple Use of PLplot, Top
@chapter Advanced Use of PLplot

In this chapter, we describe advanced use of PLplot. 

@menu
* Command Line Arguments::
* Output Devices::
* Adding FreeType Library Support to Bitmap Drivers::
* View Surfaces; [Sub-]Pages; Viewports and Windows::
* Setting Line Attributes::
* Setting the Area Fill Pattern::
* Setting Color::
* Setting Character Attributes::
* Three Dimensional Surface Plots::
* Contour and Shade Plots::
@end menu

@node Command Line Arguments, Output Devices, , Advanced Use of PLplot
@section Command Line Arguments

PLplot supports a large number of command line arguments, but it is
up to the user to pass these to PLplot for processing at the
beginning of execution.
@code{plparseopts} (@pxref{plparseopts; Parse command-line arguments}) is responsible for parsing
the argument list, removing all that are recognized by PLplot, and
taking the appropriate action before returning. There are an
extensive number of options available to affect this process. The
command line arguments recognized by PLplot are given by the -h
option:


@example

% x01c -h
Usage:
        ./x01c [options]

PLplot options:
    -h                   Print out this message
    -v                   Print out the PLplot library version number
    -verbose             Be more verbose than usual
    -debug               Print debugging info (implies -verbose)
    -dev name            Output device name
    -o name              Output filename
    -display name        X server to contact
    -px number           Plots per page in x
    -py number           Plots per page in y
    -geometry geom       Window size, in pixels (e.g. -geometry 400x300)
    -wplt xl,yl,xr,yr    Relative coordinates [0-1] of window into plot
    -mar margin          Margin space in relative coordinates (0 to 0.5, def 0)
    -a aspect            Page aspect ratio (def: same as output device)
    -jx justx            Page justification in x (-0.5 to 0.5, def 0)
    -jy justy            Page justification in y (-0.5 to 0.5, def 0)
    -ori orient          Plot orientation (0,2=landscape, 1,3=portrait)
    -freeaspect          Do not preserve aspect ratio on orientation swaps
    -portrait            Sets portrait mode (both orientation and aspect ratio)
    -width width         Sets pen width (1 <= width <= 10)
    -bg color            Background color (0=black, FFFFFF=white)
    -ncol0 n             Number of colors to allocate in cmap 0 (upper bound)
    -ncol1 n             Number of colors to allocate in cmap 1 (upper bound)
    -fam                 Create a family of output files
    -fsiz size[kKmMgG]   Output family file size in MB (e.g. -fsiz 0.5G, def MB)
    -fbeg number         First family member number on output
    -finc number         Increment between family members
    -fflen length        Family member number minimum field width
    -nopixmap            Don't use pixmaps in X-based drivers
    -db                  Double buffer X window output
    -np                  No pause between pages
    -server_name name    Main window name of PLplot server (tk driver)
    -dpi dpi             Resolution, in dots per inch (e.g. -dpi 360x360)
    -compression num     Sets compression level in supporting devices
    -drvopt option[=value][,option[=value]]* Driver specific options
@end example

The command-line options can also be set using the @code{plsetopt} (@pxref{plsetopt; Set any command-line option}) function, if invoked before @code{plinit} (@pxref{plinit; Initialize PLplot}).

Some options are may not be recognized by individual drivers. If an option is not recognized but should be, please contact the driver author via the plplot mailing lists.

Many drivers have specific options that can be set using the -drvopt command line option or with @code{plsetopt} (@pxref{plsetopt; Set any command-line option}). These options are documented in @ref{The PLplot Display Driver Family,,The PLplot Display Driver Family}. and @ref{The PLplot Output Driver Family,,The PLplot Output Driver Family}..

@node Output Devices, Adding FreeType Library Support to Bitmap Drivers, Command Line Arguments, Advanced Use of PLplot
@section Output Devices

PLplot supports a variety of output devices, via a set of device drivers.
Each driver is required to emulate a small set of low-level graphics
primitives such as initialization, line draw and page advance, as well
as be completely independent of the PLplot package as a whole. Thus a
driver may be very simple, as in the case of the many black and white file
drivers (tektronix, etc.). More complicated and/or color systems require a
bit more effort by the driver, with the most effort required by an output
device with a graphical user interface, including menus for screen dumps,
palette manipulation, and so forth. At present only the tk driver does
the latter on Unix systems. At present we aren't pursuing
a Macintosh development effort due to a lack of time and expertise, but
will assist anyone wanting to volunteer for the job.

Note that if you always render to a PLplot metafile, you can always
@code{plrender} them to new devices as they become available.

The list of available devices presented when starting PLplot (via
@samp{plstar}) is determined at compile time. When installing PLplot you may wish
to exclude devices not available on your system in order to reduce screen
clutter. To include a specified device, simply define the appropriate macro
constant when building PLplot (see the installation instructions for your
system).

The device drivers for PLplot terminal output at present are given in 
@ref{PLplot Terminal Output Devices,,PLplot Terminal Output Devices}. while 
drivers for file output are given in
@ref{PLplot File Output Devices,,PLplot File Output Devices}..
The driver for OS/2 PM is available separately. See the section on OS/2 in
the Appendix for more details.
@anchor{PLplot Terminal Output Devices}

@strong{PLplot Terminal Output Devices}

@multitable @columnfractions 0.333333333333333 0.333333333333333 0.333333333333333
@item
Device@tab keyword@tab driver file
@item
X-Window Screen@tab xwin@tab xwin.c
@item
Tcl/Tk widget@tab tk@tab tk.c
@item
Linux console VGA@tab vga@tab linuxvga.c
@item
Xterm Window@tab xterm@tab tek.c
@item
Tektronix Terminal (4010)@tab tekt@tab tek.c
@item
Tektronix Terminal (4105/4107)@tab tek4107t@tab tek.c
@item
MS-Kermit emulator@tab mskermit@tab tek.c
@item
Versaterm vt100/tek emulator@tab versaterm@tab tek.c
@item
VLT vt100/tek emulator@tab vlt@tab tek.c
@item
Conex vt320/tek emulator@tab conex@tab tek.c
@item
DG300 Terminal@tab dg300@tab dg300.c
@item
NeXT display (unsupported)@tab nx@tab next.c
@item
GNOME display@tab gnome@tab gnome.c
@item
GNOME Canvas Widget / Display@tab gcw@tab gcw.c
@end multitable

@noindent
@anchor{PLplot File Output Devices}

@strong{PLplot File Output Devices}

@multitable @columnfractions 0.333333333333333 0.333333333333333 0.333333333333333
@item
Device@tab keyword@tab driver file
@item
PLplot Native Meta-File@tab plmeta@tab plmeta.c
@item
Tektronix File (4010)@tab tekf@tab tek.c
@item
Tektronix File (4105/4107)@tab tek4107f@tab tek.c
@item
PostScript File (monochrome)@tab ps@tab ps.c
@item
PostScript File (color)@tab psc@tab ps.c
@item
XFig file@tab xfig@tab xfig.c
@item
LaserJet IIp Bitmap File @tab ljiip@tab ljiip.c
@item
LaserJet II Bitmap File (150 dpi)@tab ljii@tab ljii.c
@item
HP 7470 Plotter File (HPGL Cartridge Small Plotter)@tab hp7470@tab hpgl.c
@item
HP 7580 Plotter File (Large Plotter)@tab hp7580@tab hpgl.c
@item
HP Laser Jet, HPGL file@tab lj_hpgl@tab hpgl.c
@item
Impress File@tab imp@tab impress.c
@item
Portable bitmap file@tab pbm@tab pbm.c
@item
Null device@tab null@tab null.c
@item
JPEG file@tab jpeg@tab gd.c
@item
PNG file@tab png@tab gd.c
@item
Computer Graphics Metafile@tab cgm@tab cgm.c
@end multitable

@menu
* Driver Functions::
* PLplot Metafiles and Plrender::
* Family File Output::
* Interactive Output Devices::
* Specifying the Output Device::
@end menu

@node Driver Functions, PLplot Metafiles and Plrender, , Output Devices
@subsection Driver Functions

A dispatch table is used to direct function calls to whatever driver
is chosen at run-time. Below are listed the names of each entry in the
PLDispatchTable dispatch table struct defined in
@file{plcore.h}. The entries specific to each device (defined
in @file{drivers/*.c}) are typically named similarly but with
pl_ replaced by a string specific for that device (the
logical order must be preserved, however). The dispatch table entries are :

@itemize @bullet{}

@item
@samp{pl_MenuStr}: Pointer to string that is printed in device menu.

@item
@samp{pl_DevName}: A short device "name" for device selection by name.

@item
@samp{pl_type}: 0 for file-oriented device, 1 for interactive
(the null driver uses -1 here).

@item
@samp{pl_init}: Initialize device. This routine may also prompt the user
for certain device parameters or open a graphics file
(see Notes). Called only once to set things up. Certain
options such as familying and resolution (dots/mm) should
be set up before calling this routine (note: some drivers
ignore these).

@item
@samp{pl_line}: Draws a line between two points.

@item
@samp{pl_polyline}: Draws a polyline (no broken segments).

@item
@samp{pl_eop}: Finishes out current page (see Notes).

@item
@samp{pl_bop}: Set up for plotting on a new page. May also open a new
a new graphics file (see Notes).

@item
@samp{pl_tidy}: Tidy up. May close graphics file (see Notes).

@item
@samp{pl_state}: Handle change in PLStream state
(color, pen width, fill attribute, etc).

@item
@samp{pl_esc}: Escape function for driver-specific commands.
@end itemize

@noindent
Notes: Most devices allow multi-page plots to be stored in a single graphics
file, in which case the graphics file should be opened in the pl_init()
routine, closed in pl_tidy(), and page advances done by calling pl_eop and
pl_bop() in sequence. If multi-page plots need to be stored in different
files then pl_bop() should open the file and pl_eop() should close it. Do
NOT open files in both pl_init() and pl_bop() or close files in both
pl_eop() and pl_tidy(). It is recommended that when adding new functions to
only a certain driver, the escape function be used. Otherwise it is
necessary to add a null routine to all the other drivers to handle the new
function. 

@node PLplot Metafiles and Plrender, Family File Output, Driver Functions, Output Devices
@subsection PLplot Metafiles and Plrender

The PLplot metafile is a way to store and transport your graphical data for
rendering at a later time or on a different system. A PLplot metafile is
in binary format in order to speed access and keep storage costs
reasonable. All data is stored in device-independent format (written as a
stream of bytes); the resulting file is about as portable as a tektronix
vector graphics file and only slightly larger. 

Each PLplot metafile begins with a header string that identifies it as
such, as well as the version number of the format since
this may change in time. The utility for rendering the metafile,
@code{plrender}, verifies that the input file is indeed a valid PLplot metafile,
and that it understands the format the metafile is written in.
@code{plrender} is part of the PLplot package and should be built at the time of
building PLplot, and then put into your search path. It is capable of 
high speed rendering of the graphics file, especially if the output device
can accept commands at a high rate (e.g. X windows). 

The commands as written by the metafile driver at present are as follows:

@itemize @bullet{}

@item
@samp{INITIALIZE}

@item
@samp{CLOSE}

@item
@samp{SWITCH_TO_TEXT}

@item
@samp{SWITCH_TO_GRAPH}

@item
@samp{CLEAR}

@item
@samp{PAGE}

@item
@samp{NEW_COLOR}

@item
@samp{NEW_WIDTH}

@item
@samp{LINE}

@item
@samp{LINETO}

@item
@samp{ESCAPE}

@item
@samp{ADVANCE}
@end itemize

Each command is written as a single byte, possibly followed by
additional data bytes. The @samp{NEW_COLOR} and
@samp{NEW_WIDTH} commands each write 2 data bytes, the
@samp{LINETO} command writes 4 data bytes, and the
@samp{LINE} command writes 8 data bytes. The most common
instruction in the typical metafile will be the @samp{LINETO}
command, which draws a continuation of the previous line to the given point.
This data encoding is not quite as efficient as the tektronix format, which
uses 4 bytes instead of 5 here (1 command @samp{+} 4 data),
however the PLplot encoding is far simpler to implement and more robust. The
@samp{ESCAPE} function writes a second command character
(opcode) followed by an arbitrary number of data bytes depending on the
value of the opcode. Note that any data written must be in device
independent form to maintain the transportability of the metafile so
floating point numbers are not allowed. 

The short usage message for @code{plrender} is printed if one inputs
insufficient or invalid arguments, and is as follows:

@example

% plrender

No filename specified.

Usage:
        plrender [options] [files]

plrender options:
    [-v] [-i name] [-b number] [-e number] [-p page]

PLplot options:
    [-h] [-v] [-verbose] [-debug] [-dev name] [-o name] [-display name]
    [-px number] [-py number] [-geometry geom] [-wplt xl,yl,xr,yr]
    [-mar margin] [-a aspect] [-jx justx] [-jy justy] [-ori orient]
    [-freeaspect] [-width width] [-bg color] [-ncol0 n] [-ncol1 n] [-fam]
    [-fsiz size] [-fbeg number] [-finc number] [-fflen length] [-nopixmap]
    [-db] [-np] [-server_name name] [-server_host name] [-server_port name]
    [-user name]


Type plrender -h for a full description.

@end example

The longer usage message goes into more detail, and is as follows:

@example

% plrender -h

Usage:
        plrender [options] [files]

plrender options:
    -v                   Print out the plrender version number
    -i name              Input filename
    -b number            Beginning page number
    -e number            End page number
    -p page              Plot given page only

If the "-i" flag is omitted, unrecognized input will assumed to be filename
parameters.  Specifying "-" for the input or output filename means use stdin
or stdout, respectively.  See the manual for more detail.

PLplot options:
    -h                   Print out this message
    -v                   Print out the PLplot library version number
    -verbose             Be more verbose than usual
    -debug               Print debugging info (implies -verbose)
    -dev name            Output device name
    -o name              Output filename
    -display name        X server to contact
    -px number           Plots per page in x
    -py number           Plots per page in y
    -geometry geom       Window size, in pixels (e.g. -geometry 400x300)
    -wplt xl,yl,xr,yr    Relative coordinates [0-1] of window into plot
    -mar margin          Margin space in relative coordinates (0 to 0.5, def 0)
    -a aspect            Page aspect ratio (def: same as output device)
    -jx justx            Page justification in x (-0.5 to 0.5, def 0)
    -jy justy            Page justification in y (-0.5 to 0.5, def 0)
    -ori orient          Plot orientation (0,2=landscape, 1,3=portrait)
    -freeaspect          Do not preserve aspect ratio on orientation swaps
    -portrait            Sets portrait mode (both orientation and aspect ratio)
    -width width         Sets pen width (1 <= width <= 10)
    -bg color            Background color (0=black, FFFFFF=white)
    -ncol0 n             Number of colors to allocate in cmap 0 (upper bound)
    -ncol1 n             Number of colors to allocate in cmap 1 (upper bound)
    -fam                 Create a family of output files
    -fsiz size[kKmMgG]   Output family file size in MB (e.g. -fsiz 0.5G, def MB)
    -fbeg number         First family member number on output
    -finc number         Increment between family members
    -fflen length        Family member number minimum field width
    -nopixmap            Don't use pixmaps in X-based drivers
    -db                  Double buffer X window output
    -np                  No pause between pages
    -server_name name    Main window name of PLplot server (tk driver)
    -dpi dpi             Resolution, in dots per inch (e.g. -dpi 360x360)
    -compression num     Sets compression level in supporting devices
    -drvopt option[=value][,option[=value]]* Driver specific options
@end example

The options are generally self explanatory (family files are explained in
@ref{Family File Output,,Family File Output}.).
Most of these options have default values, and for those that don't
@code{plrender} will prompt the user. The
@samp{-px} and @samp{-py} options are
not so useful at present, because everything is scaled down by the
specified factor --- resulting in labels that are too small (future
versions of @code{plrender} might allow changing the label size as well). 

Additional options may be added in future releases.

@node Family File Output, Interactive Output Devices, PLplot Metafiles and Plrender, Output Devices
@subsection Family File Output

When sending PLplot to a file, the user has the option of generating a
family of output files for most output file drivers.
This can be valuable when generating a large amount of output, so as to not
strain network or printer facilities by processing extremely large single
files. Each family member file can be treated as a completely independent
file. In addition, @code{plrender} has the ability to process a set of
family member files as a single logical file.

To create a family file, one must simply call @code{plsfam} (@pxref{plsfam; Set family file parameters}) with the
familying flag @samp{fam} set to 1, and the desired maximum
member size (in bytes) in @samp{bmax}. @code{plsfam} (@pxref{plsfam; Set family file parameters}) also allows
you to set the current family file number. If the current output
driver does not support familying, there will be no effect. This call must
be made @i{before} calling @code{plstar} (@pxref{plstar; Initialization}) or @code{plstart} (@pxref{plstart; Initialization}). 

If familying is enabled, the name given for the output file (on the
command line, in response to the @code{plstar} (@pxref{plstar; Initialization}) prompt, as a @code{plstart} (@pxref{plstart; Initialization}) argument,
or as the result of a call to @code{plsfnam} (@pxref{plsfnam; Set output file name})) becomes the name template for the
family. Thus, if you request a plmeta output file with name
@file{test-%n.plm}, the files actually created will be
@file{test-1.plm}, @file{test-2.plm}, and so on,
where @file{%n} indicates where the member number is replaced.
If there is no @file{%n}, then the output file becomes the
stem name and the created files will be like
@file{test.plm.1}, @file{test.plm.2}, and so on.
A new file is automatically started once the byte limit for the current file
is passed, but not until the next page break. One may insure a new file at
every page break by making the byte limit small enough. Alternatively, if
the byte limit is large you can still insure a new file is automatically
started after a page break if you precede the call to @code{pleop} (@pxref{pleop; Eject current page}) with a call to
@code{plfamadv} (@pxref{plfamadv; Advance to the next family file on the next new page}).

The @code{plgfam} (@pxref{plgfam; Get family file parameters}) routine can be used from within the user program to find
out more about the graphics file being written. In particular, by
periodically checking the number of the member file currently being written
to, one can detect when a new member file is started. This information
might be used in various ways; for example you could spawn a process to
automatically plrender each metafile after it is closed (perhaps during a
long simulation run) and send it off to be printed. 

@code{plrender} has several options for dealing with
family files. It can process a single member file
(@code{plrender} @file{test.plm.1})
or the entire family if given only the stem name
(@code{plrender} @file{test.plm})
It can also create family files on output, rendering to any
device that supports familying, including another metafile if desired. The
size of member files in this case is input through the argument list, and
defaults to 1MB if unspecified (this may be changed during the PLplot
installation, however). @code{plrender} can also create a
single output file from a familied input metafile. 

@node Interactive Output Devices, Specifying the Output Device, Family File Output, Output Devices
@subsection Interactive Output Devices

Here we shall discuss briefly some of the more common interactive output
devices. 

Many popular terminals or terminal emulators at present have a
facility for switching between text and graphics screens.
This includes the xterm emulator under X-windows, vt100's with
Retrographics, and numerous emulators for microcomputers which have a dual
vt100/tek4010 emulation capability. On these devices, it is possible to
switch between the text and graphics screens by surrounding your PLplot
calls by calls to @code{plgra} (@pxref{plgra; Switch to graphics screen}) and @code{pltext} (@pxref{pltext; Switch to text screen}). This will allow your diagnostic and
informational code output to not interfere with your graphical output.

At present, only the xterm driver supports switching between text
and graphics screens. The escape sequences as sent by the xterm driver
are fairly standard, however, and have worked correctly on most other
popular vt100/tek4010 emulators we've tried.

When using the xterm driver, hitting a RETURN will advance and clear the
page. If indeed running from an xterm, you may resize, move, cover and
uncover the window. The behavior of the X-window driver is quite different,
however. First, it is much faster, as there is no tty-like handshaking
going on. Second, a mouse click is used to advance and clear the page,
rather than a RETURN.

On a tektronix 4014 compatible device, you may preview tektronix output
files via the @code{pltek} utility.
@code{pltek} will let you step through the file interactively,
skipping backward or forward if desired. The help message for
@code{pltek} is as follows:

@example

% pltek
Usage: pltek filename 
At the prompt, the following replies are recognized:
   h,?    Give this help message.
    q     Quit program.
   <n>    Go to the specified page number.
   -<n>   Go back <n> pages.
   +<n>   Go forward <n> pages.
 <Return> Go to the next page.

@end example

@noindent
The output device is switched to text mode before the prompt is given,
which causes the prompt to go to the vt102 window under xterm and
most vt100/tek4010 emulators.

@node Specifying the Output Device, , Interactive Output Devices, Output Devices
@subsection Specifying the Output Device

The main initialization routine for PLplot is @code{plinit} (@pxref{plinit; Initialize PLplot}), which sets up
all internal data structures necessary for plotting and initializes
the output device driver. The output device can be a terminal, disk
file, window system, pipe, or socket. If the output device has not
already been specified when @code{plinit} (@pxref{plinit; Initialize PLplot}) is called, a list of valid
output devices is given and the user is prompted for a choice. For
example:


@example

% x01c
	
Plotting Options:
 < 1> xwin       X-Window (Xlib)
 < 2> tk         Tcl/TK Window
 < 3> xterm      Xterm Window
 < 4> tekt       Tektronix Terminal (4010)
 < 5> tek4107t   Tektronix Terminal (4105/4107)
 < 6> mskermit   MS-Kermit emulator
 < 7> versaterm  Versaterm vt100/tek emulator
 < 8> vlt        VLT vt100/tek emulator
 < 9> plmeta     PLPLOT Native Meta-File
 <10> tekf       Tektronix File (4010)
 <11> tek4107f   Tektronix File (4105/4107)
 <12> ps         PostScript File (monochrome)
 <13> psc        PostScript File (color)
 <14> xfig       Xfig file
 <15> ljiip      LaserJet IIp/deskjet compressed graphics
 <16> ljii       LaserJet II Bitmap File (150 dpi)
 <17> null       Null device

Enter device number or keyword: 
@end example

Either the device number or a device keyword is accepted. Specifying
the device by keyword is preferable in aliases or scripts since the
device number is dependent on the install procedure (the installer
can choose which device drivers to include). The device can be
specified prior to the call to @code{plinit} (@pxref{plinit; Initialize PLplot}) by:

@itemize @bullet{}

@item
A call to @code{plsdev} (@pxref{plsdev; Set the device [keyword] name}).

@item
The @samp{-dev} @var{device}
command line argument, if the program's command line arguments
are being passed to the PLplot function
@code{plparseopts} (@pxref{plparseopts; Parse command-line arguments}).
@end itemize

Additional startup routines @code{plstar} (@pxref{plstar; Initialization}) and @code{plstart} (@pxref{plstart; Initialization}) are available but
these are simply front-ends to @code{plinit} (@pxref{plinit; Initialize PLplot}), and should be avoided. It
is preferable to call @code{plinit} (@pxref{plinit; Initialize PLplot}) directly, along with the appropriate
setup calls, for the greater amount of control this provides (see the
example programs for more info).

Before @code{plinit} (@pxref{plinit; Initialize PLplot}) is called, you may modify the number of subpages the
output device is divided into via a call to
@code{plssub}. Subpages are useful for placing several
graphs on a page, but all subpages are constrained to be of the same
size. For greater flexibility, viewports can be used (see @ref{Defining the Viewport,,Defining the Viewport}. for more info on viewports). The routine
@code{pladv} (@pxref{pladv; Advance the [sub-]page}) is used to advance to a particular subpage or to the next
subpage. The screen is cleared (or a new piece of paper loaded) if a
new subpage is requested when there are no subpages left on the
current page. When a page is divided into subpages, the default
character, symbol and tick sizes are scaled inversely as the square
root of the number of subpages in the vertical direction. This is
designed to improve readability of plot labels as the plot size
shrinks.

PLplot has the ability to write to multiple output streams. An
output stream corresponds to a single logical device to which one
plots independent of all other streams. The function @code{plsstrm} (@pxref{plsstrm; Set current output stream}) is
used to switch between streams -- you may only write to one output
stream at a time. At present, an output stream is not limited by the
type of device, however, it may not be wise to attempt opening two
terminal devices. An example usage for the creation of multiple
streams is as follows:


@example
#include "plplot.h"

main()
@{
    int nx = 2, ny = 2;

    plssub(nx, ny);
    plsdev("xwin");
    plinit();

    plots for stream 0

    plsstrm(1);
    plssub(nx, ny);
    plsdev("plmeta");
    plsfnam("tst.plm");
    plinit();

    plots for stream 1

    plsstrm(0);

    plots for stream 0
@end example

and so on, for sending output simultaneously to an X-window and a
metafile. The default stream corresponds to stream number zero. At
present, the majority of output drivers can only be used by a single
stream (exceptions include the metafile driver and X-window driver).
Also see example program 14 (note: only the C version is available,
although it can be done equally well from Fortran).

At the end of a plotting program, it is important to close the
plotting device by calling @code{plend} (@pxref{plend; End plotting session}). This flushes any internal
buffers and frees any memory that may have been allocated, for all
open output streams. You may call @code{plend1} (@pxref{plend1; End plotting session for current stream}) to close the plotting
device for the current output stream only. Note that if PLplot is
initialized more than once during a program to change the output
device, an automatic call to @code{plend1} (@pxref{plend1; End plotting session for current stream}) is made before the new device
is opened for the given stream.

@node Adding FreeType Library Support to Bitmap Drivers, View Surfaces; [Sub-]Pages; Viewports and Windows, Output Devices, Advanced Use of PLplot
@section Adding FreeType Library Support to Bitmap Drivers

Any bitmap driver in the PLplot family should be able to use fonts
(TrueType and others) that are rendered by the FreeType library just as long
as the device supports setting an individual pixel. Note that drivers
interact with FreeType using the support routines 
@samp{plD_FreeType_init},
@samp{plD_render_freetype_text},
@samp{plD_FreeType_Destroy},
@samp{pl_set_extended_cmap0}, and
@samp{pl_RemakeFreeType_text_from_buffer} that are coded in
@file{plfreetype.c}.

The use of these support routines is exemplified by the
@file{gd.c} driver. Here we make some notes to accompany
this driver which should make it easier to migrate other drivers to
use the FreeType library. Every code fragment we mention below should be surrounded
with a @samp{#ifdef HAVE_FREETYPE...#endif} to quarantine these
fragments for systems without the FreeType library. For interactive devices that
need caching of text drawing, reference should also be made to
@file{wingcc.c}.

@menu
* Write a call back function to plot a single pixel::
* Initialise FreeType::
* Add A Command to redraw text [interactive drivers only]::
* Add Function Prototypes::
* Add Closing functions::
@end menu

@node Write a call back function to plot a single pixel, Initialise FreeType, , Adding FreeType Library Support to Bitmap Drivers
@subsection Write a call back function to plot a single pixel

First, write a call back function, of type
@samp{plD_pixel_fp}, which specifies how a single pixel is set
in the current colour. This can be of type static void. For example, in the
@file{gd.c} driver it looks like this:

@example

void plD_pixel_gd (PLStream *pls, short x, short y)
@{
png_Dev *dev=(png_Dev *)pls->dev;

   gdImageSetPixel(dev->im_out, x, y,dev->colour);
@}
@end example

@node Initialise FreeType, Add A Command to redraw text [interactive drivers only], Write a call back function to plot a single pixel, Adding FreeType Library Support to Bitmap Drivers
@subsection Initialise FreeType

Next, we have to initialise the FreeType library. For the
@file{gd.c} driver this is done via two separate functions due
to the order that dependent information is initialised in the driver.

The "level 1" initialisation of FreeType does two things: 1) calls
@samp{plD_FreeType_init(pls)}, which in turn allocates memory to
the pls->FT structure; and 2) stores the location of the call back routine.


@example

void init_freetype_lv1 (PLStream *pls)
@{
FT_Data *FT;

plD_FreeType_init(pls);

FT=(FT_Data *)pls->FT;
FT->pixel= (plD_pixel_fp)plD_pixel_gd;

@}
@end example

This initialisation routine is called at the end of 
@samp{plD_init_png_Dev(PLStream *pls)} in the
@file{gd.c} driver:


@example

if (freetype)
   @{
    pls->dev_text = 1; /* want to draw text */
    init_freetype_lv1(pls);
    FT=(FT_Data *)pls->FT;
    FT->smooth_text=smooth_text;
   @}
@end example

@samp{"freetype"} is a local variable which is parsed
through @samp{plParseDrvOpts} to determine if the user wanted
FreeType text. In that case @samp{pls->dev_text} is set to 1 to
indicate the driver will be rendering it's own text. After that, we always
use @samp{pls->dev_text} to work out if we want FreeType or
not.

Similarly, @samp{"smooth_text"} is a local variable passed
through @samp{plParseDrvOpts} to find out if the user wants
smoothing. Since there is nothing in PLStream to track smoothing, we have to
set the FT->smooth_text flag as well at this time.

The "level 2" initialisation function initialises everything else
required for using the FreeType library but has to be called after the
screen resolution and dpi have been set. Therefore, it is called at the end
of @samp{plD_init_png()}, where it looks like:

@example

if (pls->dev_text)
   @{
    init_freetype_lv2(pls);
   @}
@end example

The actual function looks like this:

@example

static void init_freetype_lv2 (PLStream *pls)
@{
png_Dev *dev=(png_Dev *)pls->dev;
FT_Data *FT=(FT_Data *)pls->FT;

FT->scale=dev->scale;
FT->ymax=dev->pngy;
FT->invert_y=1;

if (FT->smooth_text==1)
   @{
    FT->ncol0_org=pls->ncol0;                                   /* save a copy of the original size of ncol0 */
    FT->ncol0_xtra=NCOLOURS-(pls->ncol1+pls->ncol0);            /* work out how many free slots we have */
    FT->ncol0_width=FT->ncol0_xtra/(pls->ncol0-1);              /* find out how many different shades of anti-aliasing we can do */
    if (FT->ncol0_width>64) FT->ncol0_width=64;                 /* set a maximum number of shades */
    plscmap0n(FT->ncol0_org+(FT->ncol0_width*pls->ncol0));      /* redefine the size of cmap0 */
/* the level manipulations are to turn off the plP_state(PLSTATE_CMAP0)
 * call in plscmap0 which (a) leads to segfaults since the GD image is
 * not defined at this point and (b) would be inefficient in any case since
 * setcmap is always called later (see plD_bop_png) to update the driver
 * color palette to be consistent with cmap0. */
    @{
       PLINT level_save;
       level_save = pls->level;
       pls->level = 0;
       pl_set_extended_cmap0(pls, FT->ncol0_width, FT->ncol0_org); /* call the function to add the extra cmap0 entries and calculate stuff */
       pls->level = level_save;
    @}
   @}

@}
@end example

FT->scale is a scaling factor to convert coordinates. This is used by
the @file{gd.c} and some other drivers to scale back a larger virtual page and this
eliminate the "hidden line removal bug". Set it to 1 if your device driver
doesn't use any scaling.

Some coordinate systems have zero on the bottom, others have zero on
the top. FreeType does it one way, and most everything else does it the
other. To make sure everything is working ok, we have to "flip" the
coordinates, and to do this we need to know how big in the Y dimension the
page is, and whether we have to invert the page or leave it alone.


@itemize @bullet{}

@item
FT->ymax specifies the size of the page

@item
FT->invert_y=1 tells us to invert the
y-coordinates, FT->invert_y=0 will not invert the coordinates.
@end itemize

We also do some computational gymnastics to "expand" cmap0 if the user
wants anti-aliased text. Basically, you have to work out how many spare
colours there are in the driver after cmap0 and cmap1 are done, then set a
few variables in FT to let the render know how many colours it's going to
have at its disposal, and call plscmap0n to resize cmap0. The call to
@samp{pl_set_extended_cmap0} does the remaining part of the
work. Note it essential to protect that call by the
@samp{pls->level} manipulations for the reasons stated. 

@node Add A Command to redraw text [interactive drivers only], Add Function Prototypes, Initialise FreeType, Adding FreeType Library Support to Bitmap Drivers
@subsection Add A Command to redraw text (interactive drivers only)

Plplot only caches drawing commands, not text plotting commands, so
for interactive devices which refresh their display by replaying the plot
buffer, a separate function has to be called to redraw the text. plfreetype
knows when buffering is being used by a device driver, and will automatically
start caching text when necessary. To redraw this cached text, a call to
@samp{pl_RemakeFreeType_text_from_buffer} has to be added after the driver has called
@samp{plRemakePlot}. The following example is from @file{wingcc.c}.

@example

                if (dev->waiting==1)
                @{
                    plRemakePlot(pls);
                    #ifdef HAVE_FREETYPE
                    pl_RemakeFreeType_text_from_buffer(pls);
                    #endif
                 @}
@end example

@node Add Function Prototypes, Add Closing functions, Add A Command to redraw text [interactive drivers only], Adding FreeType Library Support to Bitmap Drivers
@subsection Add Function Prototypes

Next, to the top of the drivers' source file add the prototype
definitions for the functions just written.

@example

static void plD_pixel_gd (PLStream *pls, short x, short y);
static void init_freetype_lv1 (PLStream *pls);
static void init_freetype_lv2 (PLStream *pls);
@end example

@node Add Closing functions, , Add Function Prototypes, Adding FreeType Library Support to Bitmap Drivers
@subsection Add Closing functions

Finally, add a @samp{plD_FreeType_Destroy(pls)} entry to
the device "tidy" function; this command deallocates memory allocated to the
FT entry in the stream, closes the FreeType library and any open fonts. It
is also a good idea to reset CMAP0 back to it's original size here if
anti-aliasing was done. For example, in the @file{gd.c}
driver, it looks like this:

@example

void plD_tidy_png(PLStream *pls)
@{
   fclose(pls->OutFile);

#ifdef HAVE_FREETYPE
   FT_Data *FT=(FT_Data *)pls->FT;
   plscmap0n(FT->ncol0_org);

   plD_FreeType_Destroy(pls);
#endif

   free_mem(pls->dev);
@}

@end example

@node View Surfaces; [Sub-]Pages; Viewports and Windows, Setting Line Attributes, Adding FreeType Library Support to Bitmap Drivers, Advanced Use of PLplot
@section View Surfaces, (Sub-)Pages, Viewports and Windows

There is a whole hierarchy of coordinate systems associated with
any PLplot graph. At the lowest level a device provides a view surface
(coordinates in mm's) which can be a terminal screen or a sheet of paper
in the output device. @code{plinit} (@pxref{plinit; Initialize PLplot}) or @code{plstar} (@pxref{plstar; Initialization}) (or @code{plstart} (@pxref{plstart; Initialization})) makes that
device view surface accessible as a page or divided up into sub-pages
(see @code{plssub} (@pxref{plssub; Set the number of subpages in x and y})) which are accessed with @code{pladv} (@pxref{pladv; Advance the [sub-]page}). Before a graph can be
drawn for a subpage, the program must call appropriate routines in
PLplot to define the viewport for the subpage and a window for the
viewport. A viewport is a rectangular region of the
@i{subpage} which is specified in normalized subpage
coordinates or millimetres. A window is a rectangular region of
world-coordinate space which is mapped directly to its viewport. (When
drawing a graph, the programmer usually wishes to specify the
coordinates of the points to be plotted in terms of the values of the
variables involved. These coordinates are called @i{world
coordinates}, and may have any floating-point value
representable by the computer.)

Although the usual choice is to have one viewport per subpage, and
one window per viewport, each subpage can have more than one (possibly
overlapping) viewport defined, and each viewport can have more than one
window (more than one set of world coordinates) defined.

@menu
* Defining the Viewport::
* Defining the Window::
* Annotating the Viewport::
* Setting up a Standard Window::
@end menu

@node Defining the Viewport, Defining the Window, , View Surfaces; [Sub-]Pages; Viewports and Windows
@subsection Defining the Viewport

After defining the view surface and subpage with the appropriate
call to @code{plinit} (@pxref{plinit; Initialize PLplot}) or @code{plstar} (@pxref{plstar; Initialization}) (or @code{plstart} (@pxref{plstart; Initialization})) and a call to @code{pladv} (@pxref{pladv; Advance the [sub-]page}) it
is necessary to define the portion of this subpage which is to be used
for plotting the graph (the viewport). All lines and symbols (except
for labels drawn by @code{plbox} (@pxref{plbox; Draw a box with axes; etc}), @code{plmtex} (@pxref{plmtex; Write text relative to viewport boundaries}) and @code{pllab} (@pxref{pllab; Simple routine to write labels})) are clipped at the
viewport boundaries. 

Viewports are created within the current subpage. If the
division of the output device into equally sized subpages is
inappropriate, it is best to specify only a single subpage which
occupies the entire output device (by using @code{plinit} (@pxref{plinit; Initialize PLplot}) or by setting
@samp{nx = 1} and @samp{ny = 1} in @code{plstar} (@pxref{plstar; Initialization})
or @code{plstart} (@pxref{plstart; Initialization})), and use one of the viewport specification subroutines
below to place the plot in the desired position on the page. 

There are four methods for specifying the viewport size, using the
subroutines @code{plvpor} (@pxref{plvpor; Specify viewport using coordinates}), @code{plsvpa} (@pxref{plsvpa; Specify viewport in absolute coordinates}), @code{plvasp} (@pxref{plvasp; Specify viewport using aspect ratio only}), and @code{plvpas} (@pxref{plvpas; Specify viewport using coordinates and aspect ratio}) which are
called like this:


@example
    plvpor(xmin, xmax, ymin, ymax);
    plsvpa(xmin, xmax, ymin, ymax);
    plvasp(aspect);
    plvpas(xmin, xmax, ymin, ymax, aspect);
@end example

where in the case of @code{plvpor} (@pxref{plvpor; Specify viewport using coordinates}) and @code{plvpas} (@pxref{plvpas; Specify viewport using coordinates and aspect ratio}), the arguments are given
in @i{normalized subpage coordinates} which are
defined to run from 0.0 to 1.0 along each edge of the subpage. Thus
for example,


@example
    plvpor(0.0, 0.5, 0.5, 1.0);
@end example

uses the top left quarter of the current subpage.

In order to get a graph of known physical size, the routine @code{plsvpa} (@pxref{plsvpa; Specify viewport in absolute coordinates})
defines the viewport in terms of absolute coordinates (millimeters)
measured from the bottom left-hand corner of the current subpage.
This routine should only be used when the size of the view surface is
known, and a definite scaling is required.

The routine @code{plvasp} (@pxref{plvasp; Specify viewport using aspect ratio only}) gives the largest viewport with the given aspect
ratio that fits in the current subpage (i.e. the ratio of the length
of the y axis to that of the x axis is equal to
@samp{aspect}). It also allocates space on the left and
top of the viewport for labels.

The routine @code{plvpas} (@pxref{plvpas; Specify viewport using coordinates and aspect ratio}) gives the largest viewport with the given aspect
ratio that fits in the specified region (specified with normalized
subpage coordinates, as with @code{plvpor} (@pxref{plvpor; Specify viewport using coordinates})). This routine is functionally
equivalent to @code{plvpor} (@pxref{plvpor; Specify viewport using coordinates}) when a natural aspect ratio is
chosen (done by setting @samp{aspect} to 0.0). Unlike
@code{plvasp} (@pxref{plvasp; Specify viewport using aspect ratio only}), this routine reserves no extra space at the edges for
labels.

To help the user call @code{plsvpa} (@pxref{plsvpa; Specify viewport in absolute coordinates}) correctly, the routine @code{plgspa} (@pxref{plgspa; Get current subpage parameters}) is
provided which returns the positions of the extremities of the
current subpage measured in millimeters from the bottom left-hand
corner of the device. Thus, if to set up a viewport with a 10.0 mm
margin around it within the current subpage, the following sequence
of calls may be used:


@example
    plgspa(xmin, xmax, ymin, ymax);
    plsvpa(10.0, xmax-xmin-10.0, 10.0, ymax-ymin-10.0);
@end example

A further routine @code{plvsta} (@pxref{plvsta; Select standard viewport}) is available which sets up a standard
viewport within the current subpage with suitable margins on each
side of the viewport. This may be used for simple graphs, as it
leaves enough room for axis labels and a title. This standard
viewport is that used by @code{plenv} (@pxref{plenv; Set up standard window and draw box}) (See @ref{Setting up a Standard Window,,Setting up a Standard Window}.).

Another way to get a specified aspect ratio is via the routine
@code{plsasp} [not!.. fix this], which sets the global
aspect ratio and must be called prior to @code{plstar} (@pxref{plstar; Initialization}). An aspect ratio
of 0.0 corresponds to natural dimensions (i.e. fill
the page); any positive value will give the specified aspect ratio.
This scaling of plots is actually done in the driver, and so may not
work for all output devices (note that @code{plrender}
is capable of scaled aspect ratio plots to any device whether that
device supports scaling or not). In such scaled plots, absolute
plotting is done in the scaled coordinate system.

@node Defining the Window, Annotating the Viewport, Defining the Viewport, View Surfaces; [Sub-]Pages; Viewports and Windows
@subsection Defining the Window

The window must be defined after the viewport in order to map the
world coordinate rectangle into the viewport rectangle. The routine
@code{plwind} (@pxref{plwind; Specify world coordinates of viewport boundaries}) is used to specify the rectangle in world-coordinate space.
For example, if we wish to plot a graph showing the collector current
I_C as a function of the collector to emitter
voltage V_CE for a transistor where 0 <=
I_C <= 10.0 mA and 0 <=
V_CE <= 12.0 V, we would call the
function @code{plwind} (@pxref{plwind; Specify world coordinates of viewport boundaries}) as follows:


@example
    plwind(0.0, 12.0, 0.0, 10.0);
@end example

Note that each of the arguments is a floating point number, and so
the decimal points are required. If the order of either the X limits
or Y limits is reversed, the corresponding axis will point in the
opposite sense, (i.e., right to left for X and top to bottom for Y).
The window must be defined before any calls to the routines which
actually draw the data points. Note however that @code{plwind} (@pxref{plwind; Specify world coordinates of viewport boundaries}) may also
be called to change the window at any time. This will affect the
appearance of objects drawn later in the program, and is useful for
drawing two or more graphs with different axes on the same piece of
paper.

@node Annotating the Viewport, Setting up a Standard Window, Defining the Window, View Surfaces; [Sub-]Pages; Viewports and Windows
@subsection Annotating the Viewport

The routine @code{plbox} (@pxref{plbox; Draw a box with axes; etc}) is used to specify whether a frame is drawn
around the viewport and to control the positions of the axis
subdivisions and numeric labels. For our simple graph of the
transistor characteristics, we may wish to draw a frame consisting of
lines on all four sides of the viewport, and to place numeric labels
along the bottom and left hand side. We can also tell PLplot to
choose a suitable tick interval and the number of subticks between
the major divisions based upon the data range specified to @code{plwind} (@pxref{plwind; Specify world coordinates of viewport boundaries}).
This is done using the following statement


@example
    plbox("bcnst", 0.0, 0, "bcnstv", 0.0, 0);
@end example

The lengths of major and minor ticks on the axes are set up by the
routines @code{plsmaj} (@pxref{plsmaj; Set length of major ticks}) and @code{plsmin} (@pxref{plsmin; Set length of minor ticks}).

Another routine @code{pllab} (@pxref{pllab; Simple routine to write labels}) provides for text labels for the bottom, left
hand side and top of the viewport. These labels are not clipped,
even though they lie outside the viewport (but they are clipped at
the subpage boundaries). @code{pllab} (@pxref{pllab; Simple routine to write labels}) actually calls the more general
routine @code{plmtex} (@pxref{plmtex; Write text relative to viewport boundaries}) which can be used for plotting labels at any point
relative to the viewport. For our example, we may use


@example
    pllab("V#dCE#u (Volts)", "I#dC#u (mA)", "TRANSISTOR CHARACTERISTICS");
@end example

Note that @samp{#d} and @samp{#u} are escape
sequences (see @ref{Escape sequences in text,,Escape sequences in text}.) which allow
subscripts and superscripts to be used in text. They are described
more fully later in this chapter.

The appearance of axis labels may be further altered by auxiliary
calls to @code{plprec} (@pxref{plprec; Set precision in numeric labels}), @code{plschr} (@pxref{plschr; Set character size}), @code{plsxax} (@pxref{plsxax; Set x axis parameters}), @code{plsyax} (@pxref{plsyax; Set y axis parameters}), and @code{plszax} (@pxref{plszax; Set z axis parameters}). The
routine @code{plprec} (@pxref{plprec; Set precision in numeric labels}) is used to set the number of decimal places
precision for axis labels, while @code{plschr} (@pxref{plschr; Set character size}) modifies the heights of
characters used for the axis and graph labels. Routines @code{plsxax} (@pxref{plsxax; Set x axis parameters}),
@code{plsyax} (@pxref{plsyax; Set y axis parameters}), and @code{plszax} (@pxref{plszax; Set z axis parameters}) are used to modify the
@samp{digmax} setting for each axis, which affects how
floating point labels are formatted.

The @samp{digmax} variable represents the maximum field
width for the numeric labels on an axis (ignored if less than one).
If the numeric labels as generated by PLplot exceed this width, then
PLplot automatically switches to floating point representation. In
this case the exponent will be placed at the top left for a vertical
axis on the left, top right for a vertical axis on the right, and
bottom right for a horizontal axis.

For example, let's suppose that we have set @samp{digmax =
5} via @code{plsyax} (@pxref{plsyax; Set y axis parameters}), and for our plot a label is generated at
@samp{y = 0.0000478}. In this case the actual field
width is longer than @samp{digmax}, so PLplot switches to
floating point. In this representation, the label is printed as
simply 4.78 with the 10^-5 exponent placed
separately.

The determination of maximum length (i.e. @samp{digmax})
for fixed point quantities is complicated by the fact that long fixed
point representations look much worse than the same sized floating
point representation. Further, a fixed point number with magnitude
much less than one will actually gain in precision when written as
floating point. There is some compensation for this effect built
into PLplot, thus the internal representation for number of digits
kept (@samp{digfix}) may not always match the user's
specification (via @samp{digmax}). However, it will
always be true that @samp{digfix <= digmax}. The
PLplot defaults are set up such that good results are usually
obtained without user intervention.

Finally, after the call to @code{plbox} (@pxref{plbox; Draw a box with axes; etc}), the user may call routines
@code{plgxax} (@pxref{plgxax; Get x axis parameters}), @code{plgyax} (@pxref{plgyax; Get y axis parameters}), or @code{plgzax} (@pxref{plgzax; Get z axis parameters}) to obtain information about the
window just drawn. This can be helpful when deciding where to put
captions. For example, a typical usage would be to call @code{plgyax} (@pxref{plgyax; Get y axis parameters}) to
get the value of @samp{digits}, then offset the y axis
caption by that amount (plus a bit more) so that the caption
floats just to the outside of the numeric labels.
Note that the @samp{digits} value for each axis for the
current plot is not correct until @i{after} the call
to @code{plbox} (@pxref{plbox; Draw a box with axes; etc}) is complete.

@node Setting up a Standard Window, , Annotating the Viewport, View Surfaces; [Sub-]Pages; Viewports and Windows
@subsection Setting up a Standard Window

Having to call @code{pladv} (@pxref{pladv; Advance the [sub-]page}), @code{plvpor} (@pxref{plvpor; Specify viewport using coordinates}), @code{plwind} (@pxref{plwind; Specify world coordinates of viewport boundaries}) and @code{plbox} (@pxref{plbox; Draw a box with axes; etc}) is excessively
cumbersome for drawing simple graphs. Subroutine @code{plenv} (@pxref{plenv; Set up standard window and draw box}) combines
all four of these in one subroutine, using the standard viewport, and
a limited subset of the capabilities of @code{plbox} (@pxref{plbox; Draw a box with axes; etc}). For example, the
graph described above could be initiated by the call:


@example
    plenv(0.0, 12.0, 0.0, 10.0, 0, 0);
@end example

which is equivalent to the following series of calls:


@example
    pladv(0);
    plvsta();
    plwind(0.0, 12.0, 0.0, 10.0);
    plbox("bcnst", 0.0, 0, "bcnstv", 0.0, 0);
@end example

@node Setting Line Attributes, Setting the Area Fill Pattern, View Surfaces; [Sub-]Pages; Viewports and Windows, Advanced Use of PLplot
@section Setting Line Attributes

The graph drawing routines may be freely mixed with those described
in this section, allowing the user to control line color, width and
styles. The attributes set up by these routines apply modally, i.e,
all subsequent objects (lines, characters and symbols) plotted until
the next change in attributes are affected in the same way. The only
exception to this rule is that characters and symbols are not
affected by a change in the line style, but are always drawn using a
continuous line.

Line color is set using the routine @code{plcol0} (@pxref{plcol0; Set color; map0}). The argument is ignored
for devices which can only plot in one color, although some terminals
support line erasure by plotting in color zero.

Line width is set using @code{plwid} (@pxref{plwid; Set pen width}). This option is not supported by
all devices.

Line style is set using the routine @code{plstyl} (@pxref{plstyl; Set line style}) or @code{pllsty} (@pxref{pllsty; Select line style}). A broken
line is specified in terms of a repeated pattern consisting of marks
(pen down) and spaces (pen up). The arguments to this routine are
the number of elements in the line, followed by two pointers to
integer arrays specifying the mark and space lengths in micrometers.
Thus a line consisting of long and short dashes of lengths 4 mm
and 2 mm, separated by spaces of length 1.5 mm is specified
by:


@example
    mark[0] = 4000;
    mark[1] = 2000;
    space[0] = 1500;
    space[1] = 1500;
    plstyl(2, mark, space);
@end example

To return to a continuous line, just call @code{plstyl} (@pxref{plstyl; Set line style}) with first
argument set to zero. You can use @code{pllsty} (@pxref{pllsty; Select line style}) to choose between 8
different predefined styles.

@node Setting the Area Fill Pattern, Setting Color, Setting Line Attributes, Advanced Use of PLplot
@section Setting the Area Fill Pattern

The routine @code{plpat} (@pxref{plpat; Set area fill pattern}) can be used to set the area fill pattern. The
pattern consists of 1 or 2 sets of parallel lines with specified
inclinations and spacings. The arguments to this routine are the
number of sets to use (1 or 2) followed by two pointers to integer
arrays (of 1 or 2 elements) specifying the inclinations in tenths of
a degree and the spacing in micrometers (the inclination should be
between -900 and 900). Thus to specify an area fill pattern
consisting of horizontal lines spaced 2 mm apart use:


@example
    *inc = 0;
    *del = 2000;
    plpat(1, inc, del);
@end example

To set up a symmetrical crosshatch pattern with lines directed 30
degrees above and below the horizontal and spaced 1.5 mm apart
use:


@example
    *inc = 300;
    *(inc+1) = -300;
    *del = 1500;
    *(del+1) = 1500;
    plpat(2, inc, del);
@end example

The routine @code{plpsty} (@pxref{plpsty; Select area fill pattern}) can be used to select from 1 of 8 predefined
patterns.

The area fill routines also use the current line style, width and
colors to give a virtually infinite number of different patterns.

@node Setting Color, Setting Character Attributes, Setting the Area Fill Pattern, Advanced Use of PLplot
@section Setting Color

Normally, color is used for all drivers and devices that support
it within PLplot subject to the condition that the user has the option
of globally turning off the color (and subsequently turning it on again
if so desired) using @code{plscolor} (@pxref{plscolor; Used to globally turn color output on/off}). 

The PLplot color model utilizes two color maps which can be used
interchangeably. However, color map0 (discussed in @ref{Color Map0,,Color Map0}.) has discrete colors with no particular order
and is most suited to coloring the background, axes, lines, and labels,
and color map1 (discussed in @ref{Color Map1,,Color Map1}.) has
continuously changing colors and is most suited to plots (see @ref{Contour and Shade Plots,,Contour and Shade Plots}.) in which data values are represented by
colors. 

@menu
* Color Map0::
* Color Map1::
@end menu

@node Color Map0, Color Map1, , Setting Color
@subsection Color Map0

Color map0 is most suited to coloring the background, axes,
lines, and labels. Generally, the default color map0 palette of 16
colors is used. (@file{examples/c/x02c.c} illustrates
these colors.) The default background color is taken from the index 0
color which is black by default. The default foreground color is red.

There are a number of options for changing the default red on
black colors. The user may set the index 0 background color using the
command-line @samp{bg} parameter or by calling @code{plscolbg} (@pxref{plscolbg; Set the background color by 8-bit RGB value})
(or @code{plscol0} (@pxref{plscol0; Set a given color from color map0 by 8 bit RGB value}) with a 0 index) @i{before} @code{plinit} (@pxref{plinit; Initialize PLplot}).
During the course of the plot, the user can change the foreground color
as often as desired using @code{plcol0} (@pxref{plcol0; Set color; map0}) to select the index of the desired
color. 

For more advanced use it is possible to define an arbitrary map0
palette of colors. The user may set the number of colors in the map0
palette using the command-line @samp{ncol0} parameter or by
calling @code{plscmap0n} (@pxref{plscmap0n; Set number of colors in color map0}). @code{plscol0} (@pxref{plscol0; Set a given color from color map0 by 8 bit RGB value}) sets the RGB value of the given index
which must be less than the maximum number of colors (which is set by
default, by command line, by @code{plscmap0n} (@pxref{plscmap0n; Set number of colors in color map0}), or even by @code{plscmap0} (@pxref{plscmap0; Set color map0 colors by 8-bit RGB values})).
Alternatively, @code{plscmap0} (@pxref{plscmap0; Set color map0 colors by 8-bit RGB values}) sets up the entire map0 color palette. For
all these ways of defining the map0 palette any number of colors are
allowed in any order, but it is not guaranteed that the individual
drivers will actually be able to use more than 16 colors. 

@node Color Map1, , Color Map0, Setting Color
@subsection Color Map1

Color map1 is most suited to plots (see @ref{Contour and Shade Plots,,Contour and Shade Plots}.) in which data values are represented by
colors. The data are scaled to the input map1 range of floating point
numbers between 0. and 1. which in turn are mapped (using @code{plcol1} (@pxref{plcol1; Set color; map1})) to
colors using a default or user-specified map1 color transformation. Thus,
there are calls to @code{plcol1} (@pxref{plcol1; Set color; map1}) from within the code for @code{plshade} (@pxref{plshade; Shade individual region on the basis of value}) (see
@file{src/plshade.c}) and @code{plsurf3d} (@pxref{plsurf3d; Plot shaded 3-d surface plot}) (see
@file{src/plot3d.c}) to give a continuous range of
color corresponding to the data being plotted. In addition @code{plcol1} (@pxref{plcol1; Set color; map1}) can
be used to specify the foreground color using the map1 continuous color
palette (see the commented out section of
@file{examples/c/x12c.c} which gives an example of this
for a histogram), but normally @code{plcol0} (@pxref{plcol0; Set color; map0}) is a better tool for this job
(see @ref{Color Map0,,Color Map0}.) since discrete colors often give
a better-looking result. 

For more advanced use it is possible to define an arbitrary map1
palette of colors. The user may set the number of colors in this palette
using the command-line @samp{ncol1} parameter or by calling
@code{plscmap1n} (@pxref{plscmap1n; Set number of colors in color map1}). Furthermore, @code{plscmap1l} (@pxref{plscmap1l; Set color map1 colors using a piece-wise linear relationship}) can be used to set the map1 color
palette using linear interpolation between control points specified in
either RGB or HLS space.

There is a one-to-one correspondence between RGB and HLS color
spaces. RGB space is characterized by three 8-bit unsigned integers
corresponding to the intensity of the red, green, and blue colors. Thus,
in hexidecimal notation with the 3 bytes concatanated together the RGB
values of FF0000, FFFF00, 00FF00, 00FFFF, 0000FF, FF00FF, 000000, and
FFFFFF correspond to red, yellow, green, cyan, blue, magenta, black, and
white. 

HLS (hue, lightness, and saturation) space is often conceptually
easier to use than RGB space. One useful way to visualize HLS space is
as a volume made up by two cones with their bases joined at the
equator. A given RGB point corresponds to HLS point
somewhere on or inside the double cones, and vice versa. The hue
corresponds to the longitude of the point with 0, 60,
120, 180, 240, and 300 degrees corresponding to red, yellow, green,
cyan, blue, and magenta. The lightness corresponds to the distance along
the axis of the figure of a perpendicular dropped from the HLS point to
the axis. This values ranges from 0 at the south pole to
1 at the north pole. The saturation corresponds to the
distance of the HLS point from the axis with the on-axis value being 0
and the surface value being 1. Full saturation corresponds to full color
while reducing the saturation (moving toward the axis of the HLS figure)
mixes more gray into the color until at zero saturation on the axis of
the figure you have only shades of gray with the variation of lightness
along the axis corresponding to a gray scale. 

Here are some C-code fragments which use @code{plscmap1l} (@pxref{plscmap1l; Set color map1 colors using a piece-wise linear relationship}) to set the
map1 color palette. This first example illustrates how to set up a
gray-scale pallette using linear interpolation in RGB space.

@example
    i[0] = 0.;
    i[1] = 1.;
    /* RGB are rescaled to the range from 0 to 1. for input to plscmap1l.*/
    r[0] = 0.;
    r[1] = 1.;
    g[0] = 0.;
    g[1] = 1.;
    b[0] = 0.;
    b[1] = 1.;
    plscmap1l(1, 2, i, r, g, b, NULL);
@end example

This second example illustrates doing the same thing in HLS
space.

@example
    i[0] = 0.;
    i[1] = 1.;
    /* Hue does not matter for zero saturation.*/
    h[0] = 0.;
    h[1] = 0.;
    /* Lightness varies through its full range.*/
    l[0] = 0.;
    l[1] = 1.;
    /* Saturation is zero for a gray scale.*/
    s[0] = 0.;
    s[1] = 0.;
    /* Note the first argument which specifies HLS space.*/
    plscmap1l(0, 2, i, h, l, s, NULL);
@end example

This final example using @code{plscmap1l} (@pxref{plscmap1l; Set color map1 colors using a piece-wise linear relationship}) illustrates how the default
map1 color pallette is set with just 4 control points (taken from
@file{src/plctrl.c}).

@example
/*--------------------------------------------------------------------------*\
 * plcmap1_def()
 *
 * Initializes color map 1.
 *
 * The default initialization uses 4 control points in HLS space, the two
 * inner ones being very close to one of the vertices of the HLS double
 * cone.  The vertex used (black or white) is chosen to be the closer to
 * the background color.  If you don't like these settings you can always
 * initialize it yourself.
\*--------------------------------------------------------------------------*/

static void
plcmap1_def(void)
@{
    PLFLT i[4], h[4], l[4], s[4], vertex = 0.;

/* Positions of control points */

    i[0] = 0;		/* left boundary */
    i[1] = 0.45;	/* just before center */
    i[2] = 0.55;	/* just after center */
    i[3] = 1;		/* right boundary */

/* For center control points, pick black or white, whichever is closer to bg */
/* Be carefult to pick just short of top or bottom else hue info is lost */

    if (plsc->cmap0 != NULL)
	vertex = ((float) plsc->cmap0[0].r +
		  (float) plsc->cmap0[0].g +
		  (float) plsc->cmap0[0].b) / 3. / 255.;

    if (vertex < 0.5)
	vertex = 0.01;
    else
	vertex = 0.99;

/* Set hue */

    h[0] = 260;		/* low: blue-violet */
    h[1] = 260;		/* only change as we go over vertex */
    h[2] = 0;		/* high: red */
    h[3] = 0;		/* keep fixed */

/* Set lightness */

    l[0] = 0.5;		/* low */
    l[1] = vertex;	/* bg */
    l[2] = vertex;	/* bg */
    l[3] = 0.5;		/* high */

/* Set saturation -- keep at maximum */

    s[0] = 1;
    s[1] = 1;
    s[2] = 1;
    s[3] = 1;

    c_plscmap1l(0, 4, i, h, l, s, NULL);
@}
@end example

Finally, @code{plscmap1} (@pxref{plscmap1; Set color map1 colors using 8-bit RGB values}) is an additional method of setting the map1
color palette directly using RGB space. No interpolation is used with
@code{plscmap1} (@pxref{plscmap1; Set color map1 colors using 8-bit RGB values}) so it is the programmer's responsibility to make sure that
the colors vary smoothly. Here is an example of the method taken from
@file{examples/c/x08c.c} which sets (yet again) the
gray-scale color pallette.

@example
    for (i=0;i<n_col;i++)
        rr[i] = gg[i] = bb[i] = i*256/n_col;
    plscmap1(rr,gg,bb,n_col);
@end example

@node Setting Character Attributes, Three Dimensional Surface Plots, Setting Color, Advanced Use of PLplot
@section Setting Character Attributes

Plplot uses two separate font systems to display characters. The
traditional system uses Hershey fonts which are available for all
device drivers, while the recently introduced unicode system is
currently available only for the ps, psc, png, jpeg, and gif devices.
For details on how to enable the unicode font system for additional
device drivers using the FreeType library, see 
@ref{Adding FreeType Library Support to Bitmap Drivers,,Adding FreeType Library Support to Bitmap Drivers}..

@menu
* Hershey fonts::
* Unicode fonts::
* FCI::
* Escape sequences in text::
* Character size adjustment::
@end menu

@node Hershey fonts, Unicode fonts, , Setting Character Attributes
@subsection Hershey fonts

There are two Hershey font character sets included with PLplot.
These are known
as the standard and extended character sets. The
standard character set is a subset of the extended set. It contains
177 characters including the ascii characters in a normal style font,
the Greek alphabet and several plotter symbols. The extended
character set contains almost 1000 characters, including four font
styles, and several math, musical and plotter symbols.

The extended character set is loaded into memory automatically when
@code{plstar} (@pxref{plstar; Initialization}) or @code{plstart} (@pxref{plstart; Initialization}) is called. The standard character set is
loaded by calling @code{plfontld} (@pxref{plfontld; Load character font}). The extended character set requires
about 50 KBytes of memory, versus about 5 KBytes for the standard
set. @code{plfontld} (@pxref{plfontld; Load character font}) can be used to switch between the extended and
standard sets (one set is unloaded before the next is loaded).
@code{plfontld} (@pxref{plfontld; Load character font}) can be called before @code{plstar} (@pxref{plstar; Initialization}).

When the extended character set is loaded there are four different
font styles to choose from. In this case, the routine @code{plfont} (@pxref{plfont; Set character font}) sets
up the default Hershey font for all character strings. It may be overridden
for any portion of a string by using an escape sequence within the
text, as described below. This routine has no effect when the
standard font set is loaded. The default font (1) is simple and
fastest to draw; the others are useful for presentation plots on a
high-resolution device.

The font codes are interpreted as follows:

@itemize @bullet{}

@item
@samp{font = 1}: normal (sans-serif) font

@item
@samp{font = 2}: roman (serif) font

@item
@samp{font = 3}: italic font

@item
@samp{font = 4}: script font
@end itemize

@node Unicode fonts, FCI, Hershey fonts, Setting Character Attributes
@subsection Unicode fonts

The advantages of the unicode fonts over the more traditional PLplot
Hershey fonts are the availability of many additional glyphs
(including mathematical symbols and glyphs from other than
western-European languages) and much better display of characters on
computer screens using anti-aliasing and hinting. Unicode fonts are
obtained by specifying a command-line option of -drvopt text for
the devices (currently ps, psc, png, jpeg, gif, gcw, and wingcc) 
where it has been implemented.

For the ps and psc devices, there is a fixed relationship between the
FCI (font characterization integer, see @ref{FCI,,FCI}.) 
and the actual Type 1
fonts that are being used. This fixed relationship is specified in
the Type1Lookup array in include/plfci.h. This array maps the
font-family attributes of sans-serif, serif, monotype, script, and
symbol to the standard postscript font families called Helvetica,
Times-Roman, Courier, Times-Roman, and Symbol. (There is no script
font family amongst the 35 standard Type 1 postscript fonts so that is
why we map the font-family attribute of script to Times-Roman.)
Similarly, this array maps the font-style attributes of upright,
italic or oblique and the font-weight attributes of medium or bold to
the appropriate variety of the Helvetica, Times-Roman, Courier,
and Symbol font families that are part of the 
35 standard Type 1 postscript fonts. These standard postscript fonts
are normally installed on a user's system using the gsfonts package.

For the devices handled by the FreeType library (currently png, jpeg,
and gif) there is a configurable relationship between the FCI (font
characterization integer, see @ref{FCI,,FCI}.) 
and the TrueType fonts that are actually used. 

On Unix/Linux systems, the TrueType fonts corresponding to the 30 possible
valid FCIs can be specified using ./configure options. (Use
./configure --help to see the possibilities and also the default
values for the fonts.) These ./configure defaults for the 30
possibilites are taken from fonts available from the ttf-freefont font
package. We recommend this font package because it has a rather
complete set of glyphs for most unicode blocks. (We also recommend
the gucharmap application for determining other unicode font
possibilities on your system that are available via the FreeType
library.)

On Windows systems, the fixed default TrueType fonts are specified in the
include/plfci.h file. (NOT PROGRAMMED YET, so this statement
will probably NEED REVISION.)

For all systems, the 30 possible TrueType fonts can be specified at run
time using the following environment variables:

@itemize @bullet{}

@item
PLPLOT_FREETYPE_SANS_FONT

@item
PLPLOT_FREETYPE_SERIF_FONT

@item
PLPLOT_FREETYPE_MONO_FONT

@item
PLPLOT_FREETYPE_SCRIPT_FONT

@item
PLPLOT_FREETYPE_SYMBOL_FONT

@item
PLPLOT_FREETYPE_SANS_ITALIC_FONT

@item
PLPLOT_FREETYPE_SERIF_ITALIC_FONT

@item
PLPLOT_FREETYPE_MONO_ITALIC_FONT

@item
PLPLOT_FREETYPE_SCRIPT_ITALIC_FONT

@item
PLPLOT_FREETYPE_SYMBOL_ITALIC_FONT

@item
PLPLOT_FREETYPE_SANS_OBLIQUE_FONT

@item
PLPLOT_FREETYPE_SERIF_OBLIQUE_FONT

@item
PLPLOT_FREETYPE_MONO_OBLIQUE_FONT

@item
PLPLOT_FREETYPE_SCRIPT_OBLIQUE_FONT

@item
PLPLOT_FREETYPE_SYMBOL_OBLIQUE_FONT

@item
PLPLOT_FREETYPE_SANS_BOLD_FONT

@item
PLPLOT_FREETYPE_SERIF_BOLD_FONT

@item
PLPLOT_FREETYPE_MONO_BOLD_FONT

@item
PLPLOT_FREETYPE_SCRIPT_BOLD_FONT

@item
PLPLOT_FREETYPE_SYMBOL_BOLD_FONT

@item
PLPLOT_FREETYPE_SANS_BOLD_ITALIC_FONT

@item
PLPLOT_FREETYPE_SERIF_BOLD_ITALIC_FONT

@item
PLPLOT_FREETYPE_MONO_BOLD_ITALIC_FONT

@item
PLPLOT_FREETYPE_SCRIPT_BOLD_ITALIC_FONT

@item
PLPLOT_FREETYPE_SYMBOL_BOLD_ITALIC_FONT

@item
PLPLOT_FREETYPE_SANS_BOLD_OBLIQUE_FONT

@item
PLPLOT_FREETYPE_SERIF_BOLD_OBLIQUE_FONT

@item
PLPLOT_FREETYPE_MONO_BOLD_OBLIQUE_FONT

@item
PLPLOT_FREETYPE_SCRIPT_BOLD_OBLIQUE_FONT

@item
PLPLOT_FREETYPE_SYMBOL_BOLD_OBLIQUE_FONT
@end itemize

@noindent
On Unix/Linux systems if these environment variables are not specified
with an absolute path starting with "/", then the absolute path is
specified by the configured default (see ./configure --help) or at
run time with the
environment variable PLPLOT_FREETYPE_FONT_DIR.

@node FCI, Escape sequences in text, Unicode fonts, Setting Character Attributes
@subsection FCI

We specify the properties of unicode fonts with the FCI (font
characterization integer). The FCI is a 32-bit unsigned integer whose
left-most hexadecimal digit is marked with an 0x1 to distinguish it
from a unicode (UCS4) integer (which is also an unsigned 32-bit
integer but with a maximum value of 0x0010ffff). Users obtain the current
FCI by calling @code{plgfci} (@pxref{plgfci; Get FCI [font characterization integer]}) and store a new FCI to be used at the start
of each subsequent string using @code{plsfci} (@pxref{plsfci; Set FCI [font characterization integer]}). Independent
hexadecimal values within the FCI are characterized by the
hexdigit and hexpower. The hexpower is defined as the power of 16 or
number of hexadecimal places to the left of the "decimal place" in the FCI 
where the hexdigit is stored.
The interpretation of the hexdigit and hexpower values in the FCI are
given in @ref{FCI interpretation,,FCI interpretation}..

@noindent
@anchor{FCI interpretation}

@strong{FCI interpretation}

@multitable @columnfractions 0.142857142857143 0.142857142857143 0.142857142857143 0.142857142857143 0.142857142857143 0.142857142857143 0.142857142857143
@item
@tab hexdigit -->@tab 0@tab 1@tab 2@tab 3@tab 4
@item
Font attribute@tab hexpower@tab @tab @tab @tab @tab 
@item
font-family@tab 0@tab sans-serif@tab serif@tab monospace@tab script@tab symbol
@item
font-style@tab 1@tab upright@tab italic@tab oblique@tab @tab 
@item
font-weight@tab 2@tab medium@tab bold@tab @tab @tab 
@end multitable

Note the maximum value of hexdigit is 7 and the maximum value of
hexpower is 6 so there is substantial room for expansion of this
scheme. On the other hand, since each font attribute is independent
of the rest, what is implemented now gives us a maximum of 30
different font possibilities which is probably more than enough for
most plotting purposes.

@node Escape sequences in text, Character size adjustment, FCI, Setting Character Attributes
@subsection Escape sequences in text

The routines which draw text all allow you to include escape
sequences in the text to be plotted. These are character sequences
that are interpreted as instructions to change fonts, draw
superscripts and subscripts, draw non-ASCII (e.g. Greek), and so on.
All escape sequences start with a number symbol
(@samp{#}) by default. Some language interfaces have
the capability of changing this default, but we will assume
(@samp{#}) in the remaining documentation of the escape
sequences.

The following escape sequences are defined:

@itemize @bullet{}

@item
@samp{#u}: move up to the superscript position
(ended with @samp{#d})

@item
@samp{#d}: move down to subscript position
(ended with @samp{#u})

@item
@samp{#b}: backspace (to allow overprinting)

@item
@samp{##}: number symbol

@item
@samp{#+}: toggle overline mode

@item
@samp{#-}: toggle underline mode

@item
@samp{#gx}: Greek letter corresponding to Roman
letter @samp{x} (see below)

@item
@samp{#fn}: switch to normal (sans-serif) font

@item
@samp{#fr}: switch to Roman (serif) font

@item
@samp{#fi}: switch to italic font

@item
@samp{#fs}: switch to script font

@item
@samp{#(nnn)}: Hershey character nnn (1 to 4
decimal digits) 

@item
@samp{#[nnn]}: unicode character nnn (nnn can
be decimal or hexadecimal [e.g., starting with 0x]) (UNICODE ONLY).

@item
@samp{<0x1nnnnnnn>}: absolute FCI to be used to
change fonts in mid-string. (nnnnnnn must be exactly 7
digits). (UNICODE ONLY).

@item
@samp{<0xmn>}: change just one attribute
of the FCI in mid-string where m is the hexdigit and n is
the hexpower. If more than two digits are given (so long
as the eigth digit does not mark this as an absolute FCI, see
above) they
are ignored. (UNICODE ONLY).

@item
@samp{<FCI COMMAND STRING/>}: the FCI COMMAND
STRING is currently one of "sans-serif", "serif", "monospace",
"script", "symbol", "upright", "italic", "oblique" "medium",
or "bold" (without the surrounding quotes). These FCI
COMMAND STRINGS change one attribute of the FCI according to
their name. (UNICODE ONLY).
@end itemize

Sections of text can have an underline or overline appended. For
example, the string S-freq is obtained by specifying
@samp{"#+S#+(#-freq#-)"}. 

Greek letters are obtained by @samp{#g} followed by a
Roman letter. @ref{Roman Characters Corresponding to Greek Characters,,Roman Characters Corresponding to Greek Characters}. shows how these letters map
into Greek characters.

@noindent
@anchor{Roman Characters Corresponding to Greek Characters}

@strong{Roman Characters Corresponding to Greek Characters}

@multitable @columnfractions 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769
@item
Roman@tab A@tab B@tab G@tab D@tab E@tab Z@tab Y@tab H@tab I@tab K@tab L@tab M
@item
Greek@tab Alpha@tab Beta@tab Gamma@tab Delta@tab Epsilon@tab Zeta@tab Eta@tab Theta@tab Iota@tab Kappa@tab Lambda@tab Mu
@end multitable

@multitable @columnfractions 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769
@item
Roman@tab N@tab C@tab O@tab P@tab R@tab S@tab T@tab U@tab F@tab X@tab Q@tab W
@item
Greek@tab Nu@tab Xi@tab Omicron@tab Pi@tab Rho@tab Sigma@tab Tau@tab Upsilon@tab Phi@tab Chi@tab Psi@tab Omega
@end multitable

@multitable @columnfractions 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769
@item
Roman@tab a@tab b@tab g@tab d@tab e@tab z@tab y@tab h@tab i@tab k@tab l@tab m
@item
Greek@tab alpha@tab beta@tab gamma@tab delta@tab epsilon@tab zeta@tab eta@tab theta@tab iota@tab kappa@tab lambda@tab mu
@end multitable

@multitable @columnfractions 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769 0.0769230769230769
@item
Roman@tab n@tab c@tab o@tab p@tab r@tab s@tab t@tab u@tab f@tab x@tab q@tab w
@item
Greek@tab nu@tab xi@tab omicron@tab pi@tab rho@tab sigma@tab tau@tab upsilon@tab phi@tab chi@tab psi@tab omega
@end multitable

The escape sequences @samp{#fn}, @samp{#fr},
@samp{#fi}, @samp{#fs}, and 
@samp{#(nnn)} are designed for the four Hershey fonts, but
an effort has been made to allow some limited forward compatibility so
these escape sequences have a reasonable result when unicode
fonts are being used. However, for maximum flexibility when using
unicode fonts, these 5 escape sequences should be replaced by using
the 4 escape sequences @samp{#[nnn]},
@samp{<0x1nnnnnnn>},
@samp{<0xmn>}, or @samp{<FCI COMMAND
STRING/>} as appropriate.

@node Character size adjustment, , Escape sequences in text, Setting Character Attributes
@subsection Character size adjustment

The routine @code{plschr} (@pxref{plschr; Set character size}) is used to set up the size of subsequent
characters drawn. The actual height of a character is the product of
the default character size and a scaling factor. If no call is made
to @code{plschr} (@pxref{plschr; Set character size}), the default character size is set up depending on the
number of subpages defined in the call to @code{plstar} (@pxref{plstar; Initialization}) or @code{plstart} (@pxref{plstart; Initialization}), and
the scale is set to 1.0. Under normal circumstances, it is
recommended that the user does not alter the default height, but
simply use the scale parameter. This can be done by calling @code{plschr} (@pxref{plschr; Set character size})
with @samp{def = 0.0} and @samp{scale} set to
the desired multiple of the default height. If the default height is
to be changed, @samp{def} is set to the new default
height in millimeters, and the new character height is again set to
@samp{def} multiplied by @samp{scale}.

The routine @code{plssym} (@pxref{plssym; Set symbol size}) sets up the size of all subsequent characters drawn
by calls to @code{plpoin} (@pxref{plpoin; Plots a character at the specified points}) and @code{plsym} (@pxref{plsym; Plots a symbol at the specified points}). It operates analogously to
@code{plschr} (@pxref{plschr; Set character size}) as described above.

@node Three Dimensional Surface Plots, Contour and Shade Plots, Setting Character Attributes, Advanced Use of PLplot
@section Three Dimensional Surface Plots

PLplot includes routines that will represent a single-valued function
of two variables as a surface. In this section, we shall assume that
the function to be plotted is @samp{Z[X][Y]}, where
@samp{Z} represents the dependent variable and
@samp{X} and @samp{Y} represent the
independent variables.

As usual, we would like to refer to a three dimensional point
@samp{(X, Y, Z)} in terms of some meaningful
user-specified coordinate system. These are called
@i{three-dimensional world coordinates}. We need to
specify the ranges of these coordinates, so that the entire surface
is contained within the cuboid defined by @samp{xmin < x <
xmax}, @samp{ymin < y < ymax}, and
@samp{zmin < z < zmax}. Typically, we shall want
to view the surface from a variety of angles, and to facilitate this,
a two-stage mapping of the enclosing cuboid is performed. Firstly,
it is mapped into another cuboid called the @i{normalized
box} whose size must also be specified by the user, and
secondly this normalized box is viewed from a particular azimuth and
elevation so that it can be projected onto the two-dimensional
window.

This two-stage transformation process allows considerable flexibility
in specifying how the surface is depicted. The lengths of the sides
of the normalized box are independent of the world coordinate ranges
of each of the variables, making it possible to use
reasonable viewing angles even if the ranges of the
world coordinates on the axes are very different. The size of the
normalized box is determined essentially by the size of the
two-dimensional window into which it is to be mapped. The normalized
box is centered about the origin in the @samp{x} and
@samp{y} directions, but rests on the plane @samp{z =
0}. It is viewed by an observer located at altitude
@samp{alt} and azimuth @samp{az}, where both
angles are measured in degrees. The altitude should be restricted to
the range zero to ninety degrees for proper operation, and represents
the viewing angle above the xy plane. The azimuth is defined so that
when @samp{az = 0}, the observer sees the xz plane face
on, and as the angle is increased, the observer moves clockwise
around the box as viewed from above the xy plane. The azimuth can
take on any value.

The first step in drawing a surface plot is to decide on the size of
the two-dimensional window and the normalized box. For example, we
could choose the normalized box to have sides of length


@example
    basex = 2.0;
    basey = 4.0;
    height = 3.0;
@end example

A reasonable range for the x coordinate of the two-dimensional window
is -2.5 to +2.5, since the length of the diagonal across the base of
the normalized box is
sqrt(2^2+4^2) =
2 sqrt(5), which fits into this coordinate range. A reasonable
range for the y coordinate of the two dimensional window in this case
is -2.5 to +4, as the the projection of the normalized box lies in
this range for the allowed range of viewing angles.

The routine @code{plwind} (@pxref{plwind; Specify world coordinates of viewport boundaries}) or @code{plenv} (@pxref{plenv; Set up standard window and draw box}) is used in the usual way to establish
the size of the two-dimensional window. The routine @code{plw3d} (@pxref{plw3d; Set up window for 3-d plotting}) must
then be called to establish the range of the three dimensional world
coordinates, the size of the normalized box and the viewing angles.
After calling @code{plw3d} (@pxref{plw3d; Set up window for 3-d plotting}), the actual surface is drawn by a call to
@code{plot3d} (@pxref{plot3d; Plot 3-d surface plot}).

For example, if the three-dimensional world-coordinate ranges are
-10.0 <= @samp{x} <= 10.0, -3.0 <=
@samp{y} <= +7.0, and 0.0 <= @samp{z}
<= 8.0, we could use the following statements:


@example
    xmin2d = -2.5;
    xmax2d =  2.5;
    ymin2d = -2.5;
    ymax2d =  4.0;
    plenv(xmin2d, xmax2d, ymin2d, ymax2d, 0, -2);
    basex = 2.0;
    basey = 4.0;
    height = 3.0;
    xmin = -10.0;
    xmax = 10.0;
    ymin = -3.0;
    ymax = 7.0;
    zmin = 0.0;
    zmax = 8.0;
    alt = 45.0;
    az = 30.0;
    side = 1;
    plw3d(basex, basey, height, xmin, xmax, ymin, ymax, zmin, zmax, alt, az);
    plot3d(x, y, z, nx, ny, opt, side);
@end example

The values of the function are stored in a two-dimensional array
@samp{z[][]} where the array element
@samp{z[i][j]} contains the value of the function at the
point x_i, y_j. (The
two-dimensional array @samp{z} is a vectored array
instead of a fixed size array. @samp{z} points to an
array of pointers which each point to a row of the matrix.) Note
that the values of the independent variables
x_i and y_j do not need
to be equally spaced, but they must lie on a rectangular grid. Thus
two further arrays @samp{x[nx]} and
@samp{y[ny]} are required as arguments to @code{plot3d} (@pxref{plot3d; Plot 3-d surface plot}) to
specify the values of the independent variables. The values in the
arrays x and y must be strictly increasing with the index. The
argument @samp{opt} specifies how the surface is
outlined. If @samp{opt = 1}, a line is drawn
representing z as a function of x for each value of y, if
@samp{opt = 2}, a line is drawn representing z as a
function of y for each value of x, and if @samp{opt = 3},
a net of lines is drawn. The first two options may be preferable if
one of the independent variables is to be regarded as a parameter,
whilst the third is better for getting an overall picture of the
surface. If side is equal to one then sides are drawn on the figure
so that the graph doesn't appear to float.

The routine @code{plmesh} (@pxref{plmesh; Plot surface mesh}) is similar to @code{plot3d} (@pxref{plot3d; Plot 3-d surface plot}), except that it is used
for drawing mesh plots. Mesh plots allow you to see both the top and
bottom sides of a surface mesh, while 3D plots allow you to see the
top side only (like looking at a solid object). The side option is
not available with @code{plmesh} (@pxref{plmesh; Plot surface mesh}).

Labeling a three-dimensional or mesh plot is somewhat more
complicated than a two dimensional plot due to the need for skewing
the characters in the label so that they are parallel to the
coordinate axes. The routine @code{ plbox3} (@pxref{plbox3; Draw a box with axes; etc; in 3-d}) thus combines the functions of
box drawing and labeling.

@node Contour and Shade Plots, , Three Dimensional Surface Plots, Advanced Use of PLplot
@section Contour and Shade Plots

Several routines are available in PLplot which perform a contour or
shade plot of data stored in a two-dimensional array. The contourer
uses a contour following algorithm so that it is possible to
use non-continuous line styles. Further, one may specify arbitrary
coordinate mappings from array indices to world coordinates, such as
for contours in a polar coordinate system. In this case it is best
to draw the distinction between a C and Fortran language caller, so
these are handled in turn.

@menu
* Contour Plots from C::
* Shade Plots from C::
* Contour Plots from Fortran::
* Shade Plots from Fortran::
@end menu

@node Contour Plots from C, Shade Plots from C, , Contour and Shade Plots
@subsection Contour Plots from C

@code{plcont} (@pxref{plcont; Contour plot}) is the routine callable from C for plotting contours.
This routine has the form:


@quotation

@t{
@b{plcont}
(@i{z}, @i{nx}, @i{ny}, @i{kx}, @i{lx}, @i{ky}, @i{ly}, @i{clevel}, @i{nlevel}, @i{pltr}, @i{pltr_data});}
@end quotation

where @samp{z} is the two-dimensional array of size
@samp{nx} by @samp{ny} containing samples
of the function to be contoured. (@samp{z} is a
vectored two-dimensional array as described in the previous
section. It is @i{not} a fixed-size
two-dimensional array.) The parameters @samp{kx},
@samp{lx}, @samp{ky} and
@samp{ly} specify the portion of @samp{z}
that is to be considered. The array @samp{clevel} of
length @samp{nlevel} is a list of the desired contour
levels.

The path of each contour is initially computed in terms of the
values of the array indices which range from @samp{0}
to @samp{nx-1} in the first index and from
@samp{0} to @samp{ny-1} in the second
index. Before these can be drawn in the current window (see @ref{Defining the Window,,Defining the Window}.), it is necessary to convert from these array
indices into world coordinates. This is done by passing a pointer
@samp{pltr} to a user-defined transformation function 
to @code{plcont} (@pxref{plcont; Contour plot}). For C use of @code{plcont} (@pxref{plcont; Contour plot}) (and @code{plshade} (@pxref{plshade; Shade individual region on the basis of value}), see next subsection) 
we have included directly in
the PLplot library the following transformation routines:
@code{pltr0} (@pxref{pltr0; Identity transformation for grid to world mapping}) (identity transformation or you can
enter a NULL argument to get the same effect); @code{pltr1} (@pxref{pltr1; Linear interpolation for grid to world mapping using singly dimensioned coord arrays})
(linear interpolation in singly dimensioned coordinate arrays);
and @code{pltr2} (@pxref{pltr2; Linear interpolation for grid to world mapping using doubly dimensioned coord arrays [column dominant; as per normal C 2d arrays]}) (linear interpolation in doubly dimensioned coordinate
arrays). Examples of the use of these transformation 
routines are given in @file{examples/c/x09c.c},
@file{examples/c/x14c.c}, and
@file{examples/c/x16c.c}. These same three examples
also demonstrate a user-defined transformation function 
@samp{mypltr} which is capable of 
arbitrary translation, rotation, and/or shear. By defining other
transformation subroutines, it is possible to draw contours wrapped
around polar grids etc.

@node Shade Plots from C, Contour Plots from Fortran, Contour Plots from C, Contour and Shade Plots
@subsection Shade Plots from C

NEEDS DOCUMENTATION

@node Contour Plots from Fortran, Shade Plots from Fortran, Shade Plots from C, Contour and Shade Plots
@subsection Contour Plots from Fortran

The routines mentioned above are not recommended for use directly
from Fortran due to the need to pass a function pointer. That is,
the transformation function is written in C and can not generally
be changed by the user. The call for routine @code{plcontfortran} (@pxref{plcont; Contour plot; fixed linear mapping for fortran}) from
Fortran is then:


@quotation

@t{
call @b{plcont}
(@i{z}, @i{nx}, @i{ny}, @i{kx}, @i{lx}, @i{ky}, @i{ly}, @i{clevel}, @i{nlevel});}
@end quotation

When called from Fortran, this routine has the same effect as when invoked
from C. The interpretation of all parameters (see @code{plcont} (@pxref{plcont; Contour plot})) is also the
same except there is no transformation function supplied as the last
parameter. Instead, a 6-element array specifying coefficients to use in the
transformation is supplied via the named common block
@samp{plplot} (see code). Since this approach is somewhat
inflexible, the user is recommended to call either of @code{plcon0} (@pxref{plcon0; Contour plot; identity mapping for fortran}), @code{plcon1} (@pxref{plcon1; Contour plot; general 1-d mapping for fortran}), or
@code{plcon2} (@pxref{plcon2; Contour plot; general 2-d mapping for fortran}) instead.

The three routines recommended for use from Fortran are @code{plcon0} (@pxref{plcon0; Contour plot; identity mapping for fortran}),
@code{plcon1} (@pxref{plcon1; Contour plot; general 1-d mapping for fortran}), and @code{plcon2} (@pxref{plcon2; Contour plot; general 2-d mapping for fortran}). These routines are similar to existing
commercial plot package contour plotters in that they offer
successively higher complexity, with @code{plcon0} (@pxref{plcon0; Contour plot; identity mapping for fortran}) utilizing no
transformation arrays, while those used by @code{plcon1} (@pxref{plcon1; Contour plot; general 1-d mapping for fortran}) and @code{plcon2} (@pxref{plcon2; Contour plot; general 2-d mapping for fortran})
are one and two dimensional, respectively. The call syntax for
each is


@quotation

@t{
call @b{plcon0}
(@i{z}, @i{nx}, @i{ny}, @i{kx}, @i{lx}, @i{ky}, @i{ly}, @i{clevel}, @i{nlevel});}
@end quotation

@quotation

@t{
call @b{plcon1}
(@i{z}, @i{nx}, @i{ny}, @i{kx}, @i{lx}, @i{ky}, @i{ly}, @i{clevel}, @i{nlevel}, @i{xg1}, @i{yg1});}
@end quotation

@quotation

@t{
call @b{plcon2}
(@i{z}, @i{nx}, @i{ny}, @i{kx}, @i{lx}, @i{ky}, @i{ly}, @i{clevel}, @i{nlevel}, @i{xg2}, @i{yg2});}
@end quotation

The @code{plcon0} (@pxref{plcon0; Contour plot; identity mapping for fortran}) routine is implemented via a call to @code{plcont} (@pxref{plcont; Contour plot}) with a
very simple (identity) transformation function, while @code{plcon1} (@pxref{plcon1; Contour plot; general 1-d mapping for fortran}) and
@code{plcon2} (@pxref{plcon2; Contour plot; general 2-d mapping for fortran}) use interpolating transformation functions as well as
a call to
@code{plcont} (@pxref{plcont; Contour plot}).

The transformation arrays are used by these routines to specify a
mapping between the computational coordinate system and the
physical one. For example, the transformation to polar coordinates
might look like:


@example
    do i = 1, NX
        do j = 1, NY
            xg(i, j) = r(i) * cos( theta(j) )
            yg(i, j) = r(i) * sin( theta(j) )
        enddo
    enddo
@end example

assuming the user had already set up arrays @samp{r}
and @samp{theta} to specify the (r, theta) values at
the gridpoints in his system. For this example, it is recommended
that the user add an additional cell in theta such that
@samp{xg(i, NY+1) = xg(i, 1)} and @samp{yg(i, NY+1)
= yg(i, 1)} so that the contours show the proper periodic
behavior in theta (see also example program 9).

The transformation function not only specifies the transformation
at grid points, but also at intermediate locations, via linear
interpolation. For example, in the @samp{pltr1}
transformation function used by @code{plcon1} (@pxref{plcon1; Contour plot; general 1-d mapping for fortran}), the 1-d interpolation to
get @samp{tx} as a function of @samp{x}
looks like (in C):


@example
    ul = (PLINT)x;
    ur = ul + 1;
    du = x - ul;

    xl = *(xg+ul);
    xr = *(xg+ur);

    *tx = xl * (1-du)  +  xr * du;
@end example

while in Fortran this might look like:


@example
    lxl = x
    lxr = lxl + 1
    dx = x - lxl

    xl = xg(lxl)
    xr = xg(lxr)

    tx = xl * (1-dx)  +  xr * dx
@end example

@node Shade Plots from Fortran, , Contour Plots from Fortran, Contour and Shade Plots
@subsection Shade Plots from Fortran

NEEDS DOCUMENTATION

@node Deploying programs that use PLplot, The PLplot Display Driver Family, Advanced Use of PLplot, Top
@chapter Deploying programs that use PLplot

This chapter provides some information on the issue of
delivering programs that use PLplot: what files should be installed and
where, what environment variables are involved and related matters.

The scenario is this: You have created one or more programs that run
successfully on your development machine and now you need to install
them on the machine of a user.

One solution is to provide him or her with the full development
environment that you use, but that is in general only an option if your
user is comfortable with making programs themselves. A more common
situation is that your user just wants the executable programs and
wants to get using them rightaway. We will focus on this particular
solution, as there are a few non-trivial issues.

To be absolutely clear about what we are describing, here is a summary:

@itemize @bullet{}

@item
Your program must run on a machine that does not have PLplot
installed from the sources.

@item
There is no development environment that you can rely on.

@item
The program should be installed in a self-contained directory
structure (which @i{can} be
@file{/usr/local} or @file{c:\program}
files or whatever, but need not be so).
@end itemize

Under Linux, the easiest way to install a binary version of PLplot on a
user's machine is to use PLplot deb binary packages for the @uref{http://www.debian.org,Debian} distribution, and PLplot rpm
binary packages for rpm-based distributions. (See the @uref{http://plplot.sourceforge.net/resources/index.html,Resources  area} of the PLplot web site for locations of debs and rpms.)
Build the application on the build machine using the results of the
@samp{plplot-config --cflags --libs} command, and copy
the resulting executable(s) to the users' machines.

Under Unix (and also under Linux if you would prefer to use a newer
version of PLplot than is available in the debs or rpms), a good way
to deploy binary PLplot and applications that depend on that binary PLplot
on users' machines is as follows:

@itemize @bullet{}

@item
Use the @code{./configure} option
@samp{--prefix=/usr/local/plplot} (or some other
unique but consistent directory that is available on the build
machine and all users' machines).

@item
Build and install as normal on the build machine.

@item
Copy the installed PLplot tree,
@file{/usr/local/plplot}, into a tarball.

@item
Unpack that tarball on all users' machines in the same location
@file{/usr/local/plplot}.

@item
Build the application(s) on the build machine using the results
of the @samp{plplot-config --cflags --libs}
command, and copy the resulting executable(s) to the users'
machines. Since the PLplot install location is consistent on all
machines, the application should work the same way on all
machines.
@end itemize

On Windows, and also those rare Linux/Unix cases where you cannot install
the PLplot install tree in a consistent location on users' machines, then
there are some additional options you need to consider.

There are three situations depending on how you configure and
build the PLplot libraries:

@enumerate 

@item
You use the static versions of the PLplot libraries and devices
which are not dynamically loaded.
@footnote{
UNIX-like systems libraries can be static or shared, the first
type becoming part of the program, the second existing as a
separate file. On Windows the terms are respectively static
and dynamic (the latter type is also known as DLL).
}

@item
You use the shared versions of the PLplot libraries and devices
which are not dynamically loaded.

@item
You use the shared versions of the PLplot library and devices
which are dynamically loaded. This combination is the default
option under Unix/Linux.
@end enumerate

In the @i{first} case the program will contain all the
code it needs to work, but to run successfully, it needs to find the
font files, @file{plstnd5.fnt} and
@file{plxtnd5.fnt}. The mechanism used in PLplot to find
these files is fairly simple:

@itemize @bullet{}

@item
It looks at a number of built-in places, determined at the time
the PLplot library itself was installed and built. For deployment
these places are irrelevant in general.

@item
It looks at the environment variables
@code{PLPLOT_LIB} and @code{PLPLOT_HOME}.
(Actually, this happens only, if the corresponding compiler
macros @code{PLPLOT_LIB_ENV} and
@code{PLPLOT_HOME_ENV} were defined at compile time.)

@item
@i{(TODO: remark about Mac)}
@end itemize

Note: This is also the place to put the geographical map files, if you
happen to use them.

The environment variables should point to the directory holding the two
font files or the one above (one variable is enough though):

@itemize @bullet{}

@item
@code{PLPLOT_LIB} should point to the directory
actually holding these files

@item
@code{PLPLOT_HOME} should point to the directory that
holds a subdirectory @file{lib}
which in turn holds these files.
@end itemize

If it can find these, PLplot can do its job.

Note: This is the case for instance when you use the static PLplot
library on Windows (see the directory
@file{sys\win32\msdev\plplib}).

In the @i{second } case the font and map files are found
as in the @i{first} case. In addition, you also
require another environment variable so the PLplot shared libraries can
be found at run time by the run-time loader. The details depend on the
system you are working on, but here are some common platforms:

@itemize @bullet{}

@item
Most UNIX, BSD and Linux systems use an environment variable
@code{LD_LIBRARY_PATH} which indicates 
directories where shared libraries can be found. Some use
@code{SHLIB_PATH}, like HPUX.

@item
On Windows the PATH variable is used to find the DLLs, but
beware: Windows uses a number of places to find the DLLs a
program needs and the ordering seems to depend on some intricate
details. It seems easiest and safest to put the DLLs in the same
directory as your program.

@item
On MacOSX, ... @i{TODO}
@end itemize

In the @i{third} (default) case, the PLplot fonts and
maps are found as in the @i{first} case, and the 
shared libraries are found as in the @i{second} case,
but in addition the separated dynamic devices have to be found as well.

When PLplot uses dynamic devices, it first builds up a list of them, by
examining a directory which contains files describing those devices:
the @file{*.rc} files. Each of these files indicates what
the relevant properties for the device or devices. Then when the
device is actually needed, the corresponding shared object (or plug-in
or DLL depending on your terminology) is dynamically loaded.

The directory that contains all these files (the device descriptions as
well as the actual libraries and the description files that libtool
uses) is a directory determined at the time you configured
PLplot which is typically something like
@file{/usr/local/plplot/lib/plplot5.3.1/driversd}. This
directory must be pointed to by the @code{PLPLOT_DRV_DIR}
environment variable. Again for deployment, only the environment
variable is of real interest.

To summarise the case where you don't have a deb or rpm option, and
you must use inconsistent install locations on your users' machines:

@itemize @bullet{}

@item
The following environment variables are important:

@itemize @bullet{}

@item
@code{PLPLOT_HOME} or
@code{PLPLOT_LIB} to indicate the position of
font files (and also of the various geographic maps)

@item
@code{LD_LIBRARY_PATH},
@code{SHLIB_PATH} or @code{PATH} to
find the dynamic/shared libraries

@item
@code{PLPLOT_DRV_DIR} to find the device
descriptions
@end itemize

@item
The following files being part of PLplot must be distributed
along with your program:

@itemize @bullet{}

@item
The font files (@file{plstnd5.fnt} and
@file{plxtnd5.fnt}) and, possibly, if you use
them, the geographic map files.

@item
The PLplot shared libraries

@item
The device description files and the device shared object files
@end itemize
@end itemize

All the environment variables, except
@code{LD_LIBRARY_PATH} and equivalents, can be set within
the program (by using a small configuration file or by determining the
position of the files relative to the program's location). They just
have be set before PLplot is initialised.

@node The PLplot Display Driver Family, The PLplot Output Driver Family, Deploying programs that use PLplot, Top
@chapter The PLplot Display Driver Family

Drivers that provide screen displays are described in this chapter. 
Each of the drivers has a list of options, and these may be set as 
outlined in @ref{Command Line Arguments,,Command Line Arguments}..

@menu
* The Xwin Driver [X-Windows]::
* The GCW Driver [Gnome 2]::
* The Tk Driver::
* The AquaTerm Driver [Mac OS X]::
@end menu

@node The Xwin Driver [X-Windows], The GCW Driver [Gnome 2], , The PLplot Display Driver Family
@section The Xwin Driver (X-Windows)

The Xwin driver draws plots in an X-window. Although some of the
newer features are not supported, it remains the reference driver
for PLplot.

Plots are displayed one page at a time. The pager is advanced by 
pressing the Enter key, and may only be advanced in the foreward
direction.

Anti-aliasing is not supported, and the Xwin driver is not 
unicode-enabled.

The available driver options are:

@itemize @bullet{}

@item
sync: Synchronized X server operation (0|1)

@item
nobuffered: Sets unbuffered operation (0|1)

@item
noinitcolors: Sets cmap0 allocation (0|1)

@item
defvis: Use the Default Visual (0|1)

@item
usepth: Use pthreads (0|1)
@end itemize

@node The GCW Driver [Gnome 2], The Tk Driver, The Xwin Driver [X-Windows], The PLplot Display Driver Family
@section The GCW Driver (Gnome 2)

The GCW driver draws plots into a tabbed Gnome window. The driver's
features and user interface are described in 
@ref{GCW Driver Basics,,GCW Driver Basics}.. A specialized API allows 
interaction with the driver, and this is described in 
@ref{GCW Driver API,,GCW Driver API}..

@menu
* GCW Driver Basics::
* GCW Driver API::
@end menu

@node GCW Driver Basics, GCW Driver API, , The GCW Driver [Gnome 2]
@subsection GCW Driver Basics

The GCW driver plots each page into an individual tab within
a Gnome window. The user interface built into the window allows 
a variety of actions. In particular, pages can be saved to files
with extensions .ps, .psc, .png, .jpg, and .gif, which correspond 
to PLplot output driver devices described in 
@ref{The PLplot Output Driver Family,,The PLplot Output Driver Family}..

The GCW driver supports anti-aliasing and is unicode enabled.

There are a variety of hot keys that may be used in the user interface:

@itemize @bullet{}

@item
Arrows : Change page

@item
+ : Zooms in

@item
- : Zooms out

@item
= : Zooms to 100%

@item
q : Quits
@end itemize

The available driver options (used with the
@code{-drvopt} command-line argument) are:

@itemize @bullet{}

@item
text: Use TrueType fonts (0|1); default 1

@item
pixmap: Use pixmap for plotting lines and shades (0|1); 
default 1

@item
hrshsym: Use Hershey symbol set (0|1); default 0
@end itemize

The @code{text} option toggles between TrueType and
Hershey fonts. The Hershey fonts provide a reference implementation
for text representation in PLplot.

The @code{hrshsym} option is used to indicate that
symbols should be drawn using the Hershey fonts. This is
useful when plots need to be saved to PostScript files, because
the Type I fonts used by the PS and PSC devices do not support all
Unicode symbols.

Most of the command-line arguments described in
@ref{Command Line Arguments,,Command Line Arguments}. are also supported. Some key arguments
for use with the GCW driver are:

@itemize @bullet{}

@item
geometry geom: Sets page size, in pixels (e.g. -geometry 400x300)

@item
nopixmap: Disables pixmap usage for plotting lines and shades

@item
portrait: Sets portrait mode (both orientation and aspect ratio)
@end itemize

The @code{nopixmap} option disables the use of
the internal pixmap for drawing lines and shades, which will 
normally appear somewhat pixelated. The 
@code{nopixmap} option directs the driver to use 
anti-aliased vector graphics instead, resulting in higher quality
plots but rendered at a slower speed. This option does not affect 
the quality of plots saved from the GCW user interface. Note that
the TrueType fonts are always anti-aliased.

@node GCW Driver API, , GCW Driver Basics, The GCW Driver [Gnome 2]
@subsection GCW Driver API

The GCW driver provides an additional API that allows for a higher
degree of control by the user. The C API is described below, and
bindings to other languages are described in
*** NEEDS DOCUMENTATION ***.

The function prototypes are defined in @file{gcw.h}.
Programs that need access to this API must be linked against the 
libplplotgnome2d library rather than libplplotd. This is most easily 
accomplished using pkg-config; i.e.,

@example

        gcc x01c.c -o x01c `pkg-config --cflags --libs plplotd-gnome2`
      
@end example

@noindent
You may need to remind pkg-config where to look for the 
plplotd-gnome2 file installed by PLplot; e.g.,

@example

        gcc x01c.c -o x01c `PKG_CONFIG_PATH=/usr/local/lib/pkgconfig pkg-config --cflags --libs plplotd-gnome2`
      
@end example

@menu
* gcw_use_text; Sets font usage_::
* gcw_use_pixmapSets pixmap usage_::
@end menu

@node gcw_use_text; Sets font usage_, gcw_use_pixmapSets pixmap usage_, , GCW Driver API
@subsubsection gcw_use_text: Sets font usage.


@quotation

@t{@b{void gcw_use_text}(@i{use_text});}
@end quotation

Sets whether TrueType text or Hershey fonts are used.

@table @asis

@item   @code{use_text} (@samp{PLINT}, input)  
1 for TrueType fonts (default), 0 for Hershey fonts.
@end table

@node gcw_use_pixmapSets pixmap usage_, , gcw_use_text; Sets font usage_, GCW Driver API
@subsubsection gcw_use_pixmapSets pixmap usage.


@quotation

@t{@b{void gcw_use_pixmap}(@i{use_pixmap});}
@end quotation

Sets whether lines and shades are drawn to a pixmap,
or instead as vector graphics.

Lines and shade drawn to the pixmap may appear pixelated.
Vector graphics are fully anti-aliased, but are rendered at a 
slower speed.

@table @asis

@item   @code{use_pixmap}   (@samp{PLINT}, input)  
1 to use pixmap (default), 0 for vector graphics instead.
@end table

@node The Tk Driver, The AquaTerm Driver [Mac OS X], The GCW Driver [Gnome 2], The PLplot Display Driver Family
@section The Tk Driver

is the prototype of a whole new interaction paradigm. See next
chapter.

@node The AquaTerm Driver [Mac OS X], , The Tk Driver, The PLplot Display Driver Family
@section The AquaTerm Driver (Mac OS X)

The AquaTerm driver is a Mac OS X specific driver that is used with 
the AquaTerm Graphics Terminal. It is unicode enabled. Text, lines
and shades are anti-aliased.

There are no options...

@node The PLplot Output Driver Family, C Language, The PLplot Display Driver Family, Top
@chapter The PLplot Output Driver Family

Drivers which produce output files are described in this chapter. 
Each of the drivers has a list of options, and these may be set as 
outlined in @ref{Command Line Arguments,,Command Line Arguments}..

@menu
* The Postscript Driver::
* The GD Driver::
@end menu

@node The Postscript Driver, The GD Driver, , The PLplot Output Driver Family
@section The Postscript Driver

The Postscript driver produces publication-quality postscript
output. The driver provides two devices: the ps device for 
black-and-white plots, and the psc device for color plots.

This driver is unicode enabled, and PostScript Type I fonts are used.
Type I fonts do not have all of the available unicode symbols
represented. For this reason, Hershey fonts are used for drawing 
symbols by default, unless specified otherwise using the driver options.

The available driver options are:

@itemize @bullet{}

@item
text: Use Postscript text (0|1); default 1

@item
hrshsym: Use Hershey fonts for symbols (0|1); default 1
@end itemize

@node The GD Driver, , The Postscript Driver, The PLplot Output Driver Family
@section The GD Driver

The GD driver produces png, jpeg, and gif images, using devices by 
the same name. The GD driver is unicode enabled. Text is 
anti-aliased, but lines and shades are not.

The available driver options are:

@itemize @bullet{}

@item
optimise: Optimise PNG palette when possible

@item
def_black15: Define idx 15 as black. If the background is 
"whiteish" (from "-bg" option), force index 15 (traditionally 
white) to be "black"

@item
swp_red15: Swap index 1 (usually red) and 1 (usually white); 
always done after "black15"; quite useful for quick changes to
web pages

@item
8bit: Palette (8 bit) mode

@item
24bit: Truecolor (24 bit) mode

@item
text: Use driver text (FreeType)

@item
smooth: Turn text smoothing on (1) or off (0)
@end itemize

@node C Language, Fortran Language, The PLplot Output Driver Family, Top
@chapter C Language

(OLD, NEEDS DOCUMENTATION UPDATING)
The argument types given in this manual (PLFLT and PLINT) are typedefs for
the actual argument type. A PLINT is actually a type
@samp{long} and should not be changed. A PLFLT can be either a
@samp{float} or @samp{double}; this choice is made
when the package is installed and on a Unix system (for example) may result
in a PLplot library named @file{libplplot.a} in single
precision and @file{libplplotd.a} in double precision.

These and other constants used by PLplot are defined in the main header file
@file{plplot.h}, which must be included by the user program. This file also
contains all of the function prototypes, machine dependent defines, and
redefinition of the C-language bindings that conflict with the Fortran names
(more on this later). @file{plplot.h} obtains its values for PLFLT, PLINT,
and PLARGS (a macro for conditionally generating prototype argument lists)
from FLOAT (typedef), INT (typedef), and PROTO (macro), respectively.
The latter are defined in the file
@file{chdr.h}. The user is encouraged to use FLOAT, INT, and PROTO in
his/her own code, and modify @file{chdr.h} according to taste. It is not
actually necessary to declare variables as FLOAT and INT except when they
are pointers, as automatic conversion to the right type will otherwise occur
(if using a Standard C compiler; else K&R style automatic promotion will
occur). The only code in @file{plplot.h} that directly depends on these
settings is as follows:

@example

#include "plplot/chdr.h"

/* change from chdr.h conventions to plplot ones */

typedef FLOAT PLFLT;
typedef INT   PLINT;
#define PLARGS(a) PROTO(a)
@end example

PLplot is capable of being compiled with Standard C (ANSI) mode on or off.
This is toggled via the macro PLSTDC, and set automatically if __STDC__
is defined. If PLSTDC is defined, all functions are prototyped as allowed
under Standard C, and arguments passed exactly as specified in the
prototype. If PLSTDC is not defined, however, function prototypes are
turned off and K&R automatic argument promotion will occur, e.g.
@samp{ float &rarr; double, int &rarr; long}.
There is no middle ground! A PLplot
library built with PLSTDC defined will not work (in general) with a program
built with PLSTDC undefined, and vice versa. It is possible in principle to
build a library that will work under both Standard C and K&R compilers
simultaneously (i.e. by duplicating the K&R promotion with the Standard C
prototype), but this seems to violate the spirit of the C standard and can
be confusing. Eventually we will drop support for non-standard C compilers
but for now have adopted this compromise.

In summary, PLplot will work using either a Standard or non-standard C
compiler, provided that you :

@itemize @bullet{}

@item
Include the PLplot main header file @file{plplot.h}.

@item
Make sure all pointer arguments are of the correct type
(the compiler should warn you if you forget, so don't worry, be happy).

@item
Do not link a code compiled with PLSTDC defined to a PLplot library
compiled with PLSTDC undefined, or vice versa.

@item
Use prototypes whenever possible to reduce type errors.
@end itemize

Note that some Standard C compilers will give warnings when converting a
constant function argument to whatever is required by the prototype. These
warnings can be ignored.

The one additional complicating factor concerns the use of stub routines to
interface with Fortran (see the following section for more explanation). On
some systems, the Fortran and C namespaces are set up to clobber each other.
More reasonable (from our viewpoint) is to agree on a standard map between
namespaces, such as the appending of an underscore to Fortran routine names
as is common on many Unix-like systems. The only case where the shared
Fortran/C namespaces do any good is when passing a pointer to a like data
type, which represents only a small fraction of the cases that need to
be handled (which includes constant values passed on the stack, strings, and
two-dimensional arrays).

There are several ways to deal with this situation, but the least messy from
a user's perspective is to redefine those PLplot C function names which
conflict with the Fortran-interface stub routines. The actual function
names are the same as those described in this document, but with a
c_
prepended. These macro definitions appear in the
@file{plplot.h} header file
and are otherwise harmless. Therefore you can (and should) forget that most
of the names are being redefined to avoid the conflict and simply adhere to
the bindings as described in this manual. Codes written under old versions
of PLplot (previous to 5.0) will require a recompile, however.

For more information on calling PLplot from C, please see the example C
programs (@file{x01c.c} through @file{x19c.c})
distributed with PLplot.

@node Fortran Language, A C++ Interface for PLplot, C Language, Top
@chapter Fortran Language

As discussed in the preceding section, PLplot's integer representation is a
PLINT and its floating point representation is a PLFLT. To the
Fortran user, this most commonly translates to a type
@samp{integer} and
type @samp{real}, respectively. This is somewhat system dependent (and up to
the installer of the package) so you should check the release notes to be
sure, or just try it and see what happens.

Because the PLplot kernel is written in C, standard C syntax is used in the
description of each PLplot function. Thus to understand this manual it is
helpful to know a little about C, but fortunately the translation is very
easy and can be summarized here. As an example, the routine 
@code{plline} (@pxref{plline; Draw a line}) call from C would look like:

@example

	plline(n,x,y);
@end example

@noindent
while from Fortran it would look like:

@example

	call plline(n,x,y)
@end example

@noindent
typically with @samp{n} declared as type
@samp{integer} and @samp{x}, @samp{y}
declared as type @samp{real} (arrays in this case). 
Each C language type
used in the text translates roughly as follows:

@multitable @columnfractions 0.5 0.5
@item
PLFLT@tab real
@item
PLINT@tab integer
@item
char *@tab character
@item
PLFLT *@tab real or real array
@item
PLFLT **@tab real array
@item
@samp{"string"}@tab @samp{'string'}
@item
array[0]@tab array(1)
@end multitable

@noindent
In C there are two ways to pass a variable --- by value (the default) or by
reference (pointer), whereas only the latter is used by Fortran.
Therefore when you see references in the text to @i{either} an ordinary
argument or a pointer argument (e.g. @samp{*data}), you simply use an
ordinary Fortran variable or array name.

The PLplot library comes with a set of Fortran interface routines that
allow the exact same call syntax (usually) regardless of whether calling
from C or Fortran. In some cases, this means the subroutine name @i{
exceeds 8 characters in length}. Nearly every Fortran compiler
available
today allows subroutine names longer than 8 characters, so this should not
be a problem (although if it ever is, in principle a truncated name could
be defined for that platform).

These stub routines handle transforming the data
from the normal Fortran representation to that typically used in C. This
includes:

@itemize @bullet{}

@item
Variables passed by value instead of by reference.

Fortran passes all subroutine arguments by reference, i.e., a pointer to the
argument value is pushed on the stack. In C all values, except for arrays
(including char arrays), are passed by value, i.e., the argument value
itself is pushed on the stack. The stub routine converts the Fortran call
by reference to a call by value. As an example, here is how the plpoin stub
routine works. In your Fortran program you might have a call to plpoin that
looks something like

@example

      call plpoin(6,x,y,9)
@end example

@noindent
where x and y are arrays with 6 elements and you want to plot symbol 9.
As strange as it seems (at least to C programmers) the constants 6 and
9 are passed by reference. This will actually call the following C
stub routine (included in entirety)

@example

#include "plplot/plstubs.h"

void 
PLPOIN(n, x, y, code)
PLINT *n, *code;
PLFLT *x, *y;
@{
    c_plpoin(*n, x, y, *code);
@}
@end example

@noindent
All this stub routine does is convert the number of points
(@samp{*n} and the
symbol @samp{*code} to call by value (i.e. pushes their value on the stack)
and then calls the C plpoin library routine.

@item
Get mapping between Fortran and C namespace right (system dependent).

The external symbols (i.e. function and subroutine names) as you see them
in your program often appear differently to the linker. For example, the
Fortran routine names may be converted to uppercase or lowercase, and/or
have an underscore appended or prepended. This translation is handled
entirely via redefinition of the stub routine names, which are macros.
There are several options for compiling PLplot that simplify getting the
name translation right (NEEDS DOCUMENTATION IF THESE STILL EXIST). In any
case, once the name translation is established during installation, name
translation is completely transparent to the user.

@item
Translation of character string format from Fortran to C.

Fortran character strings are passed differently than other quantities, in
that a string descriptor is pushed on the stack along with the string
address. C doesn't want the descriptor, it wants a NULL terminated string.
For routines that handle strings two stub routines are necessary, one
written in Fortran and one written in C. Your Fortran program calls the
Fortran stub routine first. This stub converts the character string to a
null terminated integer array and then calls the C stub routine. The C
stub routine converts the integer array (type @samp{long}) to the usual C
string representation (which may be different, depending on whether your
machine uses a big endian or little endian byte ordering; in any case the
way it is done in PLplot is portable). See the @samp{plmtex} stubs for an
example of this. 

Note that the portion of a Fortran character string that exceeds 299
characters will not be plotted by the text routines (@samp{plmtex}
and @samp{plptex}). 

@item
Multidimensional array arguments are changed from row-dominant to
column-dominant ordering through use of a temporary array.

In Fortran, arrays are always stored so that the first index increases most
rapidly as one steps through memory. This is called
row-dominant
storage. In C, on the other hand, the first index increases 
@i{least}
rapidly, i.e. column-dominant ordering. Thus, two dimensional arrays
(e.g. as passed to the contour or surface plotting routines) passed into
PLplot must be transposed in order to get the proper two-dimensional
relationship to the world coordinates. This is handled in the C stub
routines by dynamic memory allocation of a temporary array. This is then set
equal to the transpose of the passed in array and passed to the appropriate
PLplot routine. The overhead associated with this is normally not important
but could be a factor if you are using very large 2d arrays.
@end itemize

This all seems a little messy, but is very user friendly. Fortran and C
programmers can use the same basic interface to the library, which is a
powerful plus for this method. The fact that stub routines are being used
is completely transparent to the Fortran programmer.

For more information on calling PLplot from Fortran, please see the
example Fortran programs (@file{x01f.f} through
@file{x16f.f}) distributed
with PLplot.

@node A C++ Interface for PLplot, Using PLplot from Tcl, Fortran Language, Top
@chapter A C++ Interface for PLplot

PLplot has long had C and Fortran bindings, presenting a fairly
conventional API to the applications programmer. Recently (1994
onwards) PLplot has been growing interfaces (language bindings) to a
variety of other languages. In this chapter we discuss the PLplot C++
support provided in the PLplot distribution. Of course many other
approaches are possible, perhaps even in use by PLplot users around
the world. The purpose of this chapter then is to explain the
rationale and intended usage for the bundled C++ language support.

@menu
* Motivation for the C++ Interface::
* Design of the PLplot C++ Interface::
* Specializing the PLplot C++ Interface::
* Status of the C++ Interface::
@end menu

@node Motivation for the C++ Interface, Design of the PLplot C++ Interface, , A C++ Interface for PLplot
@section Motivation for the C++ Interface

PLplot has a fairly complex C API. There are lots of functions, and
several facilities have multiple entry points with similar names but
different argument lists. (Think contouring, shading). Often these
differing argument lists are to accommodate a variety of data storage
paradigms, one of which you are expected to be using!

Especially in the case of the 2-d API's for contouring and shading,
sophisticated C++ users may feel a special sense of exasperation with
the data layout prescriptions, since they are extremely primitive,
pointer rich, and prone to a wide class of memory leaks and other
sorts of programming errors. Many C++ users know good and well that
better ways exist (templated matrix classes, etc), but historically
have not been able to use these more sophisticated techniques if the
contained data ever needed to get plotted.

Besides the 2-d API functions, there is also the multiple output
stream capability of PLplot. Anyone who knows C++ well, and who has
used multiple output streams in PLplot, has probably noticed striking
similarities between the PLplot @samp{PLStream} pointer and the C++ 
@samp{this} pointer. Although multiple output streams have not been 
widely used in PLplot applications in the past, the availability of
the plframe Tk widget, and the extended wish concept, is making it
much more attractive to use multiple output streams.

Unfortunately, if you do write a Tk extended wish application, and
endow your interface with multiple plframes, the event driven
character of X applications makes it difficult to ensure that PLplot
output shows up in the right plframe window. If a plot is generated
to one plframe, the PLplot @samp{PLStream} pointer is directed to that
stream. If a user then pushes a Tk button which should generate a
plot to a different plframe, the plot goes to the old plframe instead!
Schemes for controlling this can be imagined, but the logic can be
complex, especially in the face of the ability to /also/ make plots to
the same plframe from either Tcl or C++.

Beyond this, the C API is downright "ugly" for a significant number of
the functions, particularly those which return values by accepting
pointers to variables in their argument lists, and then changing them
in that way. Sophisticated C++ users generally take considerable
pride in banishing the offensive bare pointer from their code, and
consider it disgusting to have to insert &'s just in order to make a
call to an API function.

In order to address these issues (and more), I have begun constructing
a C++ interface to PLplot. The purpose of this missive is to describe
its architecture and usage.

@node Design of the PLplot C++ Interface, Specializing the PLplot C++ Interface, Motivation for the C++ Interface, A C++ Interface for PLplot
@section Design of the PLplot C++ Interface

@menu
* Stream/Object Identity::
* Namespace Management::
* Abstraction of Data Layout::
* Collapsing the API::
@end menu

@node Stream/Object Identity, Namespace Management, , Design of the PLplot C++ Interface
@subsection Stream/Object Identity

A C++ class named @samp{plstream} has been introduced. It's central
purpose is provide a specific, object based encapsulation of the
concept of a PLplot output stream. Any output produced using a
@samp{plstream} object, will go to the PLplot output stream associated with
that object, regardless of what stream may have been active before. 

In order to write a multiple output stream PLplot application, a C++
program can declare @samp{plstream} objects, and invoke drawing methods on
those objects, without regard to ordering considerations or other
coherency considerations. Although this has obvious simplification
benefit even for simple programs, the full benefit is most easily
appreciated in the context of Tk extended wish applications in which a
@samp{plstream} can be associated with each plframe.

@node Namespace Management, Abstraction of Data Layout, Stream/Object Identity, Design of the PLplot C++ Interface
@subsection Namespace Management

The PLplot C API is composed of a set of drawing functions, all
prefixed with "pl", in an effort to prevent namespace collision.
However, the prefix "pl" is gratuitous, and in particular is
unnecessary in a C++ context. The @samp{plstream} class mirrors most
of the PLplot C API, but does so by dropping the "pl" prefix. The
@samp{plstream} class thus serves to collect the PLplot drawing
functions into a scope in which collisions with other similarly named
functions is not a concern. So, where a C programmer might write:

@example

        plsstrm( 1 );
	plenv( ... );
	plline( ... );
@end example

The C++ programmer can write:

@example

	plstream p( ... );
	p.env( ... );
	p.line( ... );
@end example

Is that an important benefit? The utility varies with the number of
output streams in use in the program.

plmkstrm() is replaced by object declaration. plsstrm() is replaced by
method invocation on the desired output stream object. plgstrm() is
rendered irrelevant.

The skeptic may say, "But you have to type the same number of
characters! You've replaced 'pl' with 'p.', except it could be worse
for a longer object name." True. BUT, in this new scheme, most plots
will not be generated by invoking methods on a specific stream object,
but rather by deriving from @samp{plstream}, and invoking methods of
"this" object. See the section on derivation below.

@node Abstraction of Data Layout, Collapsing the API, Namespace Management, Design of the PLplot C++ Interface
@subsection Abstraction of Data Layout

The @samp{plstream} class will provide an abstract interface to the
2-d drawing functions. Instead of forcing the C++ user to organize
data in one of a small set of generally braindead data layouts with
poor memory management properties, potentially forcing the C++ user to
not use a superior method, or to copy data computed in one layout
format to another for plotting (with consequent bug production), the
@samp{plstream} 2-d plotting functions will accept an abstract layout
specification. The only thing which is important to the 2-d drawing
functions is that the data be "indexable". They should not care about
data layout.

Consequently, an abstract class, "Contourable_Data" is provided. This
class provides a pure virtual method which accepts indexes, and is to
be made to produce a function value for the user's 2-d data field. It
is of no concern to PLplot how the user does this. Any mapping
between index and data which the user wishes to use, may be used.

This methodology allows the C++ user to compute data using whatever
storage mechanism he wants. Then, by deriving a class from PLplot's
Contourable_Data abstract class, he can provide a mapping to his own
data layout.

Note that this does /not/ mean that the C++ user's internal data
layout must be derived from PLplot's Contourable_Data class. Suppose
for example that the user data is stored in a C++ "matrix" class.
To make this data contourable, the user may define a class which
specializes the indexing concept of the PLplot Contourable_Data class
to his matrix class. For example:

@example

class Matrix @{ ... @};
class Contourable_Matrix : public Contourable_Data @{
    Matrix& m;
  public:
    Contourable_Matrix( Matrix& _m ) : m(_m) @{@}
    PLFLT  operator()( int i, int j ) const @{ return m(i,j); @}
@};

plstream p( ... );
Matrix m;
// Code to fill m with data
Contourable_Matrix cm(m);
p.shade( cm, ... );
@end example

In this way the C++ user is completely freed from the tyranny of
moronic data layout constraints imposed by PLplot's C or Fortran API.

@node Collapsing the API, , Abstraction of Data Layout, Design of the PLplot C++ Interface
@subsection Collapsing the API

Use of abstraction as in C) above will allow a single method in
@samp{plstream} to perform the services of multiple functions in the C API.
In those cases where multiple functions were provided with different
data layout specifications, but similar functionality, these can all
be collapsed into one, through the use of the abstract interface
technique described above.
Moreover, function name overloading can be used to simplify the
namespace for those cases where multiple functions were used to get
variations on a basic capability. For example, a single name such as
contour or shade can be used for multiple methods taking different
argument sets, so that for example, one can make simple plots of
rectangular data sets, or more complex generalized coordinate
mappings.

@node Specializing the PLplot C++ Interface, Status of the C++ Interface, Design of the PLplot C++ Interface, A C++ Interface for PLplot
@section Specializing the PLplot C++ Interface

The @samp{plstream} class is an ideal candidate for derivation. By
inheriting from @samp{plstream}, the user can construct a new class
which is automatically endowed with the ability to plot to a specific
PLplot output stream in a coherent manner without having to worry
about interplay with other @samp{plstream} (or derived type) objects.
Moreover, new, higher level, plotting functionality can be constructed
to provide even more simplicity and ease of use than the PLplot API.

The PLplot maintainers (Geoff and Maurice) expect to introduce a class
plxstream in the future which provides superior support for
constructing graphics with multiple plots per page, easier
specification of plot adornments, etc. This should significantly ease
one aspect of PLplot usage which we regard as being clumsy at this
time.

Beyond that, users may find it useful to derive from
@samp{plstream}
(or later plxstream whenever it finally makes its appearance) for the
purpose of making "application specific" output streams. For example,
a C++ program will normally have a variety of objects which constitute
the fundamental entities in the code. These could all be made to be
"atomically plotted" by providing suitable methods. For example:

@example

class Cat @{ ... @};
class Dog @{ ... @};
class Bear @{ ... @};
class Fish @{ ... @};

class zoostream : public plstream @{
  public:
    void plot( const Cat& c ) @{ ... @}
    void plot( const Dog& d ) @{ ... @}
    void plot( const Bear& b ) @{ ... @}
    void plot( const Fish& f ) @{ ... @}
@};
@end example

Presumably the PLplot user community can think of even more
imaginative uses... :-).

@node Status of the C++ Interface, , Specializing the PLplot C++ Interface, A C++ Interface for PLplot
@section Status of the C++ Interface

The class @samp{plstream} (and the other abstraction classes in
@file{plstream.h}) provided in PLplot 4.99j (alpha) are to be
considered as works in progress. By the standards outlined above, the
work has barely begun. At this time, @samp{plstream} is mostly a one
to one mirror of the C API, which is to say, it is still far from the
goals of simplification and abstraction outlined above. As such, it
can be expected to change radically over the course of time. (We
don't quote schedules--how long have you been waiting for 5.0? :-).

In any event, we would welcome improvement submissions along the lines
of those above, but we would strongly discourage people from using
@samp{plstream} if they are expecting it to be rock solid. It
@i{will}
be changing, to become more like the design goals elucidated above.

So, if you like the ideas described above, and are willing to accept
the burden of "upgrading" your code as the class @samp{plstream}
evolves, then feel free to use it. Just don't whine when I fix some
of the methods to take references instead of pointers, when I
eliminate some of the redundant methods to use the collapsed form,
etc.

@node Using PLplot from Tcl, Building an Extended WISH, A C++ Interface for PLplot, Top
@chapter Using PLplot from Tcl

PLplot has historically had C and Fortran language bindings. PLplot
version 5.0 introduces a plethora of new programming options including
C++ (described earlier) and several script language bindings. The Tcl
interface to PLplot (which the PLplot maintainers regard as the
primary script language binding) is described in this chapter,
with further discussion of Tcl related issues following in additional
chapters. But Tcl is certainly not the only script language option.
Bindings to Perl, Python, and Scheme (which is actually another
compiled language, but still has some of the flavor of a VHLL) are in
various stages of completion, and are described in separate chapters.
Use the one that suits you best--or try them all!

@menu
* Motivation for the Tcl Interface to PLplot::
* Overview of the Tcl Language Binding::
* The PLplot Tcl Matrix Extension::
* Contouring and Shading from Tcl::
* Understanding the Performance Characteristics of Tcl::
@end menu

@node Motivation for the Tcl Interface to PLplot, Overview of the Tcl Language Binding, , Using PLplot from Tcl
@section Motivation for the Tcl Interface to PLplot

The recent emergence of several high quality VHLL script languages
such as Tcl, Perl, Python and arguably even some Lisp variants, is
having a profound effect upon the art of computer programming. Tasks
which have traditionally been handled by C or Fortran, are beginning
to be seen in a new light. With relatively fast processors now widely
available, many programming jobs are no longer bound by execution
time, but by human time. Rapidity of initial development and
continued maintenance, for a surprisingly wide class of applications,
is far more important than execution time. Result: in a very short
period of time, say from 1993 to 1995, script languages have exploded
onto the scene, becoming essential tools for any serious programmer.

Moreover, the entire concept of speed of execution needs revising
in the face of the gains made in computer hardware in recent years.
Saying that script language processing is slower than compiled
language processing may be undeniable and simultaneously irrelevant.
If the script language processing is fast enough, then it is fast
enough. Increasingly, computational researchers are finding that
script based tools are indeed fast enough. And if their run time is
fast enough, and their development and maintenance time is much much
better, then why indeed should they not be used?

Even in a field with several high visibility players, Tcl has
distinguished itself as a leading contender. There are many reasons
for this, but perhaps the most important, at least as it relates to
the PLplot user community, is that Tcl was designed to be extensible
and embeddable. The whole purpose of Tcl, as it name (Tool Command
Language) indicates, is to be a command language for other tools. In
other words, the fact that Tcl is capable of being a standalone shell
is interesting, even useful, but nonetheless incidental. The real
attraction of Tcl is that it can be the shell language for
@i{your}
code. Tcl can easily be embedded into your code, endowing it
immediately with a full featured, consistent and well documented
script programming language, providing all the core features you need
in a programming language: variables, procedures, control structures,
error trapping and recovery, tracing, etc. But that is only the
beginning! After that, you can easily extend Tcl by adding commands
to the core language, which invoke the capabilities of your tool. It
is in this sense that Tcl is a tool command language. It is a command
language which you can augment to provide access to the facilities of
your tool.

But Tcl is more than just an embeddable, extensible script language
for personal use. Tcl is an industry, an internet phenomenon. There
are currently at least two high quality books, with more on the way.
There is an industry of service providers and educators. Furthermore,
literally hundreds of Tcl extensions exist, and are readily available
over the net. Perhaps the most notable extension, Tk, provides a
fantastic interface to X Windows widget programming, permitting the
construction of Motif like user interfaces, with none of the hassles
of actually using Motif. Some of these extensions endow Tcl with
object oriented facilities philosophically similar to C++ or other
object oriented languages. Other extensions provide script level
access to system services. Others provide a script interface to
sockets, RPC, and other network programming protocols. The list goes
on and on. Dive into the Tcl archive, and see what it has for you!

So, the answer to the question Why do we want a Tcl interface to
PLplot? is very simple. Because we we are using Tcl anyway, as
the command language for our project, and would like to be able to do
plotting in the command language just as we do so many other things.

But there is more than just the aesthetics of integration to consider.
There are also significant pragmatic considerations. If you generate
your PLplot output via function calls from a compiled language, then
in order to add new diagnostics to your code, or to refine or
embellish existing ones, you have to edit the source, recompile,
relink, and rerun the code. If many iterations are required to get
the plot right, significant time can be wasted. This can be
especially true in the case of C++ code making heavy use of templates,
for which many C++ compilers will have program link times measured in
minutes rather than seconds, even for trivial program changes.

In contrast, if the diagnostic plot is generated from Tcl, the
development cycle looks more like: start the shell (command line or
windowing), source a Tcl script, issue the command to generate the
plot, notice a bug, edit the Tcl script, resource the script, and
regenerate the plot. Notice that compiling, linking, and restarting
the program, have all been dropped from the development cycle. The
time savings from such a development cycle can be amazing!

@node Overview of the Tcl Language Binding, The PLplot Tcl Matrix Extension, Motivation for the Tcl Interface to PLplot, Using PLplot from Tcl
@section Overview of the Tcl Language Binding

Each of the PLplot calls available to the C or Fortran programmer are
also available from Tcl, with the same name and generally the same
arguments. Thus for instance, whereas in C you can write:

@example

plenv( 0., 1., 0., 1., 0, 0 );
pllab( "(x)", "(y)", "The title of the graph" );
@end example

you can now write in Tcl:

@example

plenv 0 1 0 1 0 0
pllab "(x)" "(y)" "The title of the graph"
@end example

All the normal Tcl rules apply, there is nothing special about the
PLplot extension commands. So, you could write the above as:

@example

set xmin 0; set xmax 1; set ymin 0; set ymax 1
set just 0; set axis 0
set xlab (x)
set ylab (y)
set title "The title of the graph"
plenv $xmin $xmax $ymin $ymax $just $axis
pllab $xlab $ylab $title
@end example

for example. Not that there is any reason to be loquacious for its
own sake, of course. The point is that you might have things like the
plot bounds or axis labels stored in Tcl variables for some other
reason (tied to a Tk entry widget maybe, or provided as the result of
one of your application specific Tcl extension commands, etc), and
just want to use standard Tcl substitution to make the PLplot calls.

Go ahead and try it! Enter @samp{pltcl} to start up the PLplot
extended Tcl shell, and type (or paste) in the commands. Or put them
in a file and source it. By this point it should be clear how
incredibly easy it is to use the PLplot Tcl language binding.

In order to accommodate the ubiquitous requirement for matrix oriented
data in scientific applications, and in the PLplot API in particular,
PLplot 5.0 includes a Tcl extension for manipulating matrices in Tcl.
This Tcl Matrix Extension provides a straightforward and direct means
of representing one and two dimensional matrices in Tcl. The Tcl
Matrix Extension is described in detail in the next section, but we
mention its existence now just so that we can show how the PLplot Tcl
API works. Many of the PLplot Tcl API functions accept Tcl matrices
as arguments. For instance, in C you might write:

@example

float x[100], y[100];

/* code to initialize x and y */

plline( 100, x, y );
@end example

In Tcl you can write:

@example

matrix x f 100
matrix y f 100

# code to initialize x and y

plline 100 x y
@end example

Some of the PLplot C function calls use pointer arguments to allow
retrieval of PLplot settings. These are implemented in Tcl by
changing the value of the variable whose name you provide. For
example:

@example

pltcl> plgxax
wrong # args: should be "plgxax digmax digits  "
pltcl> set digmax 0
0
pltcl> set digits 0
0
pltcl> plgxax digmax digits
pltcl> puts "digmax=$digmax digits=$digits"
digmax=4 digits=0
@end example

This example shows that each PLplot Tcl command is designed to issue
an error if you invoke it incorrectly, which in this case was used to
remind us of the correct arguments. We then create two Tcl variables
to hold the results. Then we invoke the PLplot @samp{plgxax} function
to obtain the label formatting information for the x axis. And
finally we print the results.

People familiar with Tcl culture may wonder why the @samp{plg*} series
functions don't just pack their results into the standard Tcl result
string. The reason is that the user would then have to extract the
desired field with either @samp{lindex} or
@samp{regexp}, which seems
messy. So instead, we designed the PLplot Tcl API to look and feel as
much like the C API as could reasonably be managed.

In general then, you can assume that each C function is provided in
Tcl with the same name and same arguments (and one or two dimensional
arrays in C are replaced by Tcl matrices). There are only a few
exceptions to this rule, generally resulting from the complexity of
the argument types which are passed to some functions in the C API.
Those exceptional functions are described below, all others work in
the obvious way (analogous to the examples above). 

See the Tcl example programs for extensive demonstrations of the usage
of the PLplot Tcl API. To run the Tcl demos:

@example

% pltcl
pltcl> source tcldemos.tcl
pltcl> 1
pltcl> 2
@end example

Alternatively, you can run @samp{plserver} and source
@file{tkdemos.tcl}.

In any event, the Tcl demos provide very good coverage of the Tcl API,
and consequently serve as excellent examples of usage. For the most
part they draw the same plots as their C counterpart. Moreover, many
of them were constructed by literally inserting the C code into the
Tcl source file, and performing fairly mechanical transformations on
the source. This should provide encouragement to anyone used to using
PLplot through one of the compiled interfaces, that they can easily
and rapidly become productive with PLplot in Tcl.

@node The PLplot Tcl Matrix Extension, Contouring and Shading from Tcl, Overview of the Tcl Language Binding, Using PLplot from Tcl
@section The PLplot Tcl Matrix Extension

Tcl does many things well, but handling collections of numbers is not
one of them. You could make lists, but for data sets of sizes
relevant to scientific graphics which is the primary domain of
applicability for PLplot, the extraction time is excessive and
burdensome. You could use Tcl arrays, but the storage overhead is
astronomical and the lookup time, while better than list manipulation,
is still prohibitive. 

To cope with this, a Tcl Matrix extension was created for the
purpose of making it feasible to work with large collections of
numbers in Tcl, in a way which is storage efficient, reasonably 
efficient for accesses from Tcl, and reasonably compatible with
practices used in compiled code.

@menu
* Using Tcl Matrices from Tcl::
* Using Tcl Matrices from C::
* Using Tcl Matrices from C++::
* Extending the Tcl Matrix facility::
@end menu

@node Using Tcl Matrices from Tcl, Using Tcl Matrices from C, , The PLplot Tcl Matrix Extension
@subsection Using Tcl Matrices from Tcl

Much like the Tk widget creation commands, the Tcl @samp{matrix}
command considers its first argument to be the name of a new command
to be created, and the rest of the arguments to be modifiers. After
the name, the next argument can be @samp{float} or
@samp{int} or
contractions thereof. Next follow a variable number of size arguments
which determine the size of the matrix in each of its dimensions. For
example: 

@example

matrix x f 100
matrix y i 64 64
@end example

constructs two matrices. @samp{x} is a float matrix, with one
dimension and 100 elements. @samp{y} is an integer matrix, and has 2
dimensions each of size 64.

Additionally, an initializer may be specified, with a syntax familiar
from C. For example:

@example

matrix x f 4 = @{ 1.5, 2.5, 3.5, 4.5 @}
@end example

A Tcl matrix is a command, and as longtime Tcl users know, Tcl
commands are globally accessible. The PLplot Tcl Matrix extension
attempts to lessen the impact of this by registering a variable in the
local scope, and tracing it for insets, and deleting the actual
matrix command when the variable goes out of scope. In this way, a
Tcl matrix appears to work sort of like a variable. It is, however,
just an illusion, so you have to keep this in mind. In particular,
you may want the matrix to outlive the scope in which it was created.
For example, you may want to create a matrix, load it with data, and
then pass it off to a Tk megawidget for display in a spreadsheet like
form. The proc which launches the Tk megawidget will complete, but
the megawidget, and the associated Tcl matrix are supposed to hang
around until they are explicitly destroyed. To achieve this effect,
create the Tcl matrix with the @samp{-persist} flag. If present
(can be anywhere on the line), the matrix is not automatically deleted
when the scope of the current proc (method) ends. Instead, you must
explicitly clean up by using either the 'delete' matrix command or renaming
the matrix command name to @{@}. Now works correctly from within [incr Tcl].

As mentioned above, the result of creating a matrix is that a new
command of the given name is added to the interpreter. You can then
evaluate the command, providing indices as arguments, to extract the
data. For example:

@example

pltcl> matrix x f = @{1.5, 2.5, 3.5, 4.5@}
insufficient dimensions given for Matrix operator "x"
pltcl> matrix x f 4 = @{1.5, 2.5, 3.5, 4.5@}
pltcl> x 0
1.500000
pltcl> x 1
2.500000
pltcl> x 3
4.500000
pltcl> x *
1.500000 2.500000 3.500000 4.500000
pltcl> puts "x\[1\]=[x 1]"
x[1]=2.500000
pltcl> puts "x\[*\] = :[x *]:"
x[*] = :1.500000 2.500000 3.500000 4.500000:
pltcl> foreach v [x *] @{ puts $v @}
1.500000
2.500000
3.500000
4.500000
pltcl> for @{set i 0@} @{$i < 4@} @{incr i@} @{
           if @{[x $i] < 3@} @{puts [x $i]@} @}
1.500000
2.500000
@end example

Note from the above that the output of evaluating a matrix indexing
operation is suitable for use in condition processing, list
processing, etc.

You can assign to matrix locations in a similar way:

@example

pltcl> x 2 = 7
pltcl> puts ":[x *]:"
:1.500000 2.500000 7.000000 4.500000:
pltcl> x * = 3
pltcl> puts ":[x *]:"
@end example

Note that the * provides a means of obtaining an index range, and that
it must be separated from the = by a space. Future versions of the
Tcl Matrix extension may allow alternative ways of specifying index
ranges and may assign the obvious meaning to an expression of the
form:

@example

x *= 3
@end example

However this has not been implemented yet...

In any event, the @samp{matrix} command also supports an
@samp{info}
subcommand which reports the number of elements in each dimension:

@example

pltcl> x info
4 
pltcl> matrix y i 8 10
pltcl> y info
8 10 
@end example

@node Using Tcl Matrices from C, Using Tcl Matrices from C++, Using Tcl Matrices from Tcl, The PLplot Tcl Matrix Extension
@subsection Using Tcl Matrices from C

Normally you will create a matrix in Tcl, and then want to pass it to
C in order to have the data filled in, or existing data to be used in
a computation, etc. To do this, pass the name of the matrix command
as an argument to your C Tcl command procedure. The C code should
include @file{tclMatrix.h}, which has a definition for the
@samp{tclMatrix} structure. You fetch a pointer to the
@samp{tclMatrix} structure using the
@samp{Tcl_GetMatrixPtr} function.

For example, in Tcl:

@example

matrix x f 100
wacky x
@end example

and in C:

@example

int wackyCmd( ClientData clientData, Tcl_Interp *interp,
              int argc, char *argv[] )
@{
    tclMatrix *w;

    w = Tcl_GetMatrixPtr( interp, argv[1] );
    ...
@end example

To learn about what else you can do with the matrix once inside
compiled code, read @file{tclMatrix.h} to learn the definition of the
@samp{tclMatrix} structure, and see the examples in files like
@file{tclAPI.c} which show many various uses of the Tcl matrix.

@node Using Tcl Matrices from C++, Extending the Tcl Matrix facility, Using Tcl Matrices from C, The PLplot Tcl Matrix Extension
@subsection Using Tcl Matrices from C++

Using a Tcl matrix from C++ is very much like using it from C, except
that @file{tclMatrix.h} contains some C++ wrapper classes which are
somewhat more convenient than using the indexing macros which one has
to use in C. For example, here is a tiny snippet from one of the
authors codes in which Tcl matrices are passed in from Tcl to a C++
routine which is supposed to fill them in with values from some
matrices used in the compiled side of the code:

@example

...
if (item == "vertex_coords") @{
    tclMatrix *matxg = Tcl_GetMatrixPtr( interp, argv[1] );
    tclMatrix *matyg = Tcl_GetMatrixPtr( interp, argv[2] );

    Mat2<float> xg(ncu, ncv), yg(ncu, ncv);
    cg->Get_Vertex_Coords( xg, yg );

    TclMatFloat txg( matxg ), tyg( matyg );

    for( i=0; i < ncu; i++ )
        for( j=0; j < ncv; j++ ) @{
            txg(i,j) = xg(i,j);
            tyg(i,j) = yg(i,j);
        @}
@end example

There are other things you can do too, see the definitions of the
@samp{TclMatFloat} and @samp{TclMatInt} classes in
@file{tclMatrix.h}. 

@node Extending the Tcl Matrix facility, , Using Tcl Matrices from C++, The PLplot Tcl Matrix Extension
@subsection Extending the Tcl Matrix facility

The Tcl matrix facility provides creation, indexing, and information
gathering facilities. However, considering the scientifically
inclined PLplot user base, it is clear that some users will demand
more. Consequently there is a mechanism for augmenting the Tcl matrix
facility with your own, user defined, extension subcommands. Consider
@file{xtk04.c}. In this extended wish, we want to be able to
determine the minimum and maximum values stored in a matrix. Doing
this in Tcl would involve nested loops, which in Tcl would be
prohibitively slow. We could register a Tcl extension command to do
it, but since the only sensible data for such a command would be a
Tcl matrix, it seems nice to provide this facility as an actual
subcommand of the matrix. However, the PLplot maintainers cannot
foresee every need, so a mechanism is provided to register subcommands
for use with matrix objects.

The way to register matrix extension subcommands is to call
@samp{Tcl_MatrixInstallXtnsn}: 

@example

typedef int (*tclMatrixXtnsnProc) ( tclMatrix *pm, Tcl_Interp *interp,
                                    int argc, char *argv[] );

int Tcl_MatrixInstallXtnsn( char *cmd, tclMatrixXtnsnProc proc );
@end example

In other words, make a function for handling the matrix extension
subcommand, with the same function signature (prototype) as
@samp{tclMatrixXtnsnProc}, and register the subcommand name along with
the function pointer. For example, xtk04.c has:

@example

int mat_max( tclMatrix *pm, Tcl_Interp *interp,
             int argc, char *argv[] )
@{
    float max = pm->fdata[0];
    int i;
    for( i=1; i < pm->len; i++ )
        if (pm->fdata[i] > max)
            max = pm->fdata[i];

    sprintf( interp->result, "%f", max );
    return TCL_OK;
@}

int mat_min( tclMatrix *pm, Tcl_Interp *interp,
             int argc, char *argv[] )
@{
    float min = pm->fdata[0];
    int i;
    for( i=1; i < pm->len; i++ )
        if (pm->fdata[i] < min)
            min = pm->fdata[i];

    sprintf( interp->result, "%f", min );
    return TCL_OK;
@}
@end example

Then, inside the application initialization function
(@samp{Tcl_AppInit()} to long time Tcl users):

@example

Tcl_MatrixInstallXtnsn( "max", mat_max );
Tcl_MatrixInstallXtnsn( "min", mat_min );
@end example

Then we can do things like:

@example

dino 65: xtk04
% matrix x f 4 = @{1, 2, 3, 1.5@}
% x min
1.000000
% x max
3.000000
@end example

Your imagination is your only limit for what you can do with this.
You could add an FFT subcommand, matrix math, BLAS, whatever. 

@node Contouring and Shading from Tcl, Understanding the Performance Characteristics of Tcl, The PLplot Tcl Matrix Extension, Using PLplot from Tcl
@section Contouring and Shading from Tcl

Contouring and shading has traditionally been one of the
messier things to do in PLplot. The C API has many parameters, with
complex setup and tear down properties. Of special concern is that
some of the parameters do not have a natural representation in script
languages like Tcl. In this section we describe how the Tcl
interface to these facilities is provided, and how to use it.

@menu
* Drawing a Contour Plot from Tcl::
* Drawing a Shaded Plot from Tcl::
@end menu

@node Drawing a Contour Plot from Tcl, Drawing a Shaded Plot from Tcl, , Contouring and Shading from Tcl
@subsection Drawing a Contour Plot from Tcl

By way of reference, the primary C function call for contouring is:

@example

void plcont( PLFLT **f, PLINT nx, PLINT ny, PLINT kx, PLINT lx,
             PLINT ky, PLINT ly, PLFLT *clevel, PLINT nlevel,
             void (*pltr) (PLFLT, PLFLT, PLFLT *, PLFLT *, PLPointer),
             PLPointer pltr_data);
@end example


This is a fairly complex argument list, and so for this function (and
for plshade, described below) we dispense with trying to exactly
mirror the C API, and just concentrate on capturing the functionality
within a Tcl context. To begin with, the data is provided through a
2-d Tcl matrix. The Tcl matrix carries along its size information
with it, so @samp{nx} and @samp{ny} are no longer needed. The
@samp{kx}, @samp{lx}, @samp{ky} and
@samp{ly} variables are
potentially still useful for plotting a subdomain of the full data
set, so they may be specified in the natural way, but we make this
optional since they are frequently not used to convey anything more
than what could be inferred from @samp{nx} and
@samp{ny}. However, to
simplify processing, they must be supplied or omitted as a set (all of
them, or none of them). @samp{clevel} is supplied as a 1-d Tcl
matrix, and so @samp{nlevel} can be omitted. 

Finally, we have no way to support function pointers from Tcl, so
instead we provide token based support for accessing the three
coordinate transformation routines which are provided by PLplot, and
which many PLplot users use. There are thus three courses of action:

@itemize @bullet{}

@item
Provide no pltr specification. In this case, @samp{pltr0} is
used by default.

@item
Specify @samp{pltr1 x y} where x and y are 1-d Tcl matrices.
In this case @samp{pltr1} will be used, and the 1-d arrays which it
needs will be supplied from the Tcl matrices @samp{x} and
@samp{y}.

@item
Specify @samp{pltr2 x y} where x and y are 2-d Tcl matrices.
In this case @samp{pltr2} will be used, and the 2-d arrays which it
needs will be supplied from the Tcl matrices @samp{x} and
@samp{y}.
@end itemize

Now, there can be no question that this is both more concise and less
powerful than what you could get in C. The loss of the ability to
provide a user specified transformation function is regrettable. If
you really do need that functionality, you will have to implement your
own Tcl extension command to do pretty much the same thing as the
provided Tcl extension command @samp{plcont} (which is in
@file{tclAPI.c} in function @samp{plcontCmd()}), except specify the C
transformation function of your choice.

However, that having been said, we recognize that one common use for
this capability is to provide a special version of @samp{pltr2} which
knows how to implement a periodic boundary condition, so that polar
plots, for example, can be implemented cleanly. That is, if you want
to draw contours of a polar data set defined on a 64 x 64 grid,
ensuring that contour lines would actually go all the way around the
origin rather than breaking off like a silly pacman figure, then you
had basically two choices in C. You could copy the data to a 65 x 64
grid, and replicate one row of data into the spare slot, and then plot
the larger data set (taking care to replicate the coordinate arrays
you passed to pltr2 in the same way), @i{or} you could make a
special version of @samp{pltr2} which would understand that one of the
coordinates was wrapped, and perform transformations accordingly
without actually making you replicate the data.

Since the former option is ugly in general, and hard to do in Tcl in
particular, and since the second option is even more difficult to do
in Tcl (requiring you do make a special Tcl extension command as
described above), we provide special, explicit support for this common
activity. This is provided through the use of a new, optional
parameter @samp{wrap} which may be specified as the last parameter to
the Tcl command, only if you are using @samp{pltr2}. Supplying
@samp{1} will wrap in the first coordinate, @samp{2} will wrap in the
second coordinate.

The resultant Tcl command is:

@example

plcont f [kx lx ky ly] clev [pltr x y] [wrap]
@end example

Note that the brackets here are used to signify optional arguments,
@i{not} to represent Tcl command substitution!

The Tcl demo @file{x09.tcl} provides examples of all the capabilities
of this interface to contouring from Tcl. Note in particular,
@samp{x09_polar} which does a polar contour without doing anything
complicated in the way of setup, and without getting a pacman as the
output. 

@node Drawing a Shaded Plot from Tcl, , Drawing a Contour Plot from Tcl, Contouring and Shading from Tcl
@subsection Drawing a Shaded Plot from Tcl

The Tcl interface to shading works very much like the one for
contouring. The command is:

@example

plshade z xmin xmax ymin ymax \
    sh_min sh_max sh_cmap sh_color sh_width \
    min_col min_wid max_col max_wid \
    rect [pltr x y] [wrap]
@end example

where @samp{nx} and @samp{ny} were dropped since they are inferred
from the Tcl matrix @samp{z}, @samp{defined} was dropped since it
isn't supported anyway, and @samp{plfill} was dropped since it was the
only valid choice anyway. The @samp{pltr} spec and
@samp{wrap} work
exactly as described for the Tcl @samp{plcont} described above.

The Tcl demo @file{x16.tcl} contains extensive demonstrations of use,
including a shaded polar plot which connects in the desirable way
without requiring special data preparation, again just like for
@samp{plcont} described previously.

@node Understanding the Performance Characteristics of Tcl, , Contouring and Shading from Tcl, Using PLplot from Tcl
@section Understanding the Performance Characteristics of Tcl

Newcomers to Tcl, and detractors (read, proponents of other
paradigms) often do not have a clear (newcomers) or truthful
(detractors) perspective on Tcl performance. In this section we try
to convey a little orientation which may be helpful in working with
the PLplot Tcl interface.

Tcl is slow! Yeah, so what?

Debates of this form frequently completely miss the point. Yes, Tcl
is definitely slow. It is fundamentally a string processing language,
is interpreted, and must perform substitutions and so forth on a
continual basis. All of that takes time. Think milliseconds instead
of microseconds for comparing Tcl code to equivalent C code. On the
other hand, this does not have to be problematic, even for time
critical (interactive) applications, if the division of labor is done
correctly. Even in an interactive program, you can use Tcl fairly
extensively for high level control type operations, as long as you do
the real work in a compiled Tcl command procedure. If the high level
control code is slow, so what? So it takes 100 milliseconds over the
life the process, as compared to the 100 microseconds it could have
taken if it were in C. Big deal. On an absolute time scale, measured
in units meaningful to humans, it's just not a lot of time.

The problem comes when you try to do too much in Tcl. For instance,
an interactive process should not be trying to evaluate a
mathematical expression inside a doubly nested loop structure, if
performance is going to be a concern.

Case in point: Compare x16.tcl to x16c.c. The code looks very
similar, and the output looks very similar. What is not so similar is
the execution time. The Tcl code, which sets up the data entirely in
Tcl, takes a while to do so. On the other hand, the actual plotting
of the data proceeds at a rate which is effectively indistinguishable
from that of the compiled example. On human time scales, the
difference is not meaningful. Conclusion: If the computation of the
data arrays could be moved to compiled code, the two programs would
have performance close enough to identical that it really wouldn't be
an issue. We left the Tcl demos coded in Tcl for two reasons. First
because they provide some examples and tests of the use of the Tcl
Matrix extension, and secondly because they allow the Tcl demos to be
coded entirely in Tcl, without requiring special customized extended
shells for each one of them. They are not, however, a good example of
you should do things in practice.

Now look at @file{tk04} and @file{xtk04.c}, you will see
that if the data is computed in compiled code, and shuffled into the
Tcl matrix and then plotted from Tcl, the performance is fine. Almost
all the time is spent in plshade, in compiled code. The time taken to
do the small amount of Tcl processing involved with plotting is
dwarfed by the time spent doing the actual drawing in C. So using Tcl
cost almost nothing in this case.

So, the point is, do your heavy numerics in a compiled language, and
feel free to use Tcl for the plotting, if you want to. You can of
course mix it up so that some plotting is done from Tcl and some from
a compiled language. 

@node Building an Extended WISH, Embedding Plots in Graphical User Interfaces, Using PLplot from Tcl, Top
@chapter Building an Extended WISH

Beginning with PLplot 5.0, a new and powerful paradigm for interaction
with PLplot is introduced. This new paradigm consists of an
integration of PLplot with a powerful scripting language (Tcl), and
extensions to that language to support X Windows interface development
(Tk) and object oriented programming ([incr Tcl]). Taken together,
these four software systems (Tcl/Tk/itcl/PLplot) comprise a powerful
environment for the rapid prototyping and development of sophisticated,
flexible, X Windows applications with access to the PLplot API. Yet
that is only the beginning---Tcl was born to be extended. The true
power of this paradigm is achieved when you add your own, powerful,
application specific extensions to the above quartet, thus creating an
environment for the development of wholly new applications with only a
few keystrokes of shell programming ...

@menu
* Introduction to Tcl::
* Introduction to Tk::
* Introduction to [incr Tcl]::
* PLplot Extensions to Tcl::
* Custom Extensions to Tcl::
@end menu

@node Introduction to Tcl, Introduction to Tk, , Building an Extended WISH
@section Introduction to Tcl

The Tool Command Language, or just Tcl (pronounced
tickle) is an embeddable script language which can be
used to control a wide variety of applications. Designed by John
Ousterhout of UC Berkeley, Tcl is freely available under the standard
Berkeley copyright. Tcl and Tk (described below) are extensively
documented in a new book published by Addison Wesley, entitled
Tcl and the Tk toolkit by John Ousterhout. This book
is a must have for those interested in developing powerful extensible
applications with high quality X Windows user interfaces. The
discussion in this chapter cannot hope to approach the level of
introduction provided by that book. Rather we will concentrate on
trying to convey some of the excitement, and show the nuts and bolts
of using Tcl and some extensions to provide a powerful and flexible
interface to the PLplot library within your application.

@menu
* Motivation for Tcl::
* Capabilities of Tcl::
* Acquiring Tcl::
@end menu

@node Motivation for Tcl, Capabilities of Tcl, , Introduction to Tcl
@subsection Motivation for Tcl

The central observation which led Ousterhout to create Tcl was the
realization that many applications require the use of some sort of
a special purpose, application specific, embedded macro
language. Application programmers cobble these tiny
languages into their codes in order to provide flexibility
and some modicum of high level control. But the end result is
frequently a quirky and fragile language. And each application has
a different tiny language associated with it. The
idea behind Tcl, then, was to create a single core
language which could be easily embedded into a wide variety
of applications. Further, it should be easily extensible so that
individual applications can easily provide application specific
capabilities available in the macro language itself, while still
providing a robust, uniform syntax across a variety of
applications. To say that Tcl satisfies these requirements would
be a spectacular understatement.

@node Capabilities of Tcl, Acquiring Tcl, Motivation for Tcl, Introduction to Tcl
@subsection Capabilities of Tcl

The mechanics of using Tcl are very straightforward. Basically you
just have to include the file @file{tcl.h}, issue
some API calls to create a Tcl interpreter, and then evaluate a
script file or perform other operations supported by the Tcl API.
Then just link against @file{libtcl.a} and off you
go.

Having done this, you have essentially created a shell. That is, your
program can now execute shell scripts in the Tcl language. Tcl
provides support for basic control flow, variable substitution file
i/o and subroutines. In addition to the builtin Tcl commands, you can
define your own subroutines as Tcl procedures which effectively
become new keywords.

But the real power of this approach is to add new commands to the
interpreter which are realized by compiled C code in your
application. Tcl provides a straightforward API call which allows
you to register a function in your code to be called whenever the
interpreter comes across a specific keyword of your choosing in
the shell scripts it executes.

This facility allows you with tremendous ease, to endow your
application with a powerful, robust and full featured macro
language, trivially extend that macro language with new keywords
which trigger execution of compiled application specific commands,
and thereby raise the level of interaction with your code to one of
essentially shell programming via script editing.

@node Acquiring Tcl, , Capabilities of Tcl, Introduction to Tcl
@subsection Acquiring Tcl

There are several important sources of info and code for Tcl.
Definitely get the book mentioned above. The Tcl and Tk toolkits
are distributed by anonymous @code{ftp} at @uref{ftp://sprite.berkeley.edu/tcl,@file{sprite.berkeley.edu:/tcl}}.
There are several files in there corresponding to Tcl, Tk, and
various forms of documentation. At the time of this writing, the
current versions of Tcl and Tk are 7.3 and 3.6 respectively.
Retrieve those files, and install using the instructions provided
therein.

The other major anonymous @code{ftp} site for Tcl is
@uref{ftp://harbor.ecn.purdue.edu/pub/tcl,@file{harbor.ecn.purdue.edu:/pub/tcl}}.
Harbor contains a mirror of @samp{sprite} as well as
innumerable extensions, Tcl/Tk packages, tutorials, documentation,
etc. The level of excitement in the Tcl community is
extraordinarily high, and this is reflected by the great plethora
of available, high quality, packages and extensions available for
use with Tcl and Tk. Explore---there is definitely something
for everyone.

Additionally there is a newsgroup, @samp{comp.lang.tcl}
which is well read, and an excellent place for people to get
oriented, find help, etc. Highly recommended.

In any event, in order to use the Tk driver in PLplot, you will
need Tcl-8.2 and Tk-8.2 (or higher versions). Additionally, in order
to use the extended WISH paradigm (described below) you will need
iTcl-3.1 (or a higher version).

However, you will quite likely find Tcl/Tk to be very addictive,
and the great plethora of add-ons available at
@samp{harbor} will undoubtedly attract no small amount
of your attention. It has been our experience that all of these
extensions fit together very well. You will find that there are
large sectors of the Tcl user community which create so-called
MegaWishes which combine many of the available
extensions into a single, heavily embellished, shell interpreter.
The benefits of this approach will become apparent as you gain
experience with Tcl and Tk.

@node Introduction to Tk, Introduction to [incr Tcl], Introduction to Tcl, Building an Extended WISH
@section Introduction to Tk

As mentioned above, Tcl is designed to be extensible. The first and
most basic Tcl extension is Tk, an X11 toolkit. Tk provides the same
basic facilities that you may be familiar with from other X11
toolkits such as Athena and Motif, except that they are provided in
the context of the Tcl language. There are C bindings too, but these
are seldom needed---the vast majority of useful Tk applications
can be coded using Tcl scripts.

If it has not become obvious already, it is worth noting at this
point that Tcl is one example of a family of languages known
generally as Very High Level Languages, or VHLL's.
Essentially a VHLL raises the level of programming to a very high
level, allowing very short token streams to accomplish as much as
would be required by many scores of the more primitive actions
available in a basic HLL. Consider, for example, the basic
Hello World! application written in Tcl/Tk.


@example

#!/usr/local/bin/wish -f

button .hello -text "Hello World!"  -command "destroy ."
pack .hello
@end example

That's it! That's all there is to it. If you have ever programmed X
using a traditional toolkit such as Athena or Motif, you can
appreciate how amazingly much more convenient this is. If not, you
can either take our word for it that this is 20 times less code than
you would need to use a standard toolkit, or you can go write the
same program in one of the usual toolkits and see for yourself...

We cannot hope to provide a thorough introduction to Tk programming
in this section. Instead, we will just say that immensely complex
applications can be constructed merely by programming in exactly the
way shown in the above script. By writing more complex scripts, and
by utilizing the additional widgets provided by Tk, one can create
beautiful, extensive user interfaces. Moreover, this can be done in
a tiny fraction of the time it takes to do the same work in a
conventional toolkit. Literally minutes versus days.

Tk provides widgets for labels, buttons, radio buttons, frames with
or without borders, menubars, pull downs, toplevels, canvases, edit
boxes, scroll bars, etc.

A look at the interface provided by the PLplot Tk driver
should help give you a better idea of what you can do with this
paradigm. Also check out some of the contributed Tcl/Tk packages
available at harbor. There are high quality Tk interfaces to a great
many familiar Unix utilities ranging from mail to info, to SQL, to
news, etc. The list is endless and growing fast...

@node Introduction to [incr Tcl], PLplot Extensions to Tcl, Introduction to Tk, Building an Extended WISH
@section Introduction to [incr Tcl]

Another extremely powerful and popular extension to Tcl is [incr
Tcl]. [incr Tcl] is to Tcl what C++ is to C. The analogy is very
extensive. Itcl provides an object oriented extension to Tcl
supporting clustering of procedures and data into what is called an
@samp{itcl_class}. An @samp{itcl_class} can
have methods as well as instance data. And they support inheritance.
Essentially if you know how C++ relates to C, and if you know Tcl,
then you understand the programming model provided by Itcl.

In particular, you can use Itcl to implement new widgets which are
composed of more basic Tk widgets. A file selector is an example.
Using Tk, one can build up a very nice file selector comprised of
more basic Tk widgets such as entries, listboxes, scrollbars, etc.

But what if you need two file selectors? You have to do it all
again. Or what if you need two different kinds of file selectors,
you get to do it again and add some incremental code.

This is exactly the sort of thing object orientation is intended to
assist. Using Itcl you can create an @samp{itcl_class
FileSelector} and then you can instantiate them freely as
easily as:


@example

    FileSelector .fs1
    .fs1 -dir . -find "*.cc"
@end example

and so forth.

These high level widgets composed of smaller Tk widgets, are known as
megawidgets. There is a developing subculture of the
Tcl/Tk community for designing and implementing megawidgets, and
[incr Tcl] is the most popular enabling technology.

In particular, it is the enabling technology which is employed for
the construction of the PLplot Tcl extensions, described below.

@node PLplot Extensions to Tcl, Custom Extensions to Tcl, Introduction to [incr Tcl], Building an Extended WISH
@section PLplot Extensions to Tcl

Following the paradigm described above, PLplot provides extensions to
Tcl as well, designed to allow the use of PLplot from Tcl/Tk
programs. Essentially the idea here is to allow PLplot programmers
to achieve two goals:

@itemize @bullet{}

@item
To access PLplot facilities from their own extended WISH and/or
Tcl/Tk user interface scripts.

@item
To have PLplot display its output in a window integrated
directly into the rest of their Tcl/Tk interface.
@end itemize

For instance, prior to PLplot 5.0, if a programmer wanted to use
PLplot in a Tcl/Tk application, the best he could manage was to call
the PLplot C API from compiled C code, and get the output via the
Xwin driver, which would display in it's own toplevel window. In
other words, there was no integration, and the result was pretty
sloppy.

With PLplot 5.0, there is now a supported Tcl interface to PLplot
functionality. This is provided through a family of
PLplot megawidgets implemented in [incr Tcl]. Using this interface,
a programmer can get a PLplot window/widget into a Tk interface as
easily as:


@example

PLWin .plw
pack .plw
@end example

Actually, there's the update/init business---need to clear that up.

The @samp{PLWin} class then mirrors much of the PLplot C
API, so that a user can generate plots in the PLplot widget entirely
from Tcl. This is demonstrated in the @file{tk02}
demo,

@node Custom Extensions to Tcl, , PLplot Extensions to Tcl, Building an Extended WISH
@section Custom Extensions to Tcl

By this point, you should have a pretty decent understanding of the
underlying philosophy of Tcl and Tk, and the whole concept of
extensions, of which [incr Tcl] and PLplot are examples. These alone
are enough to allow the rapid prototyping and development of
powerful, flexible graphical applications. Normally the programmer
simply writes a shell script to be executed by the Tk windowing
shell, @code{wish}. It is in vogue for each Tcl/Tk
extension package to build it's own extended WISH.
There are many examples of this, and indeed even PLplot's
@code{plserver} program, described in an earlier chapter,
could just as easily have been called @code{plwish}.

In any event, as exciting and useful as these standalone, extended
windowing shells may be, they are ultimately only the beginning of
what you can do. The real benefit of this approach is realized when
you make your own extended WISH, comprised of Tcl, Tk,
any of the standard extensions you like, and finally embellished with
a smattering of application specific extensions designed to support
your own application domain. In this section we give a detailed
introduction to the process of constructing your own WISH. After
that, you're on your own...

@menu
* WISH Construction::
* WISH Linking::
* WISH Programming::
@end menu

@node WISH Construction, WISH Linking, , Custom Extensions to Tcl
@subsection WISH Construction

The standard way to make your own WISH, as supported by the Tcl/Tk
system, is to take a boilerplate file,
@file{tkAppInit.c}, edit to reflect the Tcl/Tk
extensions you will be requiring, add some commands to the
interpreter, and link it all together.

Here for example is the important part of the
@file{tk02} demo, extracted from the file
@file{xtk02.c}, which is effectively the extended
WISH definition file for the @file{tk02} demo.
Comments and other miscellany are omitted.


@example

#include "tk.h"
#include "itcl.h"

/* ... */

int   myplotCmd        (ClientData, Tcl_Interp *, int, char **);

int
Tcl_AppInit(interp)
    Tcl_Interp *interp;		/* Interpreter for application. */
@{
int   plFrameCmd        (ClientData, Tcl_Interp *, int, char **);

    Tk_Window main;

    main = Tk_MainWindow(interp);

    /*
     * Call the init procedures for included packages.  Each call should
     * look like this:
     *
     * if (Mod_Init(interp) == TCL_ERROR) @{
     *     return TCL_ERROR;
     * @}
     *
     * where "Mod" is the name of the module.
     */

    if (Tcl_Init(interp) == TCL_ERROR) @{
        return TCL_ERROR;
    @}
    if (Tk_Init(interp) == TCL_ERROR) @{
        return TCL_ERROR;
    @}
    if (Itcl_Init(interp) == TCL_ERROR) @{
        return TCL_ERROR;
    @}
    if (Pltk_Init(interp) == TCL_ERROR) @{
        return TCL_ERROR;
    @}

    /*
     * Call Tcl_CreateCommand for application-specific commands, if
     * they weren't already created by the init procedures called above.
     */

    Tcl_CreateCommand(interp, "myplot", myplotCmd,
                      (ClientData) main, (void (*)(ClientData)) NULL);


    /*
     * Specify a user-specific startup file to invoke if the
     * application is run interactively.  Typically the startup
     * file is "~/.apprc" where "app" is the name of the application.
     * If this line is deleted then no user-specific startup file
     * will be run under any conditions.
     */

    tcl_RcFileName = "~/.wishrc";
    return TCL_OK;
@}

/* ... myPlotCmd, etc ... */
@end example

The calls to @samp{Tcl_Init()} and
@samp{Tk_Init()} are in every WISH. To make an
extended WISH, you add calls to the initialization routines for any
extension packages you want to use, in this [incr Tcl]
(@samp{Itcl_Init()}) and PLplot
(@samp{Pltk_Init()}). Finally you add keywords to the
interpreter, associating them with functions in your code using
@samp{Tcl_CreateCommand()} as shown.

In particular, PLplot has a number of [incr Tcl] classes in its Tcl
library. If you want to be able to use those in your WISH, you
need to include the initialization of [incr Tcl].

@node WISH Linking, WISH Programming, WISH Construction, Custom Extensions to Tcl
@subsection WISH Linking

Having constructed your @samp{Tcl_AppInit()} function,
you now merely need to link this file with your own private files
to provide the code for any functions you registered via
@samp{Tcl_CreateCommand()} (and any they depend on),
against the Tcl, Tk and extension libraries you are using.


@example

cc -c tkAppInit.c
cc -c mycommands.c
cc -o my_wish tkAppInit.o mycommands.o 
           -lplplotftk -ltcl -ltk -litcl -lX11 -lm
@end example

Add any needed @samp{-L} options as needed.

Voila! You have made a wish.

@node WISH Programming, , WISH Linking, Custom Extensions to Tcl
@subsection WISH Programming

Now you are ready to put the genie to work. The basic plan here is
to write shell scripts which use your new application specific
windowing shell as their interpreter, to implement X Windows user
interfaces to control and utilize the facilities made available in
your extensions.

Effectively this just comes down to writing Tcl/Tk code, embellished
as appropriate with calls to the extension commands you registered.
Additionally, since this wish includes the PLplot extensions, you
can instantiate any of the PLplot family of [incr Tcl] classes, and
invoke methods on those objects to effect the drawing of graphs.
Similarly, you may have your extension commands (which are coded in
C) call the PLplot C programmers API to draw into the widget. In
this way you can have the best of both worlds. Use compiled C code
when the computational demands require the speed of compiled code,
or use Tcl when your programming convenience is more important than
raw speed.

@node Embedding Plots in Graphical User Interfaces, Using PLplot from Perl, Building an Extended WISH, Top
@chapter Embedding Plots in Graphical User Interfaces

This chapter describes how to embed plots in graphical user interfaces.

@menu
* The PlplotCanvas Widget for Gnome/GTK Applications::
@end menu

@node The PlplotCanvas Widget for Gnome/GTK Applications, , , Embedding Plots in Graphical User Interfaces
@section The PlplotCanvas Widget for Gnome/GTK Applications

Plots can be embedded into Gnome/GTK applications by using the
PlplotCanvas widget. Information on the GTK toolkit is provided
at http://www.gtk.org/. PlplotCanvas is a subclass of the GnomeCanvas
(see http://developer.gnome.org/doc/API/2.0/libgnomecanvas/index.html), 
and so includes all of its functionality. The specialized C API for 
PlplotCanvas is described in
@ref{PlplotCanvas API,,PlplotCanvas API}., and bindings to other languages
are described in *** NEEDS DOCUMENTATION ***.

@menu
* PlplotCanvas Basics::
* PlplotCanvas API::
* PlplotCanvas Examples::
@end menu

@node PlplotCanvas Basics, PlplotCanvas API, , The PlplotCanvas Widget for Gnome/GTK Applications
@subsection PlplotCanvas Basics

The method declarations and data structures are defined in 
@file{plplotcanvas.h}. Programs using the PlplotCanvas
widget must be linked against the 
@file{libplplotgnome2d} library 
rather than @file{libplplotd}. This is most easily 
accomplished using pkg-config; i.e.,

@example

        gcc plplotcanvas_demo.c -o plplotcanvas_demo `pkg-config --cflags --libs plplotd-gnome2`
      
@end example

@noindent
You may need to remind pkg-config where to look for the 
@file{plplotd-gnome2.pc} file installed by PLplot; e.g.,

@example

        gcc plplotcanvas_demo.c -o plplotcanvas_demo `PKG_CONFIG_PATH=/usr/local/lib/pkgconfig pkg-config --cflags --libs plplotd-gnome2`
      
@end example

A specialized API is provided for PlplotCanvas and is described in
@ref{PlplotCanvas API,,PlplotCanvas API}.. The API provides methods
to create and manipulate PlplotCanvas widgets, in addition to
object-oriented analogues for each of the PLplot functions.

Example programs are provided that demonstrate the use of the 
PlplotCanvas widget in @ref{PlplotCanvas Examples,,PlplotCanvas Examples}..

@node PlplotCanvas API, PlplotCanvas Examples, PlplotCanvas Basics, The PlplotCanvas Widget for Gnome/GTK Applications
@subsection PlplotCanvas API

The PlplotCanvas methods are as follows. Because PlplotCanvas is a
GTK widget, GLib types (gint, gdouble, gboolean, etc) are sometimes 
used rather than PLplot types (PLINT, PLFLT, etc). See 
http://developer.gnome.org/doc/API/2.0/glib/index.html for more 
information on GLib and GLib types.

@menu
* plplot_canvas_new; Creates a new PlplotCanvas_::
* plplot_canvas_plfunc; PLplot function analogues_::
* plplot_canvas_dispose; Disposes the canvas_::
* plplot_canvas_set_size; Sets the canvas size_::
* plplot_canvas_use_text; Sets text handling_::
* plplot_canvas_use_pixmap; Sets pixmap usage_::
* plplot_canvas_use_persistence; Sets persistence of subsequent drawing operations_::
* plplot_canvas_get_stream_number; Retrieves the PLplot stream number_::
@end menu

@node plplot_canvas_new; Creates a new PlplotCanvas_, plplot_canvas_plfunc; PLplot function analogues_, , PlplotCanvas API
@subsubsection   plplot_canvas_new: Creates a new PlplotCanvas.  


@quotation

@t{@b{
PlplotCanvas* plplot_canvas_new
}(@i{void});}
@end quotation

Returns a pointer to a new PlplotCanvas widget. Methods that
apply to a PlplotCanvas are given next.

@table @asis

@item   @code{void}   
There are no arguments for this method.
@end table

@node plplot_canvas_plfunc; PLplot function analogues_, plplot_canvas_dispose; Disposes the canvas_, plplot_canvas_new; Creates a new PlplotCanvas_, PlplotCanvas API
@subsubsection   plplot_canvas_plfunc: PLplot function analogues.  


@quotation

@t{@b{void plplot_canvas_plfunc}(@i{canvas}, @i{...});}
@end quotation

The PLplot functions have analogue methods named like
@code{plplot_canvas_plfunc}. For example, the 
PLplot function @code{plline} (@pxref{plline; Draw a line}) maps to 
@code{plplot_canvas_plline}. The 
@code{plplot_canvas_plfunc} methods
should be used rather than the standard PLplot API when the
PlplotCanvas is used.

Lines drawn to the canvas are not shown until the page is
advanced using @code{plplot_canvas_pladv}. The 
plot will remain on the canvas until the next page advance.

The PLplot @code{plinit} (@pxref{plinit; Initialize PLplot}) and @code{plgstrm} (@pxref{plgstrm; Get current stream number}) functions are not used with 
PlplotCanvas because the @code{plplot_canvas_new}
function does the necessary initialization and returns an 
object with a unique stream number.

@table @asis

@item   @code{canvas}   (@samp{PlplotCanvas*}, input)  
The canvas on which to operate.

@item   @code{...}   
The list of arguments from the PLplot function analogue. The
same types used in the PLplot function are used here.
@end table

@node plplot_canvas_dispose; Disposes the canvas_, plplot_canvas_set_size; Sets the canvas size_, plplot_canvas_plfunc; PLplot function analogues_, PlplotCanvas API
@subsubsection   plplot_canvas_dispose: Disposes the canvas.  


@quotation

@t{@b{void plplot_canvas_dispose}(@i{canvas});}
@end quotation

Disposes the Canvas.

@table @asis

@item   @code{canvas}   (@samp{PlplotCanvas*}, input)  
The canvas to dispose.
@end table

@node plplot_canvas_set_size; Sets the canvas size_, plplot_canvas_use_text; Sets text handling_, plplot_canvas_dispose; Disposes the canvas_, PlplotCanvas API
@subsubsection   plplot_canvas_set_size: Sets the canvas size.  


@quotation

@t{@b{
void plplot_canvas_set_size
}(@i{canvas}, @i{width}, @i{height});}
@end quotation

Sets the PlplotCanvas widget width and height.

@table @asis

@item   @code{canvas}   (@samp{PlplotCanvas*}, input)  
The PlplotCanvas to size.

@item   @code{width} (@samp{gint}, input)  
The width, in pixels.

@item   @code{height} (@samp{gint}, input)  
The height, in pixels.
@end table

@node plplot_canvas_use_text; Sets text handling_, plplot_canvas_use_pixmap; Sets pixmap usage_, plplot_canvas_set_size; Sets the canvas size_, PlplotCanvas API
@subsubsection   plplot_canvas_use_text: Sets text handling.  


@quotation

@t{@b{void plplot_canvas_use_text}(@i{canvas}, @i{use_text});}
@end quotation

Sets whether TrueType text or Hershey fonts are used by the
PlplotCanvas widget.

@table @asis

@item   @code{canvas}   (@samp{PlplotCanvas*}, input)  
The PlplotCanvas to set.

@item   @code{use_text}   (@samp{gboolean}, input)  
TRUE for TrueType fonts (default), FALSE for Hershey fonts.
@end table

@node plplot_canvas_use_pixmap; Sets pixmap usage_, plplot_canvas_use_persistence; Sets persistence of subsequent drawing operations_, plplot_canvas_use_text; Sets text handling_, PlplotCanvas API
@subsubsection   plplot_canvas_use_pixmap: Sets pixmap usage.  


@quotation

@t{@b{void plplot_canvas_use_pixmap}(@i{canvas}, @i{use_pixmap});}
@end quotation

Sets whether lines and shades are drawn to a pixmap,
or instead as vector graphics.

Lines and shade drawn to the pixmap are not anti-aliased, and so may
appear pixelated. Vector graphics are fully anti-aliased, but are
rendered at a slower speed.

@table @asis

@item   @code{canvas}   (@samp{PlplotCanvas*}, input)  
The PlplotCanvas to set.

@item   @code{use_pixmap}   (@samp{gboolean}, input)  
TRUE to use pixmap (default), FALSE for vector graphics instead.
@end table

@node plplot_canvas_use_persistence; Sets persistence of subsequent drawing operations_, plplot_canvas_get_stream_number; Retrieves the PLplot stream number_, plplot_canvas_use_pixmap; Sets pixmap usage_, PlplotCanvas API
@subsubsection   plplot_canvas_use_persistence: Sets persistence  of subsequent drawing operations.  


@quotation

@t{@b{
void plplot_canvas_use_persistence
}(@i{canvas}, @i{use_persistence});}
@end quotation

Sets whether the subsequent drawing commands are persistent,
or refreshed when the PLplot page is advanced. This feature
is useful for plot animations, because the axes can be persistent
rather than redrawn for each frame.

Note that lines that are persistent are always anti-aliased and
drawn at the front.

@table @asis

@item   @code{canvas}   (@samp{PlplotCanvas*}, input)  
The PlplotCanvas to set.

@item   @code{use_persistence}   (@samp{gboolean}, input)  
TRUE for persistence, FALSE for erasing at new page (default).
@end table

@node plplot_canvas_get_stream_number; Retrieves the PLplot stream number_, , plplot_canvas_use_persistence; Sets persistence of subsequent drawing operations_, PlplotCanvas API
@subsubsection   plplot_canvas_get_stream_number: Retrieves the  PLplot stream number.  


@quotation

@t{@b{
PLINT plplot_canvas_get_stream_number
}(@i{canvas});}
@end quotation

Returns the stream number for the given Canvas. Although the 
concept of streams that exists in the standard PLplot API is not
used here, the stream number provides a unique ID number for
the given PlplotCanvas widget.

@table @asis

@item   @code{canvas}  (@samp{PlplotCanvas*}, input)  
The canvas to retrieve the stream number from.
@end table

@node PlplotCanvas Examples, , PlplotCanvas API, The PlplotCanvas Widget for Gnome/GTK Applications
@subsection PlplotCanvas Examples

Two example programs are provided that demonstrate the use of the
PlplotCanvas widget. They are:

@itemize @bullet{}

@item
plplotcanvas_demo: Demonstrates the basic usage of the 
PlplotCanvas to embed a plot in a Gnome application.

@item
plplotcanvas_animation: Demonstrates advanced multi-threaded 
dual-stream usage of the PlplotCanvas.
@end itemize

The code from plplotcanvas_demo.c is given below, and is explained
in what follows.

@example


#include <plplotcanvas.h>
#include <gtk/gtk.h>

/* The width and height of the plplot canvas widget */
#define WIDTH 1000 /* 500 */
#define HEIGHT 600 /* 300 */

/* Delete event callback */
gint delete_event( GtkWidget *widget,GdkEvent *event,gpointer data ) @{
  return FALSE;
@}

/* Destroy event calback */
void destroy(GtkWidget *widget,gpointer data) @{
  gtk_main_quit ();
@}


int main(int argc,char *argv[] )
@{

  PlplotCanvas* canvas;
  GtkWidget *window;

  /* Parse the options */
  plparseopts(&argc, argv, PL_PARSE_FULL);

  /* The data to plot */
  double x[11] = @{0,1,2,3,4,5,6,7,8,9,10@};
  double y[11] = @{0,0.1,0.4,0.9,1.6,2.6,3.6,4.9,6.4,8.1,10@};

  /* Initialize gtk and the glib type system */
  gtk_init(&argc, &argv);
  g_type_init();

  /* Create the canvas and set its size; during the creation process,
   * the gcw driver is loaded into plplot, and plinit() is invoked.
   */
  canvas=plplot_canvas_new(TRUE);
  plplot_canvas_set_size(canvas,WIDTH,HEIGHT);

  /* Create a new window and stuff the canvas into it */
  window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
  gtk_container_set_border_width(GTK_CONTAINER(window),10);
  gtk_container_add(GTK_CONTAINER(window),GTK_WIDGET(canvas));

  /* Connect the signal handlers to the window decorations */
  g_signal_connect(G_OBJECT(window),"delete_event",
		   G_CALLBACK(delete_event),NULL);
  g_signal_connect(G_OBJECT(window),"destroy",G_CALLBACK(destroy),NULL);

  /* Display everything */
  gtk_widget_show_all(window);

  /* Draw on the canvas with Plplot */
  plplot_canvas_pladv(canvas,0); /* Advance to first page */
  plplot_canvas_plcol0(canvas,15); /* Set color to black */
  plplot_canvas_plwid(canvas,2); /* Set the pen width */
  plplot_canvas_plvsta(canvas); /* Set the viewport */
  plplot_canvas_plwind(canvas,0.,10.,0.,10.); /* Set the window */
  plplot_canvas_plbox(canvas,"bcnst",0.,0,"bcnstv",0.,0); /* Set the box */
  plplot_canvas_pllab(canvas,"x-axis","y-axis","A Simple Plot"); /* Draw some labels */

  /* Draw the line */
  plplot_canvas_plcol0(canvas,1); /* Set the pen color */
  plplot_canvas_plline(canvas,11,x,y);

  /* Advancing the page finalizes this plot */
  plplot_canvas_pladv(canvas,0);

  /* Start the gtk main loop */
  gtk_main();
@}
@end example

So, what's going on here? After the preliminaries, the GTK and the 
GLib type system are initialized by calls to 
@code{gtk_init} and @code{g_type_init}. 
A PlplotCanvas is created using 
@code{plplot_canvas_new}, and it's size is set using 
@code{plplot_canvas_set_size}. 

Next, a window is created (@code{gtk_window_new}), 
the border is set (@code{gtk_set_border_width}), 
and the canvas is stuffed into the window 
(@code{gtk_container_add}). 

Callback functions are installed using 
@code{g_signal_connect} so that the window 
decorations respond. The window is set to display everything using
@code{gtk_widget_show_all}.

Now come the PLplot analogue commands. First, the page using is
advanced using @code{plplot_canvas_pladv}. The pen 
color and width are set with @code{plplot_canvas_plcol0} 
and @code{plplot_canvas_plwid},respectively. The PLplot
viewport, window, box and labels are created using 
@code{plplot_canvas_plvpor}, 
@code{plplot_canvas_plwind}, 
@code{plplot_canvas_plbox} and 
@code{plplot_canvas_pllab}, respectively. A line is 
drawn on the canvas using @code{plplot_canvas_plline}, 
the page is advanced with @code{plplot_canvas_pladv}.

Finally, the GTK main loop is entered using 
@code{gtk_main}, where it resides until the program
is exited.

@node Using PLplot from Perl, Using PLplot from Python, Embedding Plots in Graphical User Interfaces, Top
@chapter Using PLplot from Perl

There are no proper bindings for the Perl language delivered with the
PLplot sources. However, a PLplot interface has been added to the Perl
Data Language (PDL) since version 2.4.0. If the PLplot library is
installed in the system, it is automatically detected by the PDL
configuration script, such that PLplot support for PDL should work out
of the box. For further informations see the @uref{http://pdl.perl.org,PDL homepage}. Here is an usage
example:


@example

use PDL;
use PDL::Graphics::PLplot;

$x = pdl (0..5);
$y = $x ** 2;

plsdev ("xwin");
plinit ();
plcol0 (1);

plenv (-0.5, 5.5, -1, 26, 0, 0);
plline ($x, $y);

plend ();
    
@end example

There is also a Perl PLplot interface on @uref{http://www.cpan.org,CPAN} which is not dependent on PDL.
The Perl module is called @uref{http://search.cpan.org/%7Etjenness/,Graphics::PLplot} and is
appropriate for small data arrays. The API is very similar to the C
API except that if the number of elements in an array is required by
the C function the perl interface calculates it automatically. Also,
return values are returned and not supplied as arguments. Here is the
PDL example above translated to Graphics::PLplot:


@example

use Graphics::PLplot qw/ :all /;

@@x = (0..5);
@@y = map @{$_ * $_@} @@x;

plsdev ("xwin");
plinit ();
plcol0 (1);

plenv (-0.5, 5.5, -1, 26, 0, 0);
plline (\@@x, \@@y);

plend ();
      
@end example

@node Using PLplot from Python, Bibliography, Using PLplot from Perl, Top
@chapter Using PLplot from Python

NEEDS DOCUMENTATION, but here is the short story. We currently (February,
2001) have
switched to dynamic loading of plplot following the generic method given
in the python documentation. Most (???) of the PLplot common API
has been implemented. (For a complete list see plmodules.c and plmodules2.c).
With this dynamic method all the xw??.py examples
work fine and should be consulted for the best way to use PLplot from python.
You may have to set PYTHONPATH to the path where plmodule.so is located
(or eventually installed). For more information see examples/python/README

pytkdemo and the x??.py examples it loads use the plframe widget. Thus,
this method does not currently work under
dynamic loading. They have only worked in the past using the static method
with much hacking and rebuilding of python itself. We plan to try dynamic
loading of all of PLplot (not just the plmodule.c and plmodule2.c wrappers)
including plframe (or a python-variant of this widget) into python at some
future date to see whether it is possible to get pytkdemo and the
x??.py examples working
under dynamic loading, but only the individual stand-alone xw??.py demos
work at the moment.

@node Bibliography, The Common API for PLplot, Using PLplot from Python, Top
@chapter Bibliography

These articles are descriptions of PLplot itself or else scientific
publications whose figures were generated with PLplot.

@menu
* References::
@end menu

@node References, , , Bibliography
@section References

Furnish G.,
Das Graphikpaket PLplot (in German)
(http://www.linux-magazin.de/ausgabe/1996/12/Plplot/plplot.html),
@i{Linux Magazin},
1996 December

Furnish G.,
Horton W.,
Kishimoto Y.,
LeBrun M.,
Tajima T.,
Global Gyrokinetic Simulation of Tokamak
Transport,
@i{Physics of Plasmas},
6,
1,
1999

Irwin A.W.,
Fukushima T.,
A Numerical Time Ephemeris of the Earth,
@i{Astronomy and Astrophysics},
348,
642,
1999

LeBrun M.J.,
Tajima T.,
Gray M.,
Furnish G.,
Horton W.,
Toroidal Effects on Drift-Wave Turbulence,
@i{Physics of Fluids},
B5,
752,
1993

@node The Common API for PLplot, The Specialized C API for PLplot, Bibliography, Top
@chapter The Common API for PLplot

The purpose of this chapter is to document the API for every C function in
PLplot that should have a counterpart in other PLplot language bindings such as
Fortran. These common API routines have a special
c_ prefix name assigned to them in @file{plplot.h}.
This common API between the various languages constitutes the
most important part of the PLplot API that programmers need to know.
Additional PLplot API specialized for each language binding is documented
in @ref{The Specialized C API for PLplot,,The Specialized C API for PLplot}. and subsequent chapters.

All common API functions of the current CVS HEAD are listed here with their
arguments except for obsolete/deprecated API which is listed in @ref{Obsolete/Deprecated API for PLplot,,Obsolete/Deprecated API for PLplot}..
All functions have a short description, and all parameters are documented.

@menu
* pl_setcontlabelformat; Set format of numerical label for contours::
* pl_setcontlabelparam; Set parameters of contour labelling other than format of numerical label::
* pladv; Advance the [sub-]page::
* plaxes; Draw a box with axes; etc_ with arbitrary origin::
* plbin; Plot a histogram from binned data::
* plbop; Begin a new page::
* plbox; Draw a box with axes; etc::
* plbox3; Draw a box with axes; etc; in 3-d::
* plcalc_world; Calculate world coordinates and corresponding window index from relative device coordinates::
* plclear; Clear current [sub]page::
* plcol0; Set color; map0::
* plcol1; Set color; map1::
* plcont; Contour plot::
* plcpstrm; Copy state parameters from the reference stream to the current stream::
* plend; End plotting session::
* plend1; End plotting session for current stream::
* plenv0; Same as plenv but if in multiplot mode does not advance the subpage; instead clears it_::
* plenv; Set up standard window and draw box::
* pleop; Eject current page::
* plerrx; Draw x error bar::
* plerry; Draw y error bar::
* plfamadv; Advance to the next family file on the next new page::
* plfill; Draw filled polygon::
* plfill3; Draw filled polygon in 3D::
* plflush; Flushes the output stream::
* plfont; Set character font::
* plfontld; Load character font::
* plgchr; Get character default height and current [scaled] height::
* plgcol0; Returns 8-bit RGB values for given color from color map0::
* plgcolbg; Returns the background color [cmap0[0]] by 8-bit RGB value::
* plgcompression; Get the current device-compression setting::
* plgdev; Get the current device [keyword] name::
* plgdidev; Get parameters that define current device-space window::
* plgdiori; Get plot orientation::
* plgdiplt; Get parameters that define current plot-space window::
* plgfam; Get family file parameters::
* plgfci; Get FCI [font characterization integer]::
* plgfnam; Get output file name::
* plglevel; Get the [current] run level::
* plgpage; Get page parameters::
* plgra; Switch to graphics screen::
* plgriddata; Grid data from irregularly sampled data::
* plgspa; Get current subpage parameters::
* plgstrm; Get current stream number::
* plgver; Get the current library version number::
* plgvpd; Get viewport limits in normalized device coordinates::
* plgvpw; Get viewport limits in world coordinates::
* plgxax; Get x axis parameters::
* plgyax; Get y axis parameters::
* plgzax; Get z axis parameters::
* plhist; Plot a histogram from unbinned data::
* plhlsrgb; Convert HLS color to RGB::
* plinit; Initialize PLplot::
* pljoin; Draw a line between two points::
* pllab; Simple routine to write labels::
* pllightsource; Sets the 3D position of the light source::
* plline; Draw a line::
* plline3; Draw a line in 3 space::
* pllsty; Select line style::
* plmesh; Plot surface mesh::
* plmeshc; Magnitude colored plot surface mesh with contour_::
* plmkstrm; Creates a new stream and makes it the default::
* plmtex; Write text relative to viewport boundaries::
* plot3d; Plot 3-d surface plot::
* plot3dc; Magnitude colored plot surface with contour_::
* plparseopts; Parse command-line arguments::
* plpat; Set area fill pattern::
* plpoin; Plots a character at the specified points::
* plpoin3; Plots a character at the specified points in 3 space::
* plpoly3; Draw a polygon in 3 space::
* plprec; Set precision in numeric labels::
* plpsty; Select area fill pattern::
* plptex; Write text inside the viewport::
* plreplot; Replays contents of plot buffer to current device/file::
* plrgbhls; Convert RGB color to HLS::
* plschr; Set character size::
* plscmap0; Set color map0 colors by 8-bit RGB values::
* plscmap0n; Set number of colors in color map0::
* plscmap1; Set color map1 colors using 8-bit RGB values::
* plscmap1l; Set color map1 colors using a piece-wise linear relationship::
* plscmap1n; Set number of colors in color map1::
* plscol0; Set a given color from color map0 by 8 bit RGB value::
* plscolbg; Set the background color by 8-bit RGB value::
* plscolor; Used to globally turn color output on/off::
* plscompression; Set device-compression level::
* plsdev; Set the device [keyword] name::
* plsdidev; Set parameters that define current device-space window::
* plsdimap; Set up transformation from metafile coordinates::
* plsdiori; Set plot orientation::
* plsdiplt; Set parameters that define current plot-space window::
* plsdiplz; Set parameters incrementally [zoom mode] that define current plot-space window::
* plsesc; Set the escape character for text strings::
* plsetopt; Set any command-line option::
* plsfam; Set family file parameters::
* plsfci; Set FCI [font characterization integer]::
* plsfnam; Set output file name::
* plshades; Shade regions on the basis of value::
* plshade; Shade individual region on the basis of value::
* plshade1; Shade individual region on the basis of value::
* plsmaj; Set length of major ticks::
* plsmem; Set the memory area to be plotted::
* plsmin; Set length of minor ticks::
* plsori; Set orientation::
* plspage; Set page parameters::
* plspause; Set the pause [on end-of-page] status::
* plsstrm; Set current output stream::
* plssub; Set the number of subpages in x and y::
* plssym; Set symbol size::
* plstar; Initialization::
* plstart; Initialization::
* plstripa; Add a point to a stripchart::
* plstripc; Create a 4-pen stripchart::
* plstripd; Deletes and releases memory used by a stripchart::
* plstyl; Set line style::
* plsurf3d; Plot shaded 3-d surface plot::
* plsvect; Set arrow style for vector plots::
* plsvpa; Specify viewport in absolute coordinates::
* plsxax; Set x axis parameters::
* plsyax; Set y axis parameters::
* plsym; Plots a symbol at the specified points::
* plszax; Set z axis parameters::
* pltext; Switch to text screen::
* plvasp; Specify viewport using aspect ratio only::
* plvect; Vector plot::
* plvpas; Specify viewport using coordinates and aspect ratio::
* plvpor; Specify viewport using coordinates::
* plvsta; Select standard viewport::
* plw3d; Set up window for 3-d plotting::
* plwid; Set pen width::
* plwind; Specify world coordinates of viewport boundaries::
* plxormod; Enter or leave xor mode::
@end menu

@node pl_setcontlabelformat; Set format of numerical label for contours, pl_setcontlabelparam; Set parameters of contour labelling other than format of numerical label, , The Common API for PLplot
@section pl_setcontlabelformat: Set format of numerical label for contours


@quotation

@t{
@b{pl_setcontlabelformat}
(@i{lexp}, @i{sigdig});}
@end quotation

Set format of numerical label for contours.

@table @asis

@item   @code{lexp}  (@samp{PLINT}, input)  
If the contour numerical label is greater than 10^(lexp) or less
than 10^(-lexp), then the
exponential format is used. Default value of lexp is 4.

@item   @code{sigdig}  (@samp{PLINT}, input)  
Number of significant digits. Default value is 2.
@end table

@node pl_setcontlabelparam; Set parameters of contour labelling other than format of numerical label, pladv; Advance the [sub-]page, pl_setcontlabelformat; Set format of numerical label for contours, The Common API for PLplot
@section pl_setcontlabelparam: Set parameters of contour labelling other than format of numerical label


@quotation

@t{
@b{pl_setcontlabelparam}
(@i{offset}, @i{size}, @i{spacing}, @i{active});}
@end quotation

Set parameters of
contour labelling other than those handled by @code{pl_setcontlabelformat} (@pxref{pl_setcontlabelformat; Set format of numerical label for contours}).

@table @asis

@item   @code{offset}  (@samp{PLFLT}, input)  
Offset of label from contour line (if set to 0.0, labels are
printed on the lines). Default value is 0.006.

@item   @code{size}  (@samp{PLFLT}, input)  
Font height for contour labels (normalized). Default value is 0.3.

@item   @code{spacing}  (@samp{PLFLT}, input)  
Spacing parameter for contour labels. Default value is 0.1.

@item   @code{active}  (@samp{PLINT}, input)  
Activate labels. Set to 1 if you want contour labels on.
Default is off (0).
@end table

@node pladv; Advance the [sub-]page, plaxes; Draw a box with axes; etc_ with arbitrary origin, pl_setcontlabelparam; Set parameters of contour labelling other than format of numerical label, The Common API for PLplot
@section pladv: Advance the (sub-)page


@quotation

@t{
@b{pladv}
(@i{sub});}
@end quotation

Advances to the next subpage if
@samp{@code{sub}=0}, performing a page
advance if there are no remaining subpages on the current page. If
subpages aren't being used, @samp{@code{pladv} (@pxref{pladv; Advance the [sub-]page})(0)} will
always advance the page. If
@samp{@code{sub}>0}, PLplot switches
to the specified subpage. Note that this allows you to overwrite a
plot on the specified subpage; if this is not what you intended, use
@code{pleop} (@pxref{pleop; Eject current page}) followed by @code{plbop} (@pxref{plbop; Begin a new page}) to first advance the page. This routine
is called automatically (with
@samp{@code{sub}=0}) by @code{plenv} (@pxref{plenv; Set up standard window and draw box}), but if
@code{plenv} (@pxref{plenv; Set up standard window and draw box}) is not used, @code{pladv} (@pxref{pladv; Advance the [sub-]page}) must be called after initializing PLplot
but before defining the viewport.

@table @asis

@item   @code{sub}  (@samp{PLINT}, input)  
Specifies the subpage number (starting from 1 in the top left
corner and increasing along the rows) to which to advance. Set
to zero to advance to the next subpage.
@end table

@node plaxes; Draw a box with axes; etc_ with arbitrary origin, plbin; Plot a histogram from binned data, pladv; Advance the [sub-]page, The Common API for PLplot
@section   plaxes: Draw a box with axes, etc. with arbitrary origin  


@quotation

@t{
@b{plaxes}
(@i{x0}, @i{y0}, @i{xopt}, @i{xtick}, @i{nxsub}, @i{yopt}, @i{ytick}, @i{nysub});}
@end quotation

Draws a box around the currently defined viewport with arbitrary
world-coordinate origin specified by
@samp{@code{x0}} and
@samp{@code{y0}}
and labels it with world coordinate values appropriate to the
window. Thus @code{plaxes} (@pxref{plaxes; Draw a box with axes; etc_ with arbitrary origin}) should only be called after defining both
viewport and window. The character strings
@samp{@code{xopt}} and
@samp{@code{yopt}} specify how the box
should be drawn as described below. If ticks and/or subticks are to
be drawn for a particular axis, the tick intervals and number of
subintervals may be specified explicitly, or they may be defaulted by
setting the appropriate arguments to zero. 

@table @asis

@item   @code{x0}  (@samp{PLFLT}, input)  
World X coordinate of origin.

@item   @code{y0}  (@samp{PLFLT}, input)  
World Y coordinate of origin.

@item   @code{xopt}  (@samp{const char *}, input)  
Pointer to character string specifying options for horizontal
axis. The string can include any combination of the following
letters (upper or lower case) in any order:

@itemize @bullet{}

@item
@samp{a}: Draws axis, X-axis is horizontal
line (@samp{y=0}), and Y-axis is vertical
line (@samp{x=0}).

@item
@samp{b}: Draws bottom (X) or left (Y) edge
of frame.

@item
@samp{c}: Draws top (X) or right (Y) edge of
frame.

@item
@samp{f}: Always use fixed point numeric labels.

@item
@samp{g}: Draws a grid at the major tick
interval.

@item
@samp{h}: Draws a grid at the minor tick
interval.

@item
@samp{i}: Inverts tick marks, so they are
drawn outwards, rather than inwards.

@item
@samp{l}: Labels axis logarithmically. This
only affects the labels, not the data, and so it is
necessary to compute the logarithms of data points before
passing them to any of the drawing routines.

@item
@samp{m}: Writes numeric labels at major tick
intervals in the unconventional location (above box for
X, right of box for Y).

@item
@samp{n}: Writes numeric labels at major tick
intervals in the conventional location (below box for X,
left of box for Y).

@item
@samp{s}: Enables subticks between major
ticks, only valid if @samp{t} is also
specified.

@item
@samp{t}: Draws major ticks.
@end itemize

@item   @code{xtick}  (@samp{PLFLT}, input)  
World coordinate interval between major ticks on the x axis.
If it is set to zero, PLplot automatically generates a suitable
tick interval.

@item   @code{nxsub}  (@samp{PLINT}, input)  
Number of subintervals between major x axis ticks for minor
ticks. If it is set to zero, PLplot automatically generates a
suitable minor tick interval.

@item   @code{yopt}  (@samp{const char *}, input)  
Pointer to character string specifying options for vertical
axis. The string can include any combination of the letters
defined above for
@samp{@code{xopt}}, and in addition
may contain:

@itemize @bullet{}

@item
@samp{v}: Write numeric labels for vertical
axis parallel to the base of the graph, rather than
parallel to the axis.
@end itemize

@item   @code{ytick}  (@samp{PLFLT}, input)  
World coordinate interval between major ticks on the y axis.
If it is set to zero, PLplot automatically generates a suitable
tick interval.

@item   @code{nysub}  (@samp{PLINT}, input)  
Number of subintervals between major y axis ticks for minor
ticks. If it is set to zero, PLplot automatically generates a
suitable minor tick interval.
@end table

@node plbin; Plot a histogram from binned data, plbop; Begin a new page, plaxes; Draw a box with axes; etc_ with arbitrary origin, The Common API for PLplot
@section   plbin: Plot a histogram from binned data  


@quotation

@t{
@b{plbin}
(@i{nbin}, @i{x}, @i{y}, @i{center});}
@end quotation

Plots a histogram consisting of
@samp{@code{nbin}} bins. The value
associated with the @samp{i}'th bin is placed in
@samp{@code{x}[i]}, and the number of
points in the bin is placed in
@samp{@code{y}[i]}. For proper
operation, the values in
@samp{@code{x}[i]} must form a strictly
increasing sequence. If
@samp{@code{center}=0},
@samp{@code{x}[i]} is the left-hand edge
of the @samp{i}'th bin, and if
@samp{@code{center}=1}, the bin
boundaries are placed midway between the values in the
@samp{@code{x}} array. Also see @code{plhist} (@pxref{plhist; Plot a histogram from unbinned data})
for drawing histograms from unbinned data.

@table @asis

@item   @code{nbin}  (@samp{PLINT}, input)  
Number of bins (i.e., number of values in
@samp{@code{x}} and
@samp{@code{y}} arrays.)

@item   @code{x}  (@samp{PLFLT *}, input)  
Pointer to array containing values associated with bins. These
must form a strictly increasing sequence.

@item   @code{y}  (@samp{PLFLT *}, input)  
Pointer to array containing number of points in bin. This is a
@samp{PLFLT} (instead of @samp{PLINT})
array so as to allow histograms of probabilities, etc.

@item   @code{center}  (@samp{PLINT}, input)  
Indicates whether the values in
@samp{@code{x}} represent the lower
bin boundaries
(@samp{@code{center}=0}) or whether
the bin boundaries are to be midway between the
@samp{@code{x}} values
(@samp{@code{center}=1}). If the
values in @samp{@code{x}} are
equally spaced and
@samp{@code{center}=1}, the values
in @samp{@code{x}} are the center
values of the bins.
@end table

@node plbop; Begin a new page, plbox; Draw a box with axes; etc, plbin; Plot a histogram from binned data, The Common API for PLplot
@section plbop: Begin a new page


@quotation

@t{
@b{plbop}
();}
@end quotation

Begins a new page. For a file driver, the output file is opened if
necessary. Advancing the page via @code{pleop} (@pxref{pleop; Eject current page}) and @code{plbop} (@pxref{plbop; Begin a new page}) is useful when
a page break is desired at a particular point when plotting to
subpages. Another use for @code{pleop} (@pxref{pleop; Eject current page}) and @code{plbop} (@pxref{plbop; Begin a new page}) is when plotting pages
to different files, since you can manually set the file name
by calling @code{plsfnam} (@pxref{plsfnam; Set output file name}) after the call to @code{pleop} (@pxref{pleop; Eject current page}).
(In fact some drivers may only support a single page per file, making
this a necessity.) One way to handle this case automatically is to
page advance via @code{pladv} (@pxref{pladv; Advance the [sub-]page}), but enable familying (see @code{plsfam} (@pxref{plsfam; Set family file parameters})) with a
small limit on the file size so that a new family member file will be
created on each page break.

@node plbox; Draw a box with axes; etc, plbox3; Draw a box with axes; etc; in 3-d, plbop; Begin a new page, The Common API for PLplot
@section plbox: Draw a box with axes, etc


@quotation

@t{
@b{plbox}
(@i{xopt}, @i{xtick}, @i{nxsub}, @i{yopt}, @i{ytick}, @i{nysub});}
@end quotation

Draws a box around the currently defined viewport, and labels it with
world coordinate values appropriate to the window. Thus @code{plbox} (@pxref{plbox; Draw a box with axes; etc})
should only be called after defining both viewport and window. The
character strings @samp{@code{xopt}} and
@samp{@code{yopt}} specify how the box
should be drawn as described below. If ticks and/or subticks are to
be drawn for a particular axis, the tick intervals and number of
subintervals may be specified explicitly, or they may be defaulted by
setting the appropriate arguments to zero.

@table @asis

@item   @code{xopt}  (@samp{const char *}, input)  
Pointer to character string specifying options for horizontal
axis. The string can include any combination of the following
letters (upper or lower case) in any order:

@itemize @bullet{}

@item
@samp{a}: Draws axis, X-axis is horizontal
line (@samp{y=0}), and Y-axis is vertical
line (@samp{x=0}).

@item
@samp{b}: Draws bottom (X) or left (Y) edge
of frame.

@item
@samp{c}: Draws top (X) or right (Y) edge of
frame.

@item
@samp{f}: Always use fixed point numeric labels.

@item
@samp{g}: Draws a grid at the major tick
interval.

@item
@samp{h}: Draws a grid at the minor tick
interval.

@item
@samp{i}: Inverts tick marks, so they are
drawn outwards, rather than inwards.

@item
@samp{l}: Labels axis logarithmically. This
only affects the labels, not the data, and so it is
necessary to compute the logarithms of data points before
passing them to any of the drawing routines.

@item
@samp{m}: Writes numeric labels at major tick
intervals in the unconventional location (above box for
X, right of box for Y).

@item
@samp{n}: Writes numeric labels at major tick
intervals in the conventional location (below box for X,
left of box for Y).

@item
@samp{s}: Enables subticks between major
ticks, only valid if @samp{t} is also
specified.

@item
@samp{t}: Draws major ticks.
@end itemize

@item   @code{xtick}  (@samp{PLFLT}, input)  
World coordinate interval between major ticks on the x axis.
If it is set to zero, PLplot automatically generates a suitable
tick interval.

@item   @code{nxsub}  (@samp{PLINT}, input)  
Number of subintervals between major x axis ticks for minor
ticks. If it is set to zero, PLplot automatically generates a
suitable minor tick interval.

@item   @code{yopt}  (@samp{const char *}, input)  
Pointer to character string specifying options for vertical
axis. The string can include any combination of the letters
defined above for
@samp{@code{xopt}}, and in addition
may contain:

@itemize @bullet{}

@item
@samp{v}: Write numeric labels for vertical
axis parallel to the base of the graph, rather than
parallel to the axis.
@end itemize

@item   @code{ytick}  (@samp{PLFLT}, input)  
World coordinate interval between major ticks on the y axis.
If it is set to zero, PLplot automatically generates a suitable
tick interval.

@item   @code{nysub}  (@samp{PLINT}, input)  
Number of subintervals between major y axis ticks for minor
ticks. If it is set to zero, PLplot automatically generates a
suitable minor tick interval.
@end table

@node plbox3; Draw a box with axes; etc; in 3-d, plcalc_world; Calculate world coordinates and corresponding window index from relative device coordinates, plbox; Draw a box with axes; etc, The Common API for PLplot
@section   plbox3: Draw a box with axes, etc, in 3-d  


@quotation

@t{
@b{plbox3}
(@i{xopt}, @i{xlabel}, @i{xtick}, @i{nxsub}, @i{yopt}, @i{ylabel}, @i{ytick}, @i{nysub}, @i{zopt}, @i{zlabel}, @i{ztick}, @i{nzsub});}
@end quotation

Draws axes, numeric and text labels for a three-dimensional surface
plot. For a more complete description of three-dimensional plotting
see @ref{Three Dimensional Surface Plots,,Three Dimensional Surface Plots}..

@table @asis

@item   @code{xopt}  (@samp{const char *}, input)  
Pointer to character string specifying options for the x axis.
The string can include any combination of the following letters
(upper or lower case) in any order:

@itemize @bullet{}

@item
@samp{b}: Draws axis at base, at height
@samp{z=@code{zmin}} where
@samp{@code{zmin}} is defined
by call to @code{plw3d} (@pxref{plw3d; Set up window for 3-d plotting}). This character must be specified in
order to use any of the other options.

@item
@samp{f}: Always use fixed point numeric labels.

@item
@samp{i}: Inverts tick marks, so they are
drawn downwards, rather than upwards.

@item
@samp{l}: Labels axis logarithmically. This
only affects the labels, not the data, and so it is
necessary to compute the logarithms of data points before
passing them to any of the drawing routines.

@item
@samp{n}: Writes numeric labels at major tick
intervals.

@item
@samp{s}: Enables subticks between major
ticks, only valid if @samp{t} is also
specified.

@item
@samp{t}: Draws major ticks.

@item
@samp{u}: If this is specified, the text
label for the axis is written under the axis.
@end itemize

@item   @code{xlabel}  (@samp{const char *}, input)  
Pointer to character string specifying text label for the x
axis. It is only drawn if @samp{u} is in the
@samp{@code{xopt}} string.

@item   @code{xtick}  (@samp{PLFLT}, input)  
World coordinate interval between major ticks on the x axis.
If it is set to zero, PLplot automatically generates a suitable
tick interval.

@item   @code{nxsub}  (@samp{PLINT}, input)  
Number of subintervals between major x axis ticks for minor
ticks. If it is set to zero, PLplot automatically generates a
suitable minor tick interval.

@item   @code{yopt}  (@samp{const char *}, input)  
Pointer to character string specifying options for the y axis.
The string is interpreted in the same way as
@samp{@code{xopt}}.

@item   @code{ylabel}  (@samp{const char *}, input)  
Pointer to character string specifying text label for the y
axis. It is only drawn if @samp{u} is in the
@samp{@code{yopt}} string.

@item   @code{ytick}  (@samp{PLFLT}, input)  
World coordinate interval between major ticks on the y axis.
If it is set to zero, PLplot automatically generates a suitable
tick interval.

@item   @code{nysub}  (@samp{PLINT}, input)  
Number of subintervals between major y axis ticks for minor
ticks. If it is set to zero, PLplot automatically generates a
suitable minor tick interval.

@item   @code{zopt}  (@samp{const char *}, input)  
Pointer to character string specifying options for the z axis.
The string can include any combination of the following letters
(upper or lower case) in any order:

@itemize @bullet{}

@item
@samp{b}: Draws z axis to the left of the
surface plot.

@item
@samp{c}: Draws z axis to the right of the
surface plot.

@item
@samp{d}: Draws grid lines parallel to the
x-y plane behind the figure. These lines are not drawn
until after @code{plot3d} (@pxref{plot3d; Plot 3-d surface plot}) or @code{plmesh} (@pxref{plmesh; Plot surface mesh}) are called because of
the need for hidden line removal.

@item
@samp{f}: Always use fixed point numeric labels.

@item
@samp{i}: Inverts tick marks, so they are
drawn away from the center.

@item
@samp{l}: Labels axis logarithmically. This
only affects the labels, not the data, and so it is
necessary to compute the logarithms of data points before
passing them to any of the drawing routines.

@item
@samp{m}: Writes numeric labels at major tick
intervals on the right-hand vertical axis.

@item
@samp{n}: Writes numeric labels at major tick
intervals on the left-hand vertical axis.

@item
@samp{s}: Enables subticks between major
ticks, only valid if @samp{t} is also
specified.

@item
@samp{t}: Draws major ticks.

@item
@samp{u}: If this is specified, the text
label is written beside the left-hand axis.

@item
@samp{v}: If this is specified, the text
label is written beside the right-hand axis.
@end itemize

@item   @code{zlabel}  (@samp{const char *}, input)  
Pointer to character string specifying text label for the z
axis. It is only drawn if @samp{u} or
@samp{v} are in the
@samp{@code{zopt}} string.

@item   @code{ztick}  (@samp{PLFLT}, input)  
World coordinate interval between major ticks on the z axis.
If it is set to zero, PLplot automatically generates a suitable
tick interval.

@item   @code{nzsub}  (@samp{PLINT}, input)  
Number of subintervals between major z axis ticks for minor
ticks. If it is set to zero, PLplot automatically generates a
suitable minor tick interval.
@end table

@node plcalc_world; Calculate world coordinates and corresponding window index from relative device coordinates, plclear; Clear current [sub]page, plbox3; Draw a box with axes; etc; in 3-d, The Common API for PLplot
@section   plcalc_world: Calculate world coordinates and corresponding window index from relative device coordinates  


@quotation

@t{
@b{plcalc_world}
(@i{rx}, @i{ry}, @i{wx}, @i{wy}, @i{window});}
@end quotation

Calculate world coordinates,
@samp{@code{wx}} and
@samp{@code{wy}}, and corresponding
@samp{@code{window}} index
from relative device coordinates,
@samp{@code{rx}} and
@samp{@code{ry}}.

@table @asis

@item   @code{rx}  (@samp{PLFLT}, input)  
Input relative device coordinate (ranging from 0. to 1.) for the
x coordinate.

@item   @code{ry}  (@samp{PLFLT}, input)  
Input relative device coordinate (ranging from 0. to 1.) for the
y coordinate.

@item   @code{wx}  (@samp{PLFLT *}, output)  
Pointer to the returned world coordinate for x corresponding
to the relative device coordinates
@samp{@code{rx}} and
@samp{@code{ry}}.

@item   @code{wy}  (@samp{PLFLT *}, output)  
Pointer to the returned world coordinate for y corresponding
to the relative device coordinates
@samp{@code{rx}} and
@samp{@code{ry}}.

@item   @code{window}  (@samp{PLINT *}, output)  
Pointer to the returned last defined window index that corresponds to the
input relative device coordinates (and the returned world
coordinates). To give some background on the window index,
for each page the initial window index is set to
zero, and each time @code{plwind} (@pxref{plwind; Specify world coordinates of viewport boundaries}) is called within the page, world
and device coordinates are stored for the window and the window
index is incremented. Thus, for a simple page layout with
non-overlapping viewports and one window per viewport,
@samp{@code{window}} corresponds to
the viewport index (in the order which the viewport/windows
were created) of the only viewport/window corresponding to
@samp{@code{rx}} and
@samp{@code{ry}}. However, for
more complicated layouts with potentially overlapping viewports
and possibly more than one window (set of world coordinates) per
viewport, @samp{@code{window}}
and the corresponding output world coordinates
corresponds to the last window created that fulfils the criterion
that the relative device coordinates are inside it. Finally, in
all cases where the input relative device coordinates are not
inside any viewport/window, then
@samp{@code{window}} is set to -1.
@end table

@node plclear; Clear current [sub]page, plcol0; Set color; map0, plcalc_world; Calculate world coordinates and corresponding window index from relative device coordinates, The Common API for PLplot
@section   plclear: Clear current (sub)page  


@quotation

@t{
@b{plclear}
();}
@end quotation

Clears the current page, effectively erasing everything that have
been drawn. This command only works with interactive drivers; if the driver
does not support this, the page is filled with the background color in use.
If the current page is divided into subpages, only the current subpage
is erased. The nth subpage can be selected with @code{pladv} (@pxref{pladv; Advance the [sub-]page})(n).

@node plcol0; Set color; map0, plcol1; Set color; map1, plclear; Clear current [sub]page, The Common API for PLplot
@section   plcol0: Set color, map0  


@quotation

@t{
@b{plcol0}
(@i{color});}
@end quotation

Sets the color for color map0 (see @ref{Color Map0,,Color Map0}.).

@table @asis

@item   @code{color}  (@samp{PLINT}, input)  
Integer representing the color. The defaults at present are
(these may change):

@multitable @columnfractions 0.5 0.5
@item
0 black (default background)@tab 
@item
1 red (default foreground)@tab 
@item
2 yellow@tab 
@item
3 green@tab 
@item
4 aquamarine@tab 
@item
5 pink@tab 
@item
6 wheat@tab 
@item
7 grey@tab 
@item
8 brown@tab 
@item
9 blue@tab 
@item
10 BlueViolet@tab 
@item
11 cyan@tab 
@item
12 turquoise@tab 
@item
13 magenta@tab 
@item
14 salmon@tab 
@item
15 white@tab 
@end multitable

@noindent
Use @code{plscmap0} (@pxref{plscmap0; Set color map0 colors by 8-bit RGB values}) to change the entire map0 color palette and
@code{plscol0} (@pxref{plscol0; Set a given color from color map0 by 8 bit RGB value}) to change an individual color in the map0 color
palette.
@end table

@node plcol1; Set color; map1, plcont; Contour plot, plcol0; Set color; map0, The Common API for PLplot
@section   plcol1: Set color, map1  


@quotation

@t{
@b{plcol1}
(@i{col1});}
@end quotation

Sets the color for color map1 (see @ref{Color Map1,,Color Map1}.). 

@table @asis

@item   @code{col1}  (@samp{PLFLT}, input)  
This value must be in the range from 0. to 1. and is mapped to
color using the continuous map1 color palette which by default
ranges from blue to the background color to red. The map1
palette can also be straightforwardly changed by the user with
@code{plscmap1} (@pxref{plscmap1; Set color map1 colors using 8-bit RGB values}) or @code{plscmap1l} (@pxref{plscmap1l; Set color map1 colors using a piece-wise linear relationship}).
@end table

@node plcont; Contour plot, plcpstrm; Copy state parameters from the reference stream to the current stream, plcol1; Set color; map1, The Common API for PLplot
@section   plcont: Contour plot  


@quotation

@t{
@b{plcont}
(@i{z}, @i{nx}, @i{ny}, @i{kx}, @i{lx}, @i{ky}, @i{ly}, @i{clevel}, @i{nlevel}, @i{pltr}, @i{pltr_data});}
@end quotation

Draws a contour plot of the data in
@samp{@code{z}[@code{nx}][@code{ny}]},
using the @samp{@code{nlevel}} contour
levels specified by @samp{@code{clevel}}.
Only the region of the array from
@samp{@code{kx}} to
@samp{@code{lx}} and from
@samp{@code{ky}} to
@samp{@code{ly}} is plotted out. A
transformation routine pointed to by @samp{@code{pltr}}
with a pointer @samp{@code{pltr_data}}
for additional data required by the transformation routine
is used to map indices within the array
to the world coordinates. See the following discussion of the
arguments and @ref{Contour and Shade Plots,,Contour and Shade Plots}. for
more information.

@table @asis

@item   @code{z}  (@samp{PLFLT **}, input)  
Pointer to a vectored two-dimensional array containing data to
be contoured.

@item   @code{nx, ny}  (@samp{PLINT}, input)  
Physical dimensions of array
@samp{@code{z}}.

@item   @code{kx, lx}  (@samp{PLINT}, input)  
Range of @samp{x} indices to consider.

@item   @code{ky, ly}  (@samp{PLINT}, input)  
Range of @samp{y} indices to consider.

@item   @code{clevel}  (@samp{PLFLT *}, input)  
Pointer to array specifying levels at which to draw contours.

@item   @code{nlevel}  (@samp{PLINT}, input)  
Number of contour levels to draw.

@item   @code{pltr}  (@samp{void (*) (PLFLT, PLFLT, PLFLT *, PLFLT *, PLPointer)  }, input)  
Pointer to function that defines transformation between indices
in array @samp{@code{z}} and the
world coordinates (C only). Transformation functions are
provided in the PLplot library:
@code{pltr0} (@pxref{pltr0; Identity transformation for grid to world mapping}) for identity mapping, and @code{pltr1} (@pxref{pltr1; Linear interpolation for grid to world mapping using singly dimensioned coord arrays}) and @code{pltr2} (@pxref{pltr2; Linear interpolation for grid to world mapping using doubly dimensioned coord arrays [column dominant; as per normal C 2d arrays]}) for
arbitrary mappings respectively defined by one- and
two-dimensional arrays. In addition, user-supplied routines
for the transformation can be used as well. Examples of
all of these approaches are given in
@ref{Contour Plots from C,,Contour Plots from C}..
The transformation function should
have the form given by any of @code{pltr0} (@pxref{pltr0; Identity transformation for grid to world mapping}), @code{pltr1} (@pxref{pltr1; Linear interpolation for grid to world mapping using singly dimensioned coord arrays}), or @code{pltr2} (@pxref{pltr2; Linear interpolation for grid to world mapping using doubly dimensioned coord arrays [column dominant; as per normal C 2d arrays]}).

@item   @code{pltr_data}  (@samp{PLPointer}, input)  
Extra parameter to help
pass information to @code{pltr0} (@pxref{pltr0; Identity transformation for grid to world mapping}), @code{pltr1} (@pxref{pltr1; Linear interpolation for grid to world mapping using singly dimensioned coord arrays}), @code{pltr2} (@pxref{pltr2; Linear interpolation for grid to world mapping using doubly dimensioned coord arrays [column dominant; as per normal C 2d arrays]}), or whatever routine
that is externally supplied.
@end table

@node plcpstrm; Copy state parameters from the reference stream to the current stream, plend; End plotting session, plcont; Contour plot, The Common API for PLplot
@section   plcpstrm: Copy state parameters from the reference stream to the current stream  


@quotation

@t{
@b{plcpstrm}
(@i{iplsr}, @i{flags});}
@end quotation

Copies state parameters from the reference stream to the current stream.
Tell driver interface to map device coordinates unless
@samp{@code{flags} == 1}.

This function is used for making save files of selected plots (e.g.
from the TK driver). After initializing, you can get a copy of the
current plot to the specified device by switching to this stream and
issuing a @code{plcpstrm} (@pxref{plcpstrm; Copy state parameters from the reference stream to the current stream}) and a @code{plreplot} (@pxref{plreplot; Replays contents of plot buffer to current device/file}), with calls to @code{plbop} (@pxref{plbop; Begin a new page}) and
@code{pleop} (@pxref{pleop; Eject current page}) as appropriate. The plot buffer must have previously been
enabled (done automatically by some display drivers, such as X).

@table @asis

@item   @code{iplsr}  (@samp{PLINT}, input)  
Number of reference stream.

@item   @code{flags}  (@samp{PLINT}, input)  
If @samp{@code{flags}} is set to 1
the device coordinates are @i{not} copied from the reference to current
stream.
@end table

@node plend; End plotting session, plend1; End plotting session for current stream, plcpstrm; Copy state parameters from the reference stream to the current stream, The Common API for PLplot
@section   plend: End plotting session  


@quotation

@t{
@b{plend}
();}
@end quotation

Ends a plotting session, tidies up all the output files, switches
interactive devices back into text mode and frees up any memory that
was allocated. Must be called before end of program.

@node plend1; End plotting session for current stream, plenv0; Same as plenv but if in multiplot mode does not advance the subpage; instead clears it_, plend; End plotting session, The Common API for PLplot
@section   plend1: End plotting session for current stream  


@quotation

@t{
@b{plend1}
();}
@end quotation

Ends a plotting session for the current output stream only. See
@code{plsstrm} (@pxref{plsstrm; Set current output stream}) for more info.

@node plenv0; Same as plenv but if in multiplot mode does not advance the subpage; instead clears it_, plenv; Set up standard window and draw box, plend1; End plotting session for current stream, The Common API for PLplot
@section   plenv0: Same as @code{plenv} but if in multiplot  mode does not advance the subpage, instead clears it.  


@quotation

@t{
@b{plenv0}
(@i{xmin}, @i{xmax}, @i{ymin}, @i{ymax}, @i{just}, @i{axis});}
@end quotation

Sets up plotter environment for simple graphs by calling @code{pladv} (@pxref{pladv; Advance the [sub-]page}) and
setting up viewport and window to sensible default values. @code{plenv0} (@pxref{plenv0; Same as plenv but if in multiplot mode does not advance the subpage; instead clears it_})
leaves enough room around most graphs for axis labels and a title.
When these defaults are not suitable, use the individual routines
@code{plvpas} (@pxref{plvpas; Specify viewport using coordinates and aspect ratio}), @code{plvpor} (@pxref{plvpor; Specify viewport using coordinates}), or @code{plvasp} (@pxref{plvasp; Specify viewport using aspect ratio only}) for setting up the viewport, @code{plwind} (@pxref{plwind; Specify world coordinates of viewport boundaries})
for defining the window, and @code{plbox} (@pxref{plbox; Draw a box with axes; etc}) for drawing the box.

@table @asis

@item   @code{xmin}  (@samp{PLFLT}, input)  
Value of x at left-hand edge of window (in world coordinates).

@item   @code{xmax}  (@samp{PLFLT}, input)  
Value of x at right-hand edge of window (in world coordinates).

@item   @code{ymin}  (@samp{PLFLT}, input)  
Value of y at bottom edge of window (in world coordinates).

@item   @code{ymax}  (@samp{PLFLT}, input)  
Value of y at top edge of window (in world coordinates).

@item   @code{just}  (@samp{PLINT}, input)  
Controls how the axes will be scaled:

@itemize @bullet{}

@item
@samp{-1}: the scales
will not be set, the user must set up the scale before calling
@code{plenv0} (@pxref{plenv0; Same as plenv but if in multiplot mode does not advance the subpage; instead clears it_}) using @code{plsvpa} (@pxref{plsvpa; Specify viewport in absolute coordinates}), @code{plvasp} (@pxref{plvasp; Specify viewport using aspect ratio only}) or other.

@item
@samp{0}: the x and
y axes are scaled independently to use as much of the screen as
possible.

@item
@samp{1}: the scales of
the x and y axes are made equal.

@item
@samp{2}: the axis of
the x and y axes are made equal, and the plot box will be square.
@end itemize

@item   @code{axis}  (@samp{PLINT}, input)  
Controls drawing of the box around the plot:

@itemize @bullet{}

@item
@samp{-2}: draw no box, no tick marks, no
numeric tick labels, no axes.

@item
@samp{-1}: draw box only.

@item
@samp{0}: draw box, ticks, and numeric tick labels.

@item
@samp{1}: also draw coordinate axes at
@samp{x=0} and @samp{y=0}.

@item
@samp{2}: also draw a grid at major tick
positions in both coordinates.

@item
@samp{3}: also draw a grid at minor tick
positions in both coordinates.

@item
@samp{10}: same as 0 except logarithmic
@samp{x} tick marks. (The @samp{x}
data have to be converted to logarithms separately.)

@item
@samp{11}: same as 1 except logarithmic
@samp{x} tick marks. (The @samp{x}
data have to be converted to logarithms separately.)

@item
@samp{12}: same as 2 except logarithmic
@samp{x} tick marks. (The @samp{x}
data have to be converted to logarithms separately.)

@item
@samp{13}: same as 3 except logarithmic
@samp{x} tick marks. (The @samp{x}
data have to be converted to logarithms separately.)

@item
@samp{20}: same as 0 except logarithmic
@samp{y} tick marks. (The @samp{y}
data have to be converted to logarithms separately.)

@item
@samp{21}: same as 1 except logarithmic
@samp{y} tick marks. (The @samp{y}
data have to be converted to logarithms separately.)

@item
@samp{22}: same as 2 except logarithmic
@samp{y} tick marks. (The @samp{y}
data have to be converted to logarithms separately.)

@item
@samp{23}: same as 3 except logarithmic
@samp{y} tick marks. (The @samp{y}
data have to be converted to logarithms separately.)

@item
@samp{30}: same as 0 except logarithmic
@samp{x} and @samp{y} tick marks. (The @samp{x} and @samp{y}
data have to be converted to logarithms separately.)

@item
@samp{31}: same as 1 except logarithmic
@samp{x} and @samp{y} tick marks. (The @samp{x} and @samp{y}
data have to be converted to logarithms separately.)

@item
@samp{32}: same as 2 except logarithmic
@samp{x} and @samp{y} tick marks. (The @samp{x} and @samp{y}
data have to be converted to logarithms separately.)

@item
@samp{33}: same as 3 except logarithmic
@samp{x} and @samp{y} tick marks. (The @samp{x} and @samp{y}
data have to be converted to logarithms separately.)
@end itemize
@end table

@node plenv; Set up standard window and draw box, pleop; Eject current page, plenv0; Same as plenv but if in multiplot mode does not advance the subpage; instead clears it_, The Common API for PLplot
@section   plenv: Set up standard window and draw box  


@quotation

@t{
@b{plenv}
(@i{xmin}, @i{xmax}, @i{ymin}, @i{ymax}, @i{just}, @i{axis});}
@end quotation

Sets up plotter environment for simple graphs by calling @code{pladv} (@pxref{pladv; Advance the [sub-]page}) and
setting up viewport and window to sensible default values. @code{plenv} (@pxref{plenv; Set up standard window and draw box})
leaves enough room around most graphs for axis labels and a title.
When these defaults are not suitable, use the individual routines
@code{plvpas} (@pxref{plvpas; Specify viewport using coordinates and aspect ratio}), @code{plvpor} (@pxref{plvpor; Specify viewport using coordinates}), or @code{plvasp} (@pxref{plvasp; Specify viewport using aspect ratio only}) for setting up the viewport, @code{plwind} (@pxref{plwind; Specify world coordinates of viewport boundaries})
for defining the window, and @code{plbox} (@pxref{plbox; Draw a box with axes; etc}) for drawing the box.

@table @asis

@item   @code{xmin}  (@samp{PLFLT}, input)  
Value of x at left-hand edge of window (in world coordinates).

@item   @code{xmax}  (@samp{PLFLT}, input)  
Value of x at right-hand edge of window (in world coordinates).

@item   @code{ymin}  (@samp{PLFLT}, input)  
Value of y at bottom edge of window (in world coordinates).

@item   @code{ymax}  (@samp{PLFLT}, input)  
Value of y at top edge of window (in world coordinates).

@item   @code{just}  (@samp{PLINT}, input)  
Controls how the axes will be scaled:

@itemize @bullet{}

@item
@samp{-1}: the scales
will not be set, the user must set up the scale before calling
@code{plenv} (@pxref{plenv; Set up standard window and draw box}) using @code{plsvpa} (@pxref{plsvpa; Specify viewport in absolute coordinates}), @code{plvasp} (@pxref{plvasp; Specify viewport using aspect ratio only}) or other.

@item
@samp{0}: the x and
y axes are scaled independently to use as much of the screen as
possible.

@item
@samp{1}: the scales of
the x and y axes are made equal.

@item
@samp{2}: the axis of
the x and y axes are made equal, and the plot box will be square.
@end itemize

@item   @code{axis}  (@samp{PLINT}, input)  
Controls drawing of the box around the plot:

@itemize @bullet{}

@item
@samp{-2}: draw no box, no tick marks, no
numeric tick labels, no axes.

@item
@samp{-1}: draw box only.

@item
@samp{0}: draw box, ticks, and numeric tick labels.

@item
@samp{1}: also draw coordinate axes at
@samp{x=0} and @samp{y=0}.

@item
@samp{2}: also draw a grid at major tick
positions in both coordinates.

@item
@samp{3}: also draw a grid at minor tick
positions in both coordinates.

@item
@samp{10}: same as 0 except logarithmic
@samp{x} tick marks. (The @samp{x}
data have to be converted to logarithms separately.)

@item
@samp{11}: same as 1 except logarithmic
@samp{x} tick marks. (The @samp{x}
data have to be converted to logarithms separately.)

@item
@samp{12}: same as 2 except logarithmic
@samp{x} tick marks. (The @samp{x}
data have to be converted to logarithms separately.)

@item
@samp{13}: same as 3 except logarithmic
@samp{x} tick marks. (The @samp{x}
data have to be converted to logarithms separately.)

@item
@samp{20}: same as 0 except logarithmic
@samp{y} tick marks. (The @samp{y}
data have to be converted to logarithms separately.)

@item
@samp{21}: same as 1 except logarithmic
@samp{y} tick marks. (The @samp{y}
data have to be converted to logarithms separately.)

@item
@samp{22}: same as 2 except logarithmic
@samp{y} tick marks. (The @samp{y}
data have to be converted to logarithms separately.)

@item
@samp{23}: same as 3 except logarithmic
@samp{y} tick marks. (The @samp{y}
data have to be converted to logarithms separately.)

@item
@samp{30}: same as 0 except logarithmic
@samp{x} and @samp{y} tick marks. (The @samp{x} and @samp{y}
data have to be converted to logarithms separately.)

@item
@samp{31}: same as 1 except logarithmic
@samp{x} and @samp{y} tick marks. (The @samp{x} and @samp{y}
data have to be converted to logarithms separately.)

@item
@samp{32}: same as 2 except logarithmic
@samp{x} and @samp{y} tick marks. (The @samp{x} and @samp{y}
data have to be converted to logarithms separately.)

@item
@samp{33}: same as 3 except logarithmic
@samp{x} and @samp{y} tick marks. (The @samp{x} and @samp{y}
data have to be converted to logarithms separately.)
@end itemize
@end table

@node pleop; Eject current page, plerrx; Draw x error bar, plenv; Set up standard window and draw box, The Common API for PLplot
@section   pleop: Eject current page  


@quotation

@t{
@b{pleop}
();}
@end quotation

Clears the graphics screen of an interactive device, or ejects a page
on a plotter. See @code{plbop} (@pxref{plbop; Begin a new page}) for more information.

@node plerrx; Draw x error bar, plerry; Draw y error bar, pleop; Eject current page, The Common API for PLplot
@section   plerrx: Draw x error bar  


@quotation

@t{
@b{plerrx}
(@i{n}, @i{xmin}, @i{xmax}, @i{y});}
@end quotation

Draws a set of @samp{@code{n}}
horizontal error bars, the
@samp{i}'th error
bar extending from @samp{@code{xmin}[i]}
to @samp{@code{xmax}[i]} at y coordinate
@samp{@code{y}[i]}. The terminals of the error bar are of length equal to the
minor tick length (settable using @code{plsmin} (@pxref{plsmin; Set length of minor ticks})).

@table @asis

@item   @code{n}  (@samp{PLINT}, input)  
Number of error bars to draw.

@item   @code{xmin}  (@samp{PLFLT *}, input)  
Pointer to array with x coordinates of
left-hand endpoint of error bars.

@item   @code{xmax}  (@samp{PLFLT *}, input)  
Pointer to array with x coordinates of
right-hand endpoint of error bars.

@item   @code{y}  (@samp{PLFLT *}, input)  
Pointer to array with y coordinates of
error bar.
@end table

@node plerry; Draw y error bar, plfamadv; Advance to the next family file on the next new page, plerrx; Draw x error bar, The Common API for PLplot
@section   plerry: Draw y error bar  


@quotation

@t{
@b{plerry}
(@i{n}, @i{x}, @i{ymin}, @i{ymax});}
@end quotation

Draws a set of @samp{@code{n}} vertical
error bars, the @samp{i}'th error bar extending from
@samp{@code{ymin}[i]} to
@samp{@code{ymax}[i]} at x coordinate
@samp{@code{x}[i]}. The terminals of the
error bar are of length equal to the minor tick length (settable
using @code{plsmin} (@pxref{plsmin; Set length of minor ticks})).

@table @asis

@item   @code{n}  (@samp{PLINT}, input)  
Number of error bars to draw.

@item   @code{x}  (@samp{PLFLT *}, input)  
Pointer to array with x coordinates of error bars.

@item   @code{ymin}  (@samp{PLFLT *}, input)  
Pointer to array with y coordinates of lower endpoint of error
bars.

@item   @code{ymax}  (@samp{PLFLT *}, input)  
Pointer to array with y coordinate of upper endpoint of error
bar.
@end table

@node plfamadv; Advance to the next family file on the next new page, plfill; Draw filled polygon, plerry; Draw y error bar, The Common API for PLplot
@section   plfamadv: Advance to the next family file on the next new page  


@quotation

@t{
@b{plfamadv}
();}
@end quotation

Advance to the next family file on the next new page.

@node plfill; Draw filled polygon, plfill3; Draw filled polygon in 3D, plfamadv; Advance to the next family file on the next new page, The Common API for PLplot
@section   plfill: Draw filled polygon  


@quotation

@t{
@b{plfill}
(@i{n}, @i{x}, @i{y});}
@end quotation

Fills the polygon defined by the
@samp{@code{n}} points
@samp{(@code{x}[i],
@code{y}[i])} using the pattern defined by
@code{plpsty} (@pxref{plpsty; Select area fill pattern}) or @code{plpat} (@pxref{plpat; Set area fill pattern}). The routine will automatically close the
polygon between the last and first vertices. If multiple closed
polygons are passed in @samp{@code{x}}
and @samp{@code{y}} then @code{plfill} (@pxref{plfill; Draw filled polygon}) will
fill in between them.

@table @asis

@item   @code{n}  (@samp{PLINT}, input)  
Number of vertices in polygon.

@item   @code{x}  (@samp{PLFLT *}, input)  
Pointer to array with x coordinates of vertices.

@item   @code{y}  (@samp{PLFLT *}, input)  
Pointer to array with y coordinates of vertices.
@end table

@node plfill3; Draw filled polygon in 3D, plflush; Flushes the output stream, plfill; Draw filled polygon, The Common API for PLplot
@section   plfill3: Draw filled polygon in 3D  


@quotation

@t{
@b{plfill3}
(@i{n}, @i{x}, @i{y}, @i{z});}
@end quotation

Fills the 3D polygon defined by the
@samp{@code{n}} points in the
@samp{@code{x}},
@samp{@code{y}}, and
@samp{@code{z}} arrays
using the pattern defined by
@code{plpsty} (@pxref{plpsty; Select area fill pattern}) or @code{plpat} (@pxref{plpat; Set area fill pattern}). The routine will automatically close the
polygon between the last and first vertices. If multiple closed
polygons are passed in @samp{@code{x}},
@samp{@code{y}},
and @samp{@code{z}} then @code{plfill3} (@pxref{plfill3; Draw filled polygon in 3D}) will
fill in between them.

@table @asis

@item   @code{n}  (@samp{PLINT}, input)  
Number of vertices in polygon.

@item   @code{x}  (@samp{PLFLT *}, input)  
Pointer to array with x coordinates of vertices.

@item   @code{y}  (@samp{PLFLT *}, input)  
Pointer to array with y coordinates of vertices.

@item   @code{z}  (@samp{PLFLT *}, input)  
Pointer to array with z coordinates of vertices.
@end table

@node plflush; Flushes the output stream, plfont; Set character font, plfill3; Draw filled polygon in 3D, The Common API for PLplot
@section   plflush: Flushes the output stream  


@quotation

@t{
@b{plflush}
();}
@end quotation

Flushes the output stream. Use sparingly, if at all.

@node plfont; Set character font, plfontld; Load character font, plflush; Flushes the output stream, The Common API for PLplot
@section   plfont: Set character font  


@quotation

@t{
@b{plfont}
(@i{font});}
@end quotation

Sets the default character font for subsequent character drawing.
Also affects symbols produced by @code{plpoin} (@pxref{plpoin; Plots a character at the specified points}). This routine has no
effect unless the extended character set is loaded (see @code{plfontld} (@pxref{plfontld; Load character font})).

@table @asis

@item   @code{font}  (@samp{PLINT}, input)  
Specifies the font:

@itemize @bullet{}

@item
@samp{1}: Normal font (simplest and fastest)

@item
@samp{2}: Roman font

@item
@samp{3}: Italic font

@item
@samp{4}: Script font
@end itemize
@end table

@node plfontld; Load character font, plgchr; Get character default height and current [scaled] height, plfont; Set character font, The Common API for PLplot
@section   plfontld: Load character font  


@quotation

@t{
@b{plfontld}
(@i{set});}
@end quotation

Sets the character set to use for subsequent character drawing. May
be called before calling initializing PLplot.

@table @asis

@item   @code{set}  (@samp{PLINT}, input)  
Specifies the character set to load:

@itemize @bullet{}

@item
@samp{0}: Standard character set

@item
@samp{1}: Extended character set
@end itemize
@end table

@node plgchr; Get character default height and current [scaled] height, plgcol0; Returns 8-bit RGB values for given color from color map0, plfontld; Load character font, The Common API for PLplot
@section   plgchr: Get character default height and current (scaled) height  


@quotation

@t{
@b{plgchr}
(@i{p_def}, @i{p_ht});}
@end quotation

Get character default height and current (scaled) height.

@table @asis

@item   @code{p_def}  (@samp{PLFLT *}, output)  
Pointer to default character height (mm).

@item   @code{p_ht}  (@samp{PLFLT *}, output)  
Pointer to current (scaled) character height (mm).
@end table

@node plgcol0; Returns 8-bit RGB values for given color from color map0, plgcolbg; Returns the background color [cmap0[0]] by 8-bit RGB value, plgchr; Get character default height and current [scaled] height, The Common API for PLplot
@section   plgcol0: Returns 8-bit RGB values for given color from color map0  


@quotation

@t{
@b{plgcol0}
(@i{icol0}, @i{r}, @i{g}, @i{b});}
@end quotation

Returns 8-bit RGB values (-255) for given color from color map0 (see
@ref{Color Map0,,Color Map0}.). Values are
negative if an invalid color id is given.

@table @asis

@item   @code{icol0}  (@samp{PLINT}, input)  
Index of desired cmap0 color.

@item   @code{r}  (@samp{PLINT *}, output)  
Pointer to 8-bit red value.

@item   @code{g}  (@samp{PLINT *}, output)  
Pointer to 8-bit green value.

@item   @code{b}  (@samp{PLINT *}, output)  
Pointer to 8-bit blue value.
@end table

@node plgcolbg; Returns the background color [cmap0[0]] by 8-bit RGB value, plgcompression; Get the current device-compression setting, plgcol0; Returns 8-bit RGB values for given color from color map0, The Common API for PLplot
@section   plgcolbg: Returns the background color (cmap0[0]) by 8-bit RGB value  


@quotation

@t{
@b{plgcolbg}
(@i{r}, @i{g}, @i{b});}
@end quotation

Returns the background color (cmap0[0]) by 8-bit RGB value.

@table @asis

@item   @code{r}  (@samp{PLINT *}, output)  
Pointer to an unsigned 8-bit integer (0-255) representing
the degree of red in the color.

@item   @code{g}  (@samp{PLINT *}, output)  
Pointer to an unsigned 8-bit integer (0-255) representing
the degree of green in the color.

@item   @code{b}  (@samp{PLINT *}, output)  
Pointer to an unsigned 8-bit integer (0-255) representing
the degree of blue in the color.
@end table

@node plgcompression; Get the current device-compression setting, plgdev; Get the current device [keyword] name, plgcolbg; Returns the background color [cmap0[0]] by 8-bit RGB value, The Common API for PLplot
@section   plgcompression: Get the current  device-compression setting  


@quotation

@t{
@b{plgcompression}
(@i{compression});}
@end quotation

Get the current device-compression setting. This parameter is
only used for drivers that provide compression.

@table @asis

@item   @code{compression}  (@samp{PLINT *}, output)  
Pointer to a variable to be filled with the current
device-compression setting.
@end table

@node plgdev; Get the current device [keyword] name, plgdidev; Get parameters that define current device-space window, plgcompression; Get the current device-compression setting, The Common API for PLplot
@section   plgdev: Get the current device (keyword) name  


@quotation

@t{
@b{plgdev}
(@i{p_dev});}
@end quotation

Get the current device (keyword) name. Note: you
@i{must} have allocated
space for this (80 characters is safe).

@table @asis

@item   @code{p_dev}  (@samp{char *}, output)  
Pointer to device (keyword) name string.
@end table

@node plgdidev; Get parameters that define current device-space window, plgdiori; Get plot orientation, plgdev; Get the current device [keyword] name, The Common API for PLplot
@section   plgdidev: Get parameters that define current  device-space window  


@quotation

@t{
@b{plgdidev}
(@i{p_mar}, @i{p_aspect}, @i{p_jx}, @i{p_jy});}
@end quotation

Get relative margin width, aspect ratio, and relative justification
that define current device-space window.
If @code{plsdidev} (@pxref{plsdidev; Set parameters that define current device-space window}) has not been called the default values pointed to by
@samp{@code{p_mar}},
@samp{@code{p_aspect}},
@samp{@code{p_jx}}, and
@samp{@code{p_jy}}
will all be 0.

@table @asis

@item   @code{p_mar}  (@samp{PLFLT *}, output)  
Pointer to relative margin width.

@item   @code{p_aspect}  (@samp{PLFLT *}, output)  
Pointer to aspect ratio.

@item   @code{p_jx}  (@samp{PLFLT *}, output)  
Pointer to relative justification in x.

@item   @code{p_jy}  (@samp{PLFLT *}, output)  
Pointer to relative justification in y.
@end table

@node plgdiori; Get plot orientation, plgdiplt; Get parameters that define current plot-space window, plgdidev; Get parameters that define current device-space window, The Common API for PLplot
@section   plgdiori: Get plot orientation  


@quotation

@t{
@b{plgdiori}
(@i{p_rot});}
@end quotation

Get plot orientation parameter which is multiplied by 90 degrees to
obtain the angle of rotation. Note, arbitrary rotation parameters
such as 0.2 (corresponding to 18 degrees) are possible, but the usual
values for the rotation parameter are 0., 1., 2., and 3. corresponding
to 0 degrees (landscape mode), 90 degrees (portrait mode), 180 degrees
(seascape mode), and 270 degrees (upside-down mode).
If @code{plsdiori} (@pxref{plsdiori; Set plot orientation}) has not been called the default value pointed to by
@samp{@code{p_rot}}
will be 0.

@table @asis

@item   @code{p_rot}  (@samp{PLFLT *}, output)  
Pointer to orientation parameter.
@end table

@node plgdiplt; Get parameters that define current plot-space window, plgfam; Get family file parameters, plgdiori; Get plot orientation, The Common API for PLplot
@section   plgdiplt: Get parameters that define current  plot-space window  


@quotation

@t{
@b{plgdiplt}
(@i{p_xmin}, @i{p_ymin}, @i{p_xmax}, @i{p_ymax});}
@end quotation

Get relative minima and maxima that define current
plot-space window.
If @code{plsdiplt} (@pxref{plsdiplt; Set parameters that define current plot-space window}) has not been called the default values pointed to by
@samp{@code{p_xmin}},
@samp{@code{p_ymin}},
@samp{@code{p_xmax}}, and
@samp{@code{p_ymax}}
will be 0., 0., 1., and 1.

@table @asis

@item   @code{p_xmin}  (@samp{PLFLT *}, output)  
Pointer to relative minimum in x.

@item   @code{p_ymin}  (@samp{PLFLT *}, output)  
Pointer to relative minimum in y.

@item   @code{p_xmax}  (@samp{PLFLT *}, output)  
Pointer to relative maximum in x.

@item   @code{p_ymax}  (@samp{PLFLT *}, output)  
Pointer to relative maximum in y.
@end table

@node plgfam; Get family file parameters, plgfci; Get FCI [font characterization integer], plgdiplt; Get parameters that define current plot-space window, The Common API for PLplot
@section   plgfam: Get family file parameters  


@quotation

@t{
@b{plgfam}
(@i{fam}, @i{num}, @i{bmax});}
@end quotation

Gets information about current family file, if familying is
enabled. See @ref{Family File Output,,Family File Output}. for more information.

@table @asis

@item   @code{fam}  (@samp{PLINT *}, output)  
Pointer to variable with the Boolean family flag value. If
nonzero, familying is enabled.

@item   @code{num}  (@samp{PLINT *}, output)  
Pointer to variable with the current family file number.

@item   @code{bmax}  (@samp{PLINT *}, output)  
Pointer to variable with the maximum file size (in bytes) for a
family file.
@end table

@node plgfci; Get FCI [font characterization integer], plgfnam; Get output file name, plgfam; Get family file parameters, The Common API for PLplot
@section   plgfci: Get FCI (font characterization integer)  


@quotation

@t{
@b{plgfci}
(@i{fci});}
@end quotation

Gets information about the current font using the FCI approach.
See @ref{FCI,,FCI}. for more information.

@table @asis

@item   @code{fci}  (@samp{PLUNICODE *}, output)  
Pointer to PLUNICODE (unsigned 32-bit integer) variable which
is updated with current FCI value.
@end table

@node plgfnam; Get output file name, plglevel; Get the [current] run level, plgfci; Get FCI [font characterization integer], The Common API for PLplot
@section   plgfnam: Get output file name  


@quotation

@t{
@b{plgfnam}
(@i{fnam});}
@end quotation

Gets the current output file name, if applicable.

@table @asis

@item   @code{fnam}  (@samp{char *}, output)  
Pointer to file name string (a preallocated string of 80 characters or more).
@end table

@node plglevel; Get the [current] run level, plgpage; Get page parameters, plgfnam; Get output file name, The Common API for PLplot
@section   plglevel: Get the (current) run level  


@quotation

@t{
@b{plglevel}
(@i{p_level});}
@end quotation

Get the (current) run level. Valid settings are:

@itemize @bullet{}

@item
0, uninitialized

@item
1, initialized

@item
2, viewport defined

@item
3, world coords defined
@end itemize

@table @asis

@item   @code{p_level}  (@samp{PLINT *}, output)  
Pointer to the run level.
@end table

@node plgpage; Get page parameters, plgra; Switch to graphics screen, plglevel; Get the [current] run level, The Common API for PLplot
@section   plgpage: Get page parameters  


@quotation

@t{
@b{plgpage}
(@i{xp}, @i{yp}, @i{xleng}, @i{yleng}, @i{xoff}, @i{yoff});}
@end quotation

Gets the current page configuration. The parameters are expressed
in units that are specific to the current driver. For instance:
screen drivers will usually interpret them as number of pixels,
whereas printer drivers will usually use mm.

@table @asis

@item   @code{xp}  (@samp{PLFLT *}, output)  
Pointer to number of pixels in x.

@item   @code{yp}  (@samp{PLFLT *}, output)  
Pointer to number of pixels in y.

@item   @code{xleng}  (@samp{PLINT *}, output)  
Pointer to x page length value.

@item   @code{yleng}  (@samp{PLINT *}, output)  
Pointer to y page length value.

@item   @code{xoff}  (@samp{PLINT *}, output)  
Pointer to x page offset.

@item   @code{yoff}  (@samp{PLINT *}, output)  
Pointer to y page offset.
@end table

@node plgra; Switch to graphics screen, plgriddata; Grid data from irregularly sampled data, plgpage; Get page parameters, The Common API for PLplot
@section   plgra: Switch to graphics screen  


@quotation

@t{
@b{plgra}
();}
@end quotation

Sets an interactive device to graphics mode, used in conjunction with
@code{pltext} (@pxref{pltext; Switch to text screen}) to allow graphics and text to be interspersed. On a device
which supports separate text and graphics windows, this command
causes control to be switched to the graphics window. If already in
graphics mode, this command is ignored. It is also ignored on
devices which only support a single window or use a different method
for shifting focus. See also @code{pltext} (@pxref{pltext; Switch to text screen}).

@node plgriddata; Grid data from irregularly sampled data, plgspa; Get current subpage parameters, plgra; Switch to graphics screen, The Common API for PLplot
@section   plgriddata: Grid data from irregularly sampled  data  


@quotation

@t{
@b{plggriddata}
(@i{x}, @i{y}, @i{z}, @i{npts}, @i{xg}, @i{nptsx}, @i{yg}, @i{nptsy}, @i{zg}, @i{type}, @i{data});}
@end quotation

Real world data is frequently irregularly sampled, but all PLplot 3D
plots require data placed in a uniform grid. This function takes
irregularly sampled data from three input arrays
@samp{x[npts]}, @samp{y[npts]}, and
@samp{z[npts]}, reads the desired grid location from
input arrays @samp{xg[nptsx]} and
@samp{yg[nptsy]}, and returns the gridded data into
output array @samp{zg[nptsx][nptsy]}. The algorithm used
to grid the data is specified with the argument
@samp{type} which can have one parameter specified in
argument @samp{data}.

@table @asis

@item   @code{x}  (@samp{PLFLT *}, input)  
The input @samp{x} array.

@item   @code{y}  (@samp{PLFLT *}, input)  
The input @samp{y} array.

@item   @code{z}  (@samp{PLFLT *}, input)  
The input @samp{z} array. Each triple
@samp{x[i]}, @samp{y[i]},
@samp{z[i]} represents one data sample coordinates.

@item   @code{npts}  (@samp{PLINT}, input)  
The number of data samples in the @samp{x},
@samp{y} and @samp{z} arrays.

@item   @code{xg}  (@samp{PLFLT *}, input)  
The input array that specifies the grid spacing in the x
direction. Usually @samp{xg} has
@samp{nptsx} equaly spaced values from the mininum
to the maximum values of the @samp{x} input array.

@item   @code{nptsx}  (@samp{PLINT}, input)  
The number of points in the @samp{xg} array.

@item   @code{yg}  (@samp{PLFLT *}, input)  
The input array that specifies the grid spacing in the y
direction. Similar to the @samp{xg} parameter.

@item   @code{nptsy}  (@samp{PLINT}, input)  
The number of points in the @samp{yg} array.

@item   @code{sg}  (@samp{PLFLT **}, output)  
The output array, where data lies in the regular grid
specified by @samp{xg} and @samp{yg.}
the @samp{zg} array must exists or be allocated by
the user prior to the calling, and must have dimension
@samp{zg[nptsx][xptsy]}.

@item   @code{type}  (@samp{PLINT}, input)  
The type of gridding algorithm to use, which can be:

@itemize @bullet{}

@item
@samp{GRID_CSA}: Bivariate Cubic Spline
approximation

@item
@samp{GRID_DTLI}: Delaunay Triangulation Linear
Interpolation

@item
@samp{GRID_NNI}: Natural Neighbors Interpolation

@item
@samp{GRID_NNIDW}: Nearest Neighbors Inverse
Distance Weighted

@item
@samp{GRID_NNLI}: Nearest Neighbors Linear
Interpolation

@item
@samp{GRID_NNAIDW}: Nearest Neighbors Around
Inverse Distance Weighted
@end itemize

For details on the algorithm read the source file
@file{plgridd.c}.

@item   @code{data}  (@samp{PLFLT}, input)  
Some gridding algorithms require extra data, which can be
specified through this argument. Currently, for algoritm:

@itemize @bullet{}

@item
@samp{GRID_NNIDW}, @samp{data}
specifies the number of neighbors to use, the lower the
value, the noisier (more local) the approximation is.

@item
@samp{GRID_NNLI}, @samp{data}
specifies what a thin triangle is, in the range
[1. .. 2.]. High values enable the usage of very thin
triangles for interpolation, possibly resulting in error in
the approximation.

@item
@samp{GRID_NNI}, only weights greater than
@samp{data} will be accepted. If 0, all weigths
will be accepted.
@end itemize
@end table

@node plgspa; Get current subpage parameters, plgstrm; Get current stream number, plgriddata; Grid data from irregularly sampled data, The Common API for PLplot
@section   plgspa: Get current subpage parameters  


@quotation

@t{
@b{plgspa}
(@i{xmin}, @i{xmax}, @i{ymin}, @i{ymax});}
@end quotation

Gets the size of the current subpage in millimeters measured from the
bottom left hand corner of the output device page or screen. Can be
used in conjunction with @code{plsvpa} (@pxref{plsvpa; Specify viewport in absolute coordinates}) for setting the size of a viewport
in absolute coordinates (millimeters).

@table @asis

@item   @code{xmin}  (@samp{PLFLT *}, output)  
Pointer to variable with position of left hand edge of subpage
in millimeters.

@item   @code{xmax}  (@samp{PLFLT *}, output)  
Pointer to variable with position of right hand edge of subpage
in millimeters.

@item   @code{ymin}  (@samp{PLFLT *}, output)  
Pointer to variable with position of bottom edge of subpage in
millimeters.

@item   @code{ymax}  (@samp{PLFLT *}, output)  
Pointer to variable with position of top edge of subpage in
millimeters.
@end table

@node plgstrm; Get current stream number, plgver; Get the current library version number, plgspa; Get current subpage parameters, The Common API for PLplot
@section   plgstrm: Get current stream number  


@quotation

@t{
@b{plgstrm}
(@i{strm});}
@end quotation

Gets the number of the current output stream. See also @code{plsstrm} (@pxref{plsstrm; Set current output stream}).

@table @asis

@item   @code{strm}  (@samp{PLINT *}, output)  
Pointer to current stream value.
@end table

@node plgver; Get the current library version number, plgvpd; Get viewport limits in normalized device coordinates, plgstrm; Get current stream number, The Common API for PLplot
@section   plgver: Get the current library version number  


@quotation

@t{
@b{plgver}
(@i{p_ver});}
@end quotation

Get the current library version number. Note: you @i{must}
have allocated space for this (80 characters is safe).

@table @asis

@item   @code{p_ver}  (@samp{char *}, output)  
Pointer to the current library version number.
@end table

@node plgvpd; Get viewport limits in normalized device coordinates, plgvpw; Get viewport limits in world coordinates, plgver; Get the current library version number, The Common API for PLplot
@section   plgvpd: Get viewport limits in normalized device coordinates  


@quotation

@t{
@b{plgvpd}
(@i{p_xmin}, @i{p_xmax}, @i{p_ymin}, @i{p_ymax});}
@end quotation

Get viewport limits in normalized device coordinates.

@table @asis

@item   @code{p_xmin}  (@samp{PLFLT *}, output)  
Lower viewport limit of the normalized device coordinate in x.

@item   @code{p_xmax}  (@samp{PLFLT *}, output)  
Upper viewport limit of the normalized device coordinate in x.

@item   @code{p_ymin}  (@samp{PLFLT *}, output)  
Lower viewport limit of the normalized device coordinate in y.

@item   @code{p_ymax}  (@samp{PLFLT *}, output)  
Upper viewport limit of the normalized device coordinate in y.
@end table

@node plgvpw; Get viewport limits in world coordinates, plgxax; Get x axis parameters, plgvpd; Get viewport limits in normalized device coordinates, The Common API for PLplot
@section   plgvpw: Get viewport limits in world coordinates  


@quotation

@t{
@b{plgvpw}
(@i{p_xmin}, @i{p_xmax}, @i{p_ymin}, @i{p_ymax});}
@end quotation

Get viewport limits in world coordinates.

@table @asis

@item   @code{p_xmin}  (@samp{PLFLT *}, output)  
Lower viewport limit of the world coordinate in x.

@item   @code{p_xmax}  (@samp{PLFLT *}, output)  
Upper viewport limit of the world coordinate in x.

@item   @code{p_ymin}  (@samp{PLFLT *}, output)  
Lower viewport limit of the world coordinate in y.

@item   @code{p_ymax}  (@samp{PLFLT *}, output)  
Upper viewport limit of the world coordinate in y.
@end table

@node plgxax; Get x axis parameters, plgyax; Get y axis parameters, plgvpw; Get viewport limits in world coordinates, The Common API for PLplot
@section   plgxax: Get x axis parameters  


@quotation

@t{
@b{plgxax}
(@i{digmax}, @i{digits});}
@end quotation

Returns current values of the
@samp{@code{digmax}} and
@samp{@code{digits}} flags for the x
axis. @samp{@code{digits}} is updated
after the plot is drawn, so this routine should only be called
@i{after} the call to @code{plbox} (@pxref{plbox; Draw a box with axes; etc}) (or @code{ plbox3} (@pxref{plbox3; Draw a box with axes; etc; in 3-d})) is
complete. See @ref{Annotating the Viewport,,Annotating the Viewport}. for more information.

@table @asis

@item   @code{digmax}  (@samp{PLINT *}, output)  
Pointer to variable with the maximum number of digits for the x axis. If
nonzero, the printed label has been switched to a floating point
representation when the number of digits exceeds
@samp{@code{digmax}}.

@item   @code{digits}  (@samp{PLINT *}, output)  
Pointer to variable with the actual number of digits for the
numeric labels (x axis) from the last plot.
@end table

@node plgyax; Get y axis parameters, plgzax; Get z axis parameters, plgxax; Get x axis parameters, The Common API for PLplot
@section   plgyax: Get y axis parameters  


@quotation

@t{
@b{plgyax}
(@i{digmax}, @i{digits});}
@end quotation

Identical to @code{plgxax} (@pxref{plgxax; Get x axis parameters}), except that arguments are flags for y axis.
See the description of @code{plgxax} (@pxref{plgxax; Get x axis parameters}) for more detail.

@table @asis

@item   @code{digmax}  (@samp{PLINT *}, output)  
Pointer to variable with the maximum number of digits for the y axis. If
nonzero, the printed label has been switched to a floating point
representation when the number of digits exceeds
@samp{@code{digmax}}.

@item   @code{digits}  (@samp{PLINT *}, output)  
Pointer to variable with the actual number of digits for the
numeric labels (y axis) from the last plot.
@end table

@node plgzax; Get z axis parameters, plhist; Plot a histogram from unbinned data, plgyax; Get y axis parameters, The Common API for PLplot
@section   plgzax: Get z axis parameters  


@quotation

@t{
@b{plgzax}
(@i{digmax}, @i{digits});}
@end quotation

Identical to @code{plgxax} (@pxref{plgxax; Get x axis parameters}), except that arguments are flags for z axis.
See the description of @code{plgxax} (@pxref{plgxax; Get x axis parameters}) for more detail.

@table @asis

@item   @code{digmax}  (@samp{PLINT *}, output)  
Pointer to variable with the maximum number of digits for the z axis. If
nonzero, the printed label has been switched to a floating point
representation when the number of digits exceeds
@samp{@code{digmax}}.

@item   @code{digits}  (@samp{PLINT *}, output)  
Pointer to variable with the actual number of digits for the
numeric labels (z axis) from the last plot.
@end table

@node plhist; Plot a histogram from unbinned data, plhlsrgb; Convert HLS color to RGB, plgzax; Get z axis parameters, The Common API for PLplot
@section   plhist: Plot a histogram from unbinned data  


@quotation

@t{
@b{plhist}
(@i{n}, @i{data}, @i{datmin}, @i{datmax}, @i{nbin}, @i{oldwin});}
@end quotation

Plots a histogram from @samp{@code{n}}
data points stored in the array
@samp{@code{data}}. This routine bins
the data into @samp{@code{nbin}} bins
equally spaced between
@samp{@code{datmin}} and
@samp{@code{datmax}}, and calls @code{plbin} (@pxref{plbin; Plot a histogram from binned data})
to draw the resulting histogram. Parameter
@samp{@code{oldwin}} allows the histogram
either to be plotted in an existing window or causes @code{plhist} (@pxref{plhist; Plot a histogram from unbinned data}) to call
@code{plenv} (@pxref{plenv; Set up standard window and draw box}) with suitable limits before plotting the histogram.

@table @asis

@item   @code{n}  (@samp{PLINT}, input)  
Number of data points.

@item   @code{data}  (@samp{PLFLT *}, input)  
Pointer to array with values of the
@samp{@code{n}} data points.

@item   @code{datmin}  (@samp{PLFLT}, input)  
Left-hand edge of lowest-valued bin.

@item   @code{datmax}  (@samp{PLFLT}, input)  
Right-hand edge of highest-valued bin.

@item   @code{nbin}  (@samp{PLINT}, input)  
Number of (equal-sized) bins into which to divide the interval
@samp{@code{xmin}} to
@samp{@code{xmax}}.

@item   @code{oldwin}  (@samp{PLINT}, input)  
If one, the histogram is plotted in the currently-defined
window, and if zero, @code{plenv} (@pxref{plenv; Set up standard window and draw box}) is called automatically before
plotting.
@end table

@node plhlsrgb; Convert HLS color to RGB, plinit; Initialize PLplot, plhist; Plot a histogram from unbinned data, The Common API for PLplot
@section   plhlsrgb: Convert HLS color to RGB  


@quotation

@t{
@b{plhlsrgb}
(@i{h}, @i{l}, @i{s}, @i{p_r}, @i{p_g}, @i{p_b});}
@end quotation

Convert HLS color coordinates to RGB

@table @asis

@item   @code{h}  (@samp{PLFLT}, input)  
Hue, in degrees on the colour cone (0.0-360.0)

@item   @code{l}  (@samp{PLFLT}, input)  
Lightness, expressed as a fraction of the axis of the colour
cone (0.0-1.0)

@item   @code{s}  (@samp{PLFLT}, input)  
Saturation, expressed as a fraction of the radius of the
colour cone (0.0-1.0)

@item   @code{p_r}  (@samp{PLFLT *}, output)  
Pointer to red intensity (0.0-1.0) of the colour

@item   @code{p_g}  (@samp{PLFLT *}, output)  
Pointer to green intensity (0.0-1.0) of the colour

@item   @code{p_b}  (@samp{PLFLT *}, output)  
Pointer to blue intensity (0.0-1.0) of the colour
@end table

@node plinit; Initialize PLplot, pljoin; Draw a line between two points, plhlsrgb; Convert HLS color to RGB, The Common API for PLplot
@section   plinit: Initialize PLplot  


@quotation

@t{
@b{plinit}
();}
@end quotation

Initializing the plotting package. The program prompts for the
device keyword or number of the desired output device. Hitting a
RETURN in response to the prompt is the same as selecting the first
device. @code{plinit} (@pxref{plinit; Initialize PLplot}) will issue no prompt if either the device was
specified previously (via command line flag, the @code{plsetopt} (@pxref{plsetopt; Set any command-line option}) function,
or the @code{plsdev} (@pxref{plsdev; Set the device [keyword] name}) function), or if only one device is
enabled when PLplot is installed. If subpages have been specified,
the output device is divided into @samp{nx} by
@samp{ny} subpages, each of which may be used
independently. If @code{plinit} (@pxref{plinit; Initialize PLplot}) is called again during a program, the
previously opened file will be closed. The subroutine @code{pladv} (@pxref{pladv; Advance the [sub-]page}) is
used to advance from one subpage to the next.

@node pljoin; Draw a line between two points, pllab; Simple routine to write labels, plinit; Initialize PLplot, The Common API for PLplot
@section   pljoin: Draw a line between two points  


@quotation

@t{
@b{pljoin}
(@i{x1}, @i{y1}, @i{x2}, @i{y2});}
@end quotation

Joins the point @samp{(@code{x1},
@code{y1})} to
@samp{(@code{x2},
@code{y2})}.

@table @asis

@item   @code{x1}  (@samp{PLFLT}, input)  
x coordinate of first point.

@item   @code{y1}  (@samp{PLFLT}, input)  
y coordinate of first point.

@item   @code{x2}  (@samp{PLFLT}, input)  
x coordinate of second point.

@item   @code{y2}  (@samp{PLFLT}, input)  
y coordinate of second point.
@end table

@node pllab; Simple routine to write labels, pllightsource; Sets the 3D position of the light source, pljoin; Draw a line between two points, The Common API for PLplot
@section   pllab: Simple routine to write labels  


@quotation

@t{
@b{pllab}
(@i{xlabel}, @i{ylabel}, @i{tlabel});}
@end quotation

Routine for writing simple labels. Use @code{plmtex} (@pxref{plmtex; Write text relative to viewport boundaries}) for more complex
labels.

@table @asis

@item   @code{xlabel}  (@samp{const char *}, input)  
Label for horizontal axis.

@item   @code{ylabel}  (@samp{const char *}, input)  
Label for vertical axis.

@item   @code{tlabel}  (@samp{const char *}, input)  
Title of graph.
@end table

@node pllightsource; Sets the 3D position of the light source, plline; Draw a line, pllab; Simple routine to write labels, The Common API for PLplot
@section   pllightsource: Sets the 3D position of the light source  


@quotation

@t{
@b{pllightsource}
(@i{x}, @i{y}, @i{z});}
@end quotation

Sets the 3D position of the light source for use with @code{plsurf3d} (@pxref{plsurf3d; Plot shaded 3-d surface plot}).

@table @asis

@item   @code{x}  (@samp{PLFLT}, input)  
X-coordinate of the light source.

@item   @code{y}  (@samp{PLFLT}, input)  
Y-coordinate of the light source.

@item   @code{z}  (@samp{PLFLT}, input)  
Z-coordinate of the light source.
@end table

@node plline; Draw a line, plline3; Draw a line in 3 space, pllightsource; Sets the 3D position of the light source, The Common API for PLplot
@section   plline: Draw a line  


@quotation

@t{
@b{plline}
(@i{n}, @i{x}, @i{y});}
@end quotation

Draws line defined by @samp{@code{n}}
points in
@samp{@code{x}} and
@samp{@code{y}}.

@table @asis

@item   @code{n}  (@samp{PLINT}, input)  
Number of points defining line.

@item   @code{x}  (@samp{PLFLT *}, input)  
Pointer to array with x coordinates of points.

@item   @code{y}  (@samp{PLFLT *}, input)  
Pointer to array with y coordinates of points.
@end table

@node plline3; Draw a line in 3 space, pllsty; Select line style, plline; Draw a line, The Common API for PLplot
@section   plline3: Draw a line in 3 space  


@quotation

@t{
@b{plline3}
(@i{n}, @i{x}, @i{y}, @i{z});}
@end quotation

Draws line in 3 space defined by @samp{@code{n}}
points in
@samp{@code{x}},
@samp{@code{y}}, and
@samp{@code{z}}.
You must first set up the viewport, the
2d viewing window (in world coordinates), and the 3d normalized
coordinate box. See @file{x18c.c} for more info.

@table @asis

@item   @code{n}  (@samp{PLINT}, input)  
Number of points defining line.

@item   @code{x}  (@samp{PLFLT *}, input)  
Pointer to array with x coordinates of points.

@item   @code{y}  (@samp{PLFLT *}, input)  
Pointer to array with y coordinates of points.

@item   @code{z}  (@samp{PLFLT *}, input)  
Pointer to array with z coordinates of points.
@end table

@node pllsty; Select line style, plmesh; Plot surface mesh, plline3; Draw a line in 3 space, The Common API for PLplot
@section   pllsty: Select line style  


@quotation

@t{
@b{pllsty}
(@i{n});}
@end quotation

This sets the line style according to one of eight predefined
patterns (also see @code{plstyl} (@pxref{plstyl; Set line style})).

@table @asis

@item   @code{n}  (@samp{PLINT}, input)  
Integer value between 1 and 8. Line style 1 is a continuous line,
line style 2 is a line with short dashes and gaps, line style 3 is
a line with long dashes and gaps, line style 4 has long dashes and
short gaps and so on.
@end table

@node plmesh; Plot surface mesh, plmeshc; Magnitude colored plot surface mesh with contour_, pllsty; Select line style, The Common API for PLplot
@section   plmesh: Plot surface mesh  


@quotation

@t{
@b{plmesh}
(@i{x}, @i{y}, @i{z}, @i{nx}, @i{ny}, @i{opt});}
@end quotation

Plots a surface mesh within the environment set up by @code{plw3d} (@pxref{plw3d; Set up window for 3-d plotting}). The
surface is defined by the two-dimensional array
@samp{@code{z}[@code{nx}][@code{ny}]},
the point @samp{@code{z}[i][j]} being the
value of the function at @samp{(@code{x}[i],
@code{y}[j])}. Note that the points in
arrays @samp{@code{x}} and
@samp{@code{y}} do not need to be equally
spaced, but must be stored in ascending order. The parameter
@samp{@code{opt}} controls the way in
which the surface is displayed. For further details see @ref{Three Dimensional Surface Plots,,Three Dimensional Surface Plots}..

@table @asis

@item   @code{x}  (@samp{PLFLT *}, input)  
Pointer to set of x coordinate values at which the function is
evaluated.

@item   @code{y}  (@samp{PLFLT *}, input)  
Pointer to set of y coordinate values at which the function is
evaluated.

@item   @code{z}  (@samp{PLFLT **}, input)  
Pointer to a vectored two-dimensional array with set of
function values.

@item   @code{nx}  (@samp{PLINT}, input)  
Number of @samp{@code{x}} values at
which function is evaluated.

@item   @code{ny}  (@samp{PLINT}, input)  
Number of @samp{@code{y}} values at
which function is evaluated.

@item   @code{opt}  (@samp{PLINT}, input)  
Determines the way in which the surface is represented:

@itemize @bullet{}

@item
@samp{@code{opt}=DRAW_LINEX}: Lines
are drawn showing
@samp{@code{z}} as a function
of @samp{@code{x}} for each
value of @samp{@code{y}[j]}.

@item
@samp{@code{opt}=DRAW_LINEY}: Lines
are drawn showing
@samp{@code{z}} as a function
of @samp{@code{y}} for each
value of @samp{@code{x}[i]}.

@item
@samp{@code{opt}=DRAW_LINEXY}: Network
of lines is drawn connecting points at which function is
defined.
@end itemize
@end table

@node plmeshc; Magnitude colored plot surface mesh with contour_, plmkstrm; Creates a new stream and makes it the default, plmesh; Plot surface mesh, The Common API for PLplot
@section   plmeshc: Magnitude colored plot surface mesh with contour.  


@quotation

@t{
@b{plmeshc}
(@i{x}, @i{y}, @i{z}, @i{nx}, @i{ny}, @i{opt}, @i{clevel}, @i{nlevel});}
@end quotation

Identical to @code{plmesh} but with extra functionalities:
the surface mesh can be colored accordingly to the current z value being plotted,
a contour plot can be drawn at the base XY plane, and a curtain can be drawn between
the plotted function border and the base XY plane.

@table @asis

@item   @code{x}  (@samp{PLFLT *}, input)  
Pointer to set of x coordinate values at which the function is
evaluated.

@item   @code{y}  (@samp{PLFLT *}, input)  
Pointer to set of y coordinate values at which the function is
evaluated.

@item   @code{z}  (@samp{PLFLT **}, input)  
Pointer to a vectored two-dimensional array with set of
function values.

@item   @code{nx}  (@samp{PLINT}, input)  
Number of @samp{@code{x}} values at
which function is evaluated.

@item   @code{ny}  (@samp{PLINT}, input)  
Number of @samp{@code{y}} values at
which function is evaluated.

@item   @code{opt}  (@samp{PLINT}, input)  
Determines the way in which the surface is represented. To specify
more than one option just add the options, e.g. DRAW_LINEXY + MAG_COLOR

@itemize @bullet{}

@item
@samp{@code{opt}=DRAW_LINEX}: Lines
are drawn showing
@samp{@code{z}} as a function
of @samp{@code{x}} for each
value of @samp{@code{y}[j]}.

@item
@samp{@code{opt}=DRAW_LINEY}: Lines
are drawn showing
@samp{@code{z}} as a function
of @samp{@code{y}} for each
value of @samp{@code{x}[i]}.

@item
@samp{@code{opt}=DRAW_LINEXY}: Network
of lines is drawn connecting points at which function is
defined.

@item
@samp{@code{opt}=MAG_COLOR}: Each line
in the mesh is colored according to the z value being plotted. The
color is used from the current colormap 1.

@item
@samp{@code{opt}=BASE_CONT}: A contour
plot is drawn at the base XY plane using parameters
@code{nlevel} and @code{clevel}.

@item
@samp{@code{opt}=DRAW_SIDES}: draws a curtain
between the base XY plane and the borders of the plotted function.
@end itemize

@item   @code{clevel}  (@samp{PLFLT *}, input)  
Pointer to the array that defines the contour level spacing.

@item   @code{nlevel}  (@samp{PLINT}, input)  
Number of elements in the @samp{clevel} array.
@end table

@node plmkstrm; Creates a new stream and makes it the default, plmtex; Write text relative to viewport boundaries, plmeshc; Magnitude colored plot surface mesh with contour_, The Common API for PLplot
@section   plmkstrm: Creates a new stream and makes it the default  


@quotation

@t{
@b{plmkstrm}
(@i{p_strm});}
@end quotation

Creates a new stream and makes it the default. Differs from using
@code{plsstrm} (@pxref{plsstrm; Set current output stream}), in that a free stream number is found, and returned.
Unfortunately, I @i{have} to start at stream 1 and work upward, since
stream 0 is preallocated. One of the @i{big} flaws in the PLplot API is
that no initial, library-opening call is required. So stream 0 must
be preallocated, and there is no simple way of determining whether it
is already in use or not.

@table @asis

@item   @code{p_strm}  (@samp{PLINT *}, output)  
Pointer to stream number of the created stream.
@end table

@node plmtex; Write text relative to viewport boundaries, plot3d; Plot 3-d surface plot, plmkstrm; Creates a new stream and makes it the default, The Common API for PLplot
@section   plmtex: Write text relative to viewport boundaries  


@quotation

@t{
@b{plmtex}
(@i{side}, @i{disp}, @i{pos}, @i{just}, @i{text});}
@end quotation

Writes text at a specified position relative to the viewport
boundaries. Text may be written inside or outside the viewport, but
is clipped at the subpage boundaries. The reference point of a
string lies along a line passing through the string at half the
height of a capital letter. The position of the reference point
along this line is determined by
@samp{@code{just}}, and the position of
the reference point relative to the viewport is set by
@samp{@code{disp}} and
@samp{@code{pos}}.

@table @asis

@item   @code{side}  (@samp{const char *}, input)  
Specifies the side of the viewport along which the text is to
be written. The string must be one of:

@itemize @bullet{}

@item
@samp{b}: Bottom of viewport, text written
parallel to edge.

@item
@samp{bv}: Bottom of viewport, text written at
right angles to edge.

@item
@samp{l}: Left of viewport, text written
parallel to edge.

@item
@samp{lv}: Left of viewport, text written at
right angles to edge.

@item
@samp{r}: Right of viewport, text written
parallel to edge.

@item
@samp{rv}: Right of viewport, text written at
right angles to edge.

@item
@samp{t}: Top of viewport, text written
parallel to edge.

@item
@samp{tv}: Top of viewport, text written at
right angles to edge.
@end itemize

@item   @code{disp}  (@samp{PLFLT}, input)  
Position of the reference point of string, measured outwards
from the specified viewport edge in units of the current
character height. Use negative
@samp{@code{disp}} to write within
the viewport.

@item   @code{pos}  (@samp{PLFLT}, input)  
Position of the reference point of string along the specified
edge, expressed as a fraction of the length of the edge.

@item   @code{just}  (@samp{PLFLT}, input)  
Specifies the position of the string relative to its reference
point. If @samp{@code{just}=0},
the reference point is at the left and if
@samp{@code{just}=1}, it is at the
right of the string. Other values of
@samp{@code{just}} give
intermediate justifications.

@item   @code{text}  (@samp{const char *}, input)  
The string to be written out.
@end table

@node plot3d; Plot 3-d surface plot, plot3dc; Magnitude colored plot surface with contour_, plmtex; Write text relative to viewport boundaries, The Common API for PLplot
@section   plot3d: Plot 3-d surface plot  


@quotation

@t{
@b{plot3d}
(@i{x}, @i{y}, @i{z}, @i{nx}, @i{ny}, @i{opt}, @i{side});}
@end quotation

Plots a three dimensional surface plot within the environment set up
by @code{plw3d} (@pxref{plw3d; Set up window for 3-d plotting}). The surface is defined by the two-dimensional array
@samp{@code{z}[@code{nx}][@code{ny}]},
the point @samp{@code{z}[i][j]} being the
value of the function at @samp{(@code{x}[i],
@code{y}[j])}. Note that the points in
arrays @samp{@code{x}} and
@samp{@code{y}} do not need to be equally
spaced, but must be stored in ascending order. The parameter
@samp{@code{opt}} controls the way in
which the surface is displayed. For further details see @ref{Three Dimensional Surface Plots,,Three Dimensional Surface Plots}..
The only difference between @code{plmesh} (@pxref{plmesh; Plot surface mesh}) and @code{plot3d} (@pxref{plot3d; Plot 3-d surface plot}) is that @code{plmesh} (@pxref{plmesh; Plot surface mesh}) draws
the botton side of the surface, while @code{plot3d} (@pxref{plot3d; Plot 3-d surface plot}) only draws the surface as
viewed from the top.

@table @asis

@item   @code{x}  (@samp{PLFLT *}, input)  
Pointer to set of x coordinate values at which the function is
evaluated.

@item   @code{y}  (@samp{PLFLT *}, input)  
Pointer to set of y coordinate values at which the function is
evaluated.

@item   @code{z}  (@samp{PLFLT **}, input)  
Pointer to a vectored two-dimensional array with set of
function values.

@item   @code{nx}  (@samp{PLINT}, input)  
Number of @samp{@code{x}} values at
which function is evaluated.

@item   @code{ny}  (@samp{PLINT}, input)  
Number of @samp{@code{y}} values at
which function is evaluated.

@item   @code{opt}  (@samp{PLINT}, input)  
Determines the way in which the surface is represented:

@itemize @bullet{}

@item
@samp{@code{opt}=DRAW_LINEX}: Lines
are drawn showing
@samp{@code{z}} as a function
of @samp{@code{x}} for each
value of @samp{@code{y}[j]}.

@item
@samp{@code{opt}=DRAW_LINEY}: Lines
are drawn showing
@samp{@code{z}} as a function
of @samp{@code{y}} for each
value of @samp{@code{x}[i]}.

@item
@samp{@code{opt}=DRAW_LINEXY}: Network
of lines is drawn connecting points at which function is
defined.
@end itemize

@item   @code{side}  (@samp{PLINT}, input)  
Flag to indicate whether or not ``sides'' should be draw on the
figure. If @samp{@code{side}=0} no
sides are drawn, otherwise the sides are drawn.
@end table

@node plot3dc; Magnitude colored plot surface with contour_, plparseopts; Parse command-line arguments, plot3d; Plot 3-d surface plot, The Common API for PLplot
@section   plot3dc: Magnitude colored plot surface with contour.  


@quotation

@t{
@b{plot3dc}
(@i{x}, @i{y}, @i{z}, @i{nx}, @i{ny}, @i{opt}, @i{clevel}, @i{nlevel});}
@end quotation

Identical to @code{plot3d} but with extra functionalities:
the surface mesh can be colored accordingly to the current z value being plotted,
a contour plot can be drawn at the base XY plane, and a curtain can be drawn between
the plotted function border and the base XY plane.
The arguments are identical to @code{plmeshc}. The only difference between
@code{plmeshc} (@pxref{plmeshc; Magnitude colored plot surface mesh with contour_}) and @code{plot3dc} (@pxref{plot3dc; Magnitude colored plot surface with contour_}) is that @code{plmeshc} (@pxref{plmeshc; Magnitude colored plot surface mesh with contour_}) draws the botton side of the surface, while
@code{plot3dc} (@pxref{plot3dc; Magnitude colored plot surface with contour_}) only draws the surface as viewed from the top.

@node plparseopts; Parse command-line arguments, plpat; Set area fill pattern, plot3dc; Magnitude colored plot surface with contour_, The Common API for PLplot
@section   plparseopts: Parse command-line arguments  


@quotation

@t{
@b{plparseopts}
(@i{p_argc}, @i{argv}, @i{mode});}
@end quotation

Parse command-line arguments.

@table @asis

@item   @code{p_argc}  (@samp{int *}, input)  
pointer to number of arguments.

@item   @code{argv}  (@samp{char **}, input)  
Pointer to character array containing
@samp{@code{*p_argc}} command-line
arguments.

@item   @code{mode}  (@samp{PLINT}, input)  
Parsing mode with the following possibilities:

@itemize @bullet{}

@item
PL_PARSE_FULL (1) -- Full parsing of command line and all error messages
enabled, including program exit when an error occurs. Anything on the
command line that isn't recognized as a valid option or option argument is
flagged as an error.

@item
PL_PARSE_QUIET (2) -- Turns off all output except in the case of errors.

@item
PL_PARSE_NODELETE (4) -- Turns off deletion of processed arguments.

@item
PL_PARSE_SHOWALL (8) -- Show invisible options

@item
PL_PARSE_NOPROGRAM (32) -- Specified if argv[0] is NOT a pointer to the
program name.

@item
PL_PARSE_NODASH (64) -- Set if leading dash is NOT required.

@item
PL_PARSE_SKIP (128) -- Set to quietly skip over any unrecognized args.
@end itemize
@end table

@node plpat; Set area fill pattern, plpoin; Plots a character at the specified points, plparseopts; Parse command-line arguments, The Common API for PLplot
@section   plpat: Set area fill pattern  


@quotation

@t{
@b{plpat}
(@i{nlin}, @i{inc}, @i{del});}
@end quotation

Sets the area fill pattern. The pattern consists of 1 or 2 sets of
parallel lines with specified inclinations and spacings. The
arguments to this routine are the number of sets to use (1 or 2)
followed by two pointers to integer arrays (of 1 or 2 elements)
specifying the inclinations in tenths of a degree and the spacing in
micrometers. (also see @code{plpsty} (@pxref{plpsty; Select area fill pattern}))

@table @asis

@item   @code{nlin}  (@samp{PLINT}, input)  
Number of sets of lines making up the pattern, either 1 or 2.

@item   @code{inc}  (@samp{PLINT *}, input)  
Pointer to array with
@samp{@code{nlin}} elements.
Specifies the line inclination in tenths of a degree. (Should
be between -900 and 900).

@item   @code{del}  (@samp{PLINT *}, input)  
Pointer to array with
@samp{@code{nlin}} elements.
Specifies the spacing in micrometers between the lines making
up the pattern.
@end table

@node plpoin; Plots a character at the specified points, plpoin3; Plots a character at the specified points in 3 space, plpat; Set area fill pattern, The Common API for PLplot
@section   plpoin: Plots a character at the specified points  


@quotation

@t{
@b{plpoin}
(@i{n}, @i{x}, @i{y}, @i{code});}
@end quotation

Marks a set of @samp{@code{n}}
points in
@samp{@code{x}} and
@samp{@code{y}} using
the symbol defined by
@samp{@code{code}}.
If
@samp{@code{code}} is between 32 and 127,
the symbol is simply the corresponding printable ASCII character
in the default font.

@table @asis

@item   @code{n}  (@samp{PLINT}, input)  
Number of points to be marked.

@item   @code{x}  (@samp{PLFLT *}, input)  
Pointer to array with x coordinates of the points.

@item   @code{y}  (@samp{PLFLT *}, input)  
Pointer to array with y coordinates of the points.

@item   @code{code}  (@samp{PLINT}, input)  
Code number for the symbol to be plotted.
@end table

@node plpoin3; Plots a character at the specified points in 3 space, plpoly3; Draw a polygon in 3 space, plpoin; Plots a character at the specified points, The Common API for PLplot
@section   plpoin3: Plots a character at the specified  points in 3 space  


@quotation

@t{
@b{plpoin3}
(@i{n}, @i{x}, @i{y}, @i{z}, @i{code});}
@end quotation

Marks a set of @samp{@code{n}}
points in
@samp{@code{x}},
@samp{@code{y}}, and
@samp{@code{z}} using
the symbol defined by
@samp{@code{code}}.
If
@samp{@code{code}} is between 32 and 127,
the symbol is simply the corresponding printable ASCII character
in the default font.
Setup similar to @code{plline3} (@pxref{plline3; Draw a line in 3 space}).

@table @asis

@item   @code{n}  (@samp{PLINT}, input)  
Number of points to be marked.

@item   @code{x}  (@samp{PLFLT *}, input)  
Pointer to array with x coordinates of the points.

@item   @code{y}  (@samp{PLFLT *}, input)  
Pointer to array with y coordinates of the points.

@item   @code{z}  (@samp{PLFLT *}, input)  
Pointer to array with z coordinates of the points.

@item   @code{code}  (@samp{PLINT}, input)  
Code number for the symbol to be plotted.
@end table

@node plpoly3; Draw a polygon in 3 space, plprec; Set precision in numeric labels, plpoin3; Plots a character at the specified points in 3 space, The Common API for PLplot
@section   plpoly3: Draw a polygon in 3 space  


@quotation

@t{
@b{plpoly3}
(@i{n}, @i{x}, @i{y}, @i{z}, @i{draw}, @i{ifcc});}
@end quotation

Draws a polygon in 3 space defined by @samp{@code{n}}
points in
@samp{@code{x}},
@samp{@code{y}}, and
@samp{@code{z}}.
Setup like @code{plline3} (@pxref{plline3; Draw a line in 3 space}), but differs from that function in that @code{plpoly3} (@pxref{plpoly3; Draw a polygon in 3 space})
attempts to determine if the polygon is viewable depending on the
order of the points within the arrays and the value of
@samp{@code{ifcc}}. If the back of
polygon is facing the viewer, then it isn't drawn. If this isn't what
you want, then use @code{plline3} (@pxref{plline3; Draw a line in 3 space}) instead.

The points are assumed to be in a plane, and the directionality of
the plane is determined from the first three points. Additional
points do not @i{have} to lie on the plane defined
by the first three, but if they do not, then the determination of
visibility obviously can't be 100% accurate... So if you're 3 space
polygons are too far from planar, consider breaking them into smaller
polygons. 3 points define a plane :-).

@i{Bugs}: If one of the first two segments is of
zero length, or if they are colinear, the calculation of visibility
has a 50/50 chance of being correct. Avoid such situations :-). See
@file{x18c.c} for an example of this problem.
(Search for 20.1).

@table @asis

@item   @code{n}  (@samp{PLINT}, input)  
Number of points defining line.

@item   @code{x}  (@samp{PLFLT *}, input)  
Pointer to array with x coordinates of points.

@item   @code{y}  (@samp{PLFLT *}, input)  
Pointer to array with y coordinates of points.

@item   @code{z}  (@samp{PLFLT *}, input)  
Pointer to array with z coordinates of points.

@item   @code{draw}  (@samp{PLINT *}, input)  
Pointer to array which controls drawing the segments of the
polygon. If @samp{@code{draw[i]}} is true,
then the polygon segment from index
@samp{@code{[i]}} to
@samp{@code{[i+1]}} is drawn, otherwise, not.

@item   @code{ifcc}  (@samp{PLINT}, input)  
If @samp{@code{ifcc}=1}
the directionality of the polygon is determined by assuming the points
are laid out in a counter-clockwise order.
If @samp{@code{ifcc}=0}
the directionality of the polygon is determined by assuming the points
are laid out in a clockwise order.
@end table

@node plprec; Set precision in numeric labels, plpsty; Select area fill pattern, plpoly3; Draw a polygon in 3 space, The Common API for PLplot
@section   plprec: Set precision in numeric labels  


@quotation

@t{
@b{plprec}
(@i{set}, @i{prec});}
@end quotation

Sets the number of places after the decimal point in numeric labels.

@table @asis

@item   @code{set}  (@samp{PLINT}, input)  
If @samp{@code{set}} is equal to 0
then PLplot automatically determines the number of places to
use after the decimal point in numeric labels (like those used
to label axes). If
@samp{@code{set}} is 1 then
@samp{@code{prec}} sets the number
of places.

@item   @code{prec}  (@samp{PLINT}, input)  
The number of characters to draw after the decimal point in
numeric labels.
@end table

@node plpsty; Select area fill pattern, plptex; Write text inside the viewport, plprec; Set precision in numeric labels, The Common API for PLplot
@section   plpsty: Select area fill pattern  


@quotation

@t{
@b{plpsty}
(@i{n});}
@end quotation

Select one of eight predefined area fill patterns to use (also see
@code{plpat} (@pxref{plpat; Set area fill pattern})).

@table @asis

@item   @code{n}  (@samp{PLINT}, input)  
The desired pattern. Pattern 1 consists of horizontal lines,
pattern 2 consists of vertical lines, pattern 3 consists of lines
at 45 degrees angle (upward), and so on.
@end table

@node plptex; Write text inside the viewport, plreplot; Replays contents of plot buffer to current device/file, plpsty; Select area fill pattern, The Common API for PLplot
@section   plptex: Write text inside the viewport  


@quotation

@t{
@b{plptex}
(@i{x}, @i{y}, @i{dx}, @i{dy}, @i{just}, @i{text});}
@end quotation

Writes text at a specified position and inclination within the
viewport. Text is clipped at the viewport boundaries. The reference
point of a string lies along a line passing through the string at
half the height of a capital letter. The position of the reference
point along this line is determined by
@samp{@code{just}}, the reference point
is placed at world coordinates @samp{(@code{x},
@code{y})} within the viewport. The
inclination of the string is specified in terms of differences of
world coordinates making it easy to write text parallel to a line in
a graph.

@table @asis

@item   @code{x}  (@samp{PLFLT}, input)  
x coordinate of reference point of string.

@item   @code{y}  (@samp{PLFLT}, input)  
y coordinate of reference point of string.

@item   @code{dx}  (@samp{PLFLT}, input)  
Together with @samp{@code{dy}},
this specifies the inclination of the string. The baseline of
the string is parallel to a line joining
@samp{(@code{x},
@code{y})} to
@samp{(@code{x}+@code{dx},
@code{y}+@code{dy})}.

@item   @code{dy}  (@samp{PLFLT}, input)  
Together with @samp{@code{dx}},
this specifies the inclination of the string.

@item   @code{just}  (@samp{PLFLT}, input)  
Specifies the position of the string relative to its reference
point. If @samp{@code{just}=0},
the reference point is at the left and if
@samp{@code{just}=1}, it is at the
right of the string. Other values of
@samp{@code{just}} give
intermediate justifications.

@item   @code{text}  (@samp{const char *}, input)  
The string to be written out.
@end table

@node plreplot; Replays contents of plot buffer to current device/file, plrgbhls; Convert RGB color to HLS, plptex; Write text inside the viewport, The Common API for PLplot
@section   plreplot: Replays contents of plot buffer to current device/file  


@quotation

@t{
@b{plreplot}
();}
@end quotation

Replays contents of plot buffer to current device/file.

@node plrgbhls; Convert RGB color to HLS, plschr; Set character size, plreplot; Replays contents of plot buffer to current device/file, The Common API for PLplot
@section   plrgbhls: Convert RGB color to HLS  


@quotation

@t{
@b{plrgbhls}
(@i{r}, @i{g}, @i{b}, @i{p_h}, @i{p_l}, @i{p_s});}
@end quotation

Convert RGB color coordinates to HLS

@table @asis

@item   @code{r}  (@samp{PLFLT}, output)  
Red intensity (0.0-1.0) of the colour

@item   @code{g}  (@samp{PLFLT}, output)  
Green intensity (0.0-1.0) of the colour

@item   @code{b}  (@samp{PLFLT}, output)  
Blue intensity (0.0-1.0) of the colour

@item   @code{p_h}  (@samp{PLFLT *}, input)  
Pointer to hue, in degrees on the colour cone (0.0-360.0)

@item   @code{p_l}  (@samp{PLFLT *}, input)  
Pointer to lightness, expressed as a fraction of the axis of the colour
cone (0.0-1.0)

@item   @code{p_s}  (@samp{PLFLT *}, input)  
Pointer to saturation, expressed as a fraction of the radius of the
colour cone (0.0-1.0)
@end table

@node plschr; Set character size, plscmap0; Set color map0 colors by 8-bit RGB values, plrgbhls; Convert RGB color to HLS, The Common API for PLplot
@section   plschr: Set character size  


@quotation

@t{
@b{plschr}
(@i{def}, @i{scale});}
@end quotation

This sets up the size of all subsequent characters drawn. The actual
height of a character is the product of the default character size
and a scaling factor.

@table @asis

@item   @code{def}  (@samp{PLFLT}, input)  
The default height of a character in millimeters, should be set
to zero if the default height is to remain unchanged.

@item   @code{scale}  (@samp{PLFLT}, input)  
Scale factor to be applied to default to get actual character
height.
@end table

@node plscmap0; Set color map0 colors by 8-bit RGB values, plscmap0n; Set number of colors in color map0, plschr; Set character size, The Common API for PLplot
@section   plscmap0: Set color map0 colors by 8-bit RGB values  


@quotation

@t{
@b{plscmap0}
(@i{r}, @i{g}, @i{b}, @i{ncol0});}
@end quotation

Set color map0 colors using 8-bit RGB values (see @ref{Color Map0,,Color Map0}.). This sets the entire color
map -- only as many colors as specified will be allocated.

@table @asis

@item   @code{r}  (@samp{PLINT *}, input)  
Pointer to array with set of unsigned 8-bit integers (0-255)
representing the degree of red in the color.

@item   @code{g}  (@samp{PLINT *}, input)  
Pointer to array with set of unsigned 8-bit integers (0-255)
representing the degree of green in the color.

@item   @code{b}  (@samp{PLINT *}, input)  
Pointer to array with set of unsigned 8-bit integers (0-255)
representing the degree of blue in the color.

@item   @code{ncol0}  (@samp{PLINT}, input)  
Number of items in the
@samp{@code{r}},
@samp{@code{g}}, and
@samp{@code{b}} arrays.
@end table

@node plscmap0n; Set number of colors in color map0, plscmap1; Set color map1 colors using 8-bit RGB values, plscmap0; Set color map0 colors by 8-bit RGB values, The Common API for PLplot
@section   plscmap0n: Set number of colors in color map0  


@quotation

@t{
@b{plscmap0n}
(@i{ncol0});}
@end quotation

Set number of colors in color map0 (see @ref{Color Map0,,Color Map0}.). Allocate (or reallocate) color map0,
and fill with default values for those colors not previously allocated.
The first 16 default colors are given in the @code{plcol0} (@pxref{plcol0; Set color; map0}) documentation.
For larger indices the default color is red. 

The drivers are not guaranteed to support more than 16 colors.

@table @asis

@item   @code{ncol0}  (@samp{PLINT}, input)  
Number of colors that will be allocated in the map0 palette.
If this number is zero or less, then the value from the
previous call to @code{plscmap0n} (@pxref{plscmap0n; Set number of colors in color map0}) is used and if there is no
previous call, then a default value is used.
@end table

@node plscmap1; Set color map1 colors using 8-bit RGB values, plscmap1l; Set color map1 colors using a piece-wise linear relationship, plscmap0n; Set number of colors in color map0, The Common API for PLplot
@section   plscmap1: Set color map1 colors using 8-bit RGB values  


@quotation

@t{
@b{plscmap1}
(@i{r}, @i{g}, @i{b}, @i{ncol1});}
@end quotation

Set color map1 colors using 8-bit RGB values (see @ref{Color Map1,,Color Map1}.). This also sets the number of colors.

@table @asis

@item   @code{r}  (@samp{PLINT *}, input)  
Pointer to array with set of unsigned 8-bit integers (0-255)
representing the degree of red in the color.

@item   @code{g}  (@samp{PLINT *}, input)  
Pointer to array with set of unsigned 8-bit integers (0-255)
representing the degree of green in the color.

@item   @code{b}  (@samp{PLINT *}, input)  
Pointer to array with set of unsigned 8-bit integers (0-255)
representing the degree of blue in the color.

@item   @code{ncol1}  (@samp{PLINT}, input)  
Number of items in the
@samp{@code{r}},
@samp{@code{g}}, and
@samp{@code{b}} arrays.
@end table

@node plscmap1l; Set color map1 colors using a piece-wise linear relationship, plscmap1n; Set number of colors in color map1, plscmap1; Set color map1 colors using 8-bit RGB values, The Common API for PLplot
@section   plscmap1l: Set color map1 colors using a piece-wise linear relationship  


@quotation

@t{
@b{plscmap1l}
(@i{itype}, @i{npts}, @i{pos}, @i{coord1}, @i{coord2}, @i{coord3}, @i{rev});}
@end quotation

Set color map1 colors using a piece-wise linear relationship
between position in the color map (from 0 to 1) and position in HLS or
RGB color space (see @ref{Color Map1,,Color Map1}.). May be called at
any time. 

The idea here is to specify a number of control points that define
the mapping between palette 1 input positions (intensities) and HLS (or RGB). Between
these points, linear interpolation is used which
gives a smooth variation of
color with input position. Any number of control points may be specified,
located at arbitrary positions, although typically 2 - 4
are enough. Another way of stating this is that we are traversing a
given number of lines through HLS (or RGB) space as we move through
color map1 entries. The control points at the minimum and maximum
position (0 and 1) must always be specified. By adding more control
points you can get more variation. One good technique for plotting
functions that vary about some expected average is to use an
additional 2 control points in the center (position ~= 0.5) that are
the same lightness as the background (typically white for paper output,
black for crt), and same hue as the boundary control points. This
allows the highs and lows to be very easily distinguished.

Each control point must specify the position in color map1 as well as
three coordinates in HLS or RGB space. The first point
@i{must} correspond to position = 0, and the last to
position = 1.

The hue is interpolated around the "front" of the color wheel
(red<->green<->blue<->red) unless the "rev" flag is set, in
which case interpolation (between the @samp{i} and
@samp{i + 1} control point for @samp{rev[i]})
proceeds around the back (reverse) side. Specifying rev=NULL is
equivalent to setting rev[]=0 for every control point. 


@strong{ Bounds on coordinates}

@multitable @columnfractions 0.25 0.25 0.25 0.25
@item
RGB@tab R@tab [0, 1]@tab magnitude
@item
RGB@tab G@tab [0, 1]@tab magnitude
@item
RGB@tab B@tab [0, 1]@tab magnitude
@item
HLS@tab hue@tab [0, 360]@tab degrees
@item
HLS@tab lightness@tab [0, 1]@tab magnitude
@item
HLS@tab saturation@tab [0, 1]@tab magnitude
@end multitable

@table @asis

@item   @code{itype}  (@samp{PLINT}, input)  
0: HLS, 1: RGB

@item   @code{npts}  (@samp{PLINT}, input)  
number of control points

@item   @code{pos}  (@samp{PLFLT *}, input)  
position for each control point (between 0.0 and 1.0, in
ascending order)

@item   @code{coord1}  (@samp{PLFLT *}, input)  
first coordinate (H or R) for each control point

@item   @code{coord2}  (@samp{PLFLT *}, input)  
second coordinate (L or G) for each control point

@item   @code{coord3}  (@samp{PLFLT *}, input)  
third coordinate (S or B) for each control point

@item   @code{rev}  (@samp{PLINT *}, input)  
reverse flag for each control point (@samp{rev[i]} refers
to the interpolation interval between the @samp{i} and
@samp{i + 1} control points).
@end table

@node plscmap1n; Set number of colors in color map1, plscol0; Set a given color from color map0 by 8 bit RGB value, plscmap1l; Set color map1 colors using a piece-wise linear relationship, The Common API for PLplot
@section   plscmap1n: Set number of colors in color map1  


@quotation

@t{
@b{plscmap1n}
(@i{ncol1});}
@end quotation

Set number of colors in color map1, (re-)allocate color map1, and
set default values if this is the first allocation (see @ref{Color Map1,,Color Map1}.). 

@table @asis

@item   @code{ncol1}  (@samp{PLINT}, input)  
Number of colors that will be allocated in the map1 palette.
If this number is zero or less, then the value from the
previous call to @code{plscmap1n} (@pxref{plscmap1n; Set number of colors in color map1}) is used and if there is no
previous call, then a default value is used.
@end table

@node plscol0; Set a given color from color map0 by 8 bit RGB value, plscolbg; Set the background color by 8-bit RGB value, plscmap1n; Set number of colors in color map1, The Common API for PLplot
@section   plscol0: Set a given color from color map0 by 8 bit RGB value  


@quotation

@t{
@b{plscol0}
(@i{icol0}, @i{r}, @i{g}, @i{b});}
@end quotation

Set a given color by 8-bit RGB value for color map0 (see @ref{Color Map0,,Color Map0}.). Overwrites
the previous color value for the given index and, thus, does
not result in any additional allocation of space for colors. 

@table @asis

@item   @code{icol0}  (@samp{PLINT}, input)  
Color index. Must be less than the maximum number of colors
(which is set by default, by @code{plscmap0n} (@pxref{plscmap0n; Set number of colors in color map0}), or even by @code{plscmap0} (@pxref{plscmap0; Set color map0 colors by 8-bit RGB values})).

@item   @code{r}  (@samp{PLINT}, input)  
Unsigned 8-bit integer (0-255) representing
the degree of red in the color.

@item   @code{g}  (@samp{PLINT}, input)  
Unsigned 8-bit integer (0-255) representing
the degree of green in the color.

@item   @code{b}  (@samp{PLINT}, input)  
Unsigned 8-bit integer (0-255) representing
the degree of blue in the color.
@end table

@node plscolbg; Set the background color by 8-bit RGB value, plscolor; Used to globally turn color output on/off, plscol0; Set a given color from color map0 by 8 bit RGB value, The Common API for PLplot
@section   plscolbg: Set the background color by 8-bit RGB value  


@quotation

@t{
@b{plscolbg}
(@i{r}, @i{g}, @i{b});}
@end quotation

Set the background color (color 0 in color map 0) by 8-bit RGB value (see
@ref{Color Map0,,Color Map0}.).

@table @asis

@item   @code{r}  (@samp{PLINT}, input)  
Unsigned 8-bit integer (0-255) representing
the degree of red in the color.

@item   @code{g}  (@samp{PLINT}, input)  
Unsigned 8-bit integer (0-255) representing
the degree of green in the color.

@item   @code{b}  (@samp{PLINT}, input)  
Unsigned 8-bit integer (0-255) representing
the degree of blue in the color.
@end table

@node plscolor; Used to globally turn color output on/off, plscompression; Set device-compression level, plscolbg; Set the background color by 8-bit RGB value, The Common API for PLplot
@section   plscolor: Used to globally turn color output on/off  


@quotation

@t{
@b{plscolor}
(@i{color});}
@end quotation

Used to globally turn color output on/off for those drivers/devices
that support it.

@table @asis

@item   @code{color}  (@samp{PLINT}, input)  
Color flag (Boolean). If zero, color is turned off. If
non-zero, color is turned on.
@end table

@node plscompression; Set device-compression level, plsdev; Set the device [keyword] name, plscolor; Used to globally turn color output on/off, The Common API for PLplot
@section   plscompression: Set device-compression level  


@quotation

@t{
@b{plscompression}
(@i{compression});}
@end quotation

Set device-compression level. Only used for drivers that provide
compression. This function, if used, should be invoked
before a call to @code{plinit} (@pxref{plinit; Initialize PLplot}).

@table @asis

@item   @code{compression}  (@samp{PLINT}, input)  
The desired compression level. This is a device-dependent
value.
@end table

@node plsdev; Set the device [keyword] name, plsdidev; Set parameters that define current device-space window, plscompression; Set device-compression level, The Common API for PLplot
@section   plsdev: Set the device (keyword) name  


@quotation

@t{
@b{plsdev}
(@i{devname});}
@end quotation

Set the device (keyword) name.

@table @asis

@item   @code{devname}  (@samp{const char *}, output)  
Pointer to device (keyword) name string.
@end table

@node plsdidev; Set parameters that define current device-space window, plsdimap; Set up transformation from metafile coordinates, plsdev; Set the device [keyword] name, The Common API for PLplot
@section   plsdidev: Set parameters that define current  device-space window  


@quotation

@t{
@b{plsdidev}
(@i{mar}, @i{aspect}, @i{jx}, @i{jy});}
@end quotation

Set relative margin width, aspect ratio, and relative
justification that define current device-space window. If you want to just use the previous value for any of
these, just pass in the magic value PL_NOTSET. It is unlikely that one
should ever need to change the aspect ratio but it's in there for
completeness.
If @code{plsdidev} (@pxref{plsdidev; Set parameters that define current device-space window}) is not called the default values
of @samp{@code{mar}},
@samp{@code{jx}}, and
@samp{@code{jy}}
are all 0. @samp{@code{aspect}}
is set to a device-specific value.

@table @asis

@item   @code{mar}  (@samp{PLFLT}, input)  
Relative margin width.

@item   @code{aspect}  (@samp{PLFLT}, input)  
Aspect ratio.

@item   @code{jx}  (@samp{PLFLT}, input)  
Relative justification in x.

@item   @code{jy}  (@samp{PLFLT}, input)  
Relative justification in y.
@end table

@node plsdimap; Set up transformation from metafile coordinates, plsdiori; Set plot orientation, plsdidev; Set parameters that define current device-space window, The Common API for PLplot
@section   plsdimap: Set up transformation from metafile coordinates  


@quotation

@t{
@b{plsdimap}
(@i{dimxmin}, @i{dimxmax}, @i{dimymin}, @i{dimymax}, @i{dimxpmm}, @i{dimypmm});}
@end quotation

Set up transformation from metafile coordinates. The size of the plot
is scaled so as to preserve aspect ratio. This isn't intended to be a
general-purpose facility just yet (not sure why the user would need
it, for one).

@table @asis

@item   @code{dimxmin}  (@samp{PLINT}, input)  
NEEDS DOCUMENTATION

@item   @code{dimxmax}  (@samp{PLINT}, input)  
NEEDS DOCUMENTATION

@item   @code{dimymin}  (@samp{PLINT}, input)  
NEEDS DOCUMENTATION

@item   @code{dimymax}  (@samp{PLINT}, input)  
NEEDS DOCUMENTATION

@item   @code{dimxpmm}  (@samp{PLFLT}, input)  
NEEDS DOCUMENTATION

@item   @code{dimypmm}  (@samp{PLFLT}, input)  
NEEDS DOCUMENTATION
@end table

@node plsdiori; Set plot orientation, plsdiplt; Set parameters that define current plot-space window, plsdimap; Set up transformation from metafile coordinates, The Common API for PLplot
@section   plsdiori: Set plot orientation  


@quotation

@t{
@b{plsdiori}
(@i{rot});}
@end quotation

Set plot orientation parameter which is multiplied by 90 degrees to
obtain the angle of rotation. Note, arbitrary rotation parameters such as 0.2
(corresponding to 18 degrees) are possible, but the usual values for
the rotation parameter are 0., 1., 2., and 3. corresponding to 0 degrees
(landscape mode), 90 degrees (portrait mode), 180 degrees (seascape
mode), and 270 degrees (upside-down mode).
If @code{plsdiori} (@pxref{plsdiori; Set plot orientation}) is not called the default value
of @samp{@code{rot}}
is 0.

@table @asis

@item   @code{rot}  (@samp{PLFLT}, input)  
Plot orientation parameter.
@end table

@node plsdiplt; Set parameters that define current plot-space window, plsdiplz; Set parameters incrementally [zoom mode] that define current plot-space window, plsdiori; Set plot orientation, The Common API for PLplot
@section   plsdiplt: Set parameters that define current  plot-space window  


@quotation

@t{
@b{plsdiplt}
(@i{xmin}, @i{ymin}, @i{xmax}, @i{ymax});}
@end quotation

Set relative minima and maxima that define the current
plot-space window. If @code{plsdiplt} (@pxref{plsdiplt; Set parameters that define current plot-space window}) is not called the default values
of @samp{@code{xmin}},
@samp{@code{ymin}},
@samp{@code{xmax}}, and
@samp{@code{ymax}}
are 0., 0., 1., and 1.

@table @asis

@item   @code{xmin}  (@samp{PLFLT}, input)  
Relative minimum in x.

@item   @code{ymin}  (@samp{PLFLT}, input)  
Relative minimum in y.

@item   @code{xmax}  (@samp{PLFLT}, input)  
Relative maximum in x.

@item   @code{ymax}  (@samp{PLFLT}, input)  
Relative maximum in y.
@end table

@node plsdiplz; Set parameters incrementally [zoom mode] that define current plot-space window, plsesc; Set the escape character for text strings, plsdiplt; Set parameters that define current plot-space window, The Common API for PLplot
@section   plsdiplz: Set parameters incrementally (zoom mode)  that define current plot-space window  


@quotation

@t{
@b{plsdiplz}
(@i{xmin}, @i{ymin}, @i{xmax}, @i{ymax});}
@end quotation

Set relative minima and maxima incrementally (zoom mode)
that define the current plot-space window. This function has
the same effect as @code{plsdiplt} (@pxref{plsdiplt; Set parameters that define current plot-space window}) if that function has not been previously
called. Otherwise, this function implements zoom mode using the
transformation @samp{min_used = old_min + old_length*min }
and @samp{max_used = old_min + old_length*max } for
each axis. For example, if @samp{min = 0.05} and
@samp{max = 0.95} for each axis, repeated calls to
@code{plsdiplz} (@pxref{plsdiplz; Set parameters incrementally [zoom mode] that define current plot-space window}) will zoom in by 10 per cent for each call.

@table @asis

@item   @code{xmin}  (@samp{PLFLT}, input)  
Relative (incremental) minimum in x.

@item   @code{ymin}  (@samp{PLFLT}, input)  
Relative (incremental) minimum in y.

@item   @code{xmax}  (@samp{PLFLT}, input)  
Relative (incremental) maximum in x.

@item   @code{ymax}  (@samp{PLFLT}, input)  
Relative (incremental) maximum in y.
@end table

@node plsesc; Set the escape character for text strings, plsetopt; Set any command-line option, plsdiplz; Set parameters incrementally [zoom mode] that define current plot-space window, The Common API for PLplot
@section   plsesc: Set the escape character for text strings  


@quotation

@t{
@b{plsesc}
(@i{esc});}
@end quotation

Set the escape character for text strings. From C (in contrast to
fortran, see @code{plsescfortran} (@pxref{plsesc; Set the escape character for text strings for fortran})) you pass
@samp{@code{esc}} as a character.
Only selected characters are allowed to prevent the user from shooting
himself in the foot (For example, a \ isn't allowed since it conflicts with C's use
of backslash as a character escape). Here are the allowed escape
characters and their corresponding decimal ASCII values:

@itemize @bullet{}

@item
!, ASCII 33

@item
#, ASCII 35

@item
$, ASCII 36

@item
%, ASCII 37

@item
&, ASCII 38

@item
*, ASCII 42

@item
@@, ASCII 64

@item
^, ASCII 94

@item
~, ASCII 126
@end itemize

@table @asis

@item   @code{esc}  (@samp{char}, input)  
Escape character.
@end table

@node plsetopt; Set any command-line option, plsfam; Set family file parameters, plsesc; Set the escape character for text strings, The Common API for PLplot
@section   plsetopt: Set any command-line option  


@quotation

@t{
@b{plsetopt}
(@i{opt}, @i{optarg});}
@end quotation

Set any command-line option internally from a program before it invokes
@code{plinit} (@pxref{plinit; Initialize PLplot}). @samp{opt} is the name of the command-line
option and @samp{optarg} is the corresponding command-line
option argument.

@table @asis

@item   @code{opt}  (@samp{const char *}, output)  
Pointer to string containing the command-line option.

@item   @code{optarg}  (@samp{const char *}, output)  
Pointer to string containing the argument of the command-line
option.
@end table

@node plsfam; Set family file parameters, plsfci; Set FCI [font characterization integer], plsetopt; Set any command-line option, The Common API for PLplot
@section   plsfam: Set family file parameters  


@quotation

@t{
@b{plsfam}
(@i{fam}, @i{num}, @i{bmax});}
@end quotation

Sets variables dealing with output file familying. Does nothing if
familying not supported by the driver. This routine, if used, must
be called before initializing PLplot. See @ref{Family File Output,,Family File Output}.
for more information.

@table @asis

@item   @code{fam}  (@samp{PLINT}, input)  
Family flag (Boolean). If nonzero, familying is enabled.

@item   @code{num}  (@samp{PLINT}, input)  
Current family file number.

@item   @code{bmax}  (@samp{PLINT}, input)  
Maximum file size (in bytes) for a family file.
@end table

@node plsfci; Set FCI [font characterization integer], plsfnam; Set output file name, plsfam; Set family file parameters, The Common API for PLplot
@section   plsfci: Set FCI (font characterization integer)  


@quotation

@t{
@b{plsfci}
(@i{fci});}
@end quotation

Sets font characteristics to be used at the start of the next string
using the FCI approach.
See @ref{FCI,,FCI}. for more information.

@table @asis

@item   @code{fci}  (@samp{PLUNICODE}, input)  
PLUNICODE (unsigned 32-bit integer) value of FCI.
@end table

@node plsfnam; Set output file name, plshades; Shade regions on the basis of value, plsfci; Set FCI [font characterization integer], The Common API for PLplot
@section   plsfnam: Set output file name  


@quotation

@t{
@b{plsfnam}
(@i{fnam});}
@end quotation

Sets the current output file name, if applicable. If the file name
has not been specified and is required by the driver, the user will
be prompted for it. If using the X-windows output driver, this sets
the display name. This routine, if used, must be called before
initializing PLplot.

@table @asis

@item   @code{fnam}  (@samp{const char *}, input)  
Pointer to file name string.
@end table

@node plshades; Shade regions on the basis of value, plshade; Shade individual region on the basis of value, plsfnam; Set output file name, The Common API for PLplot
@section   plshades: Shade regions on the basis of value  


@quotation

@t{
@b{plshades}
(@i{a}, @i{nx}, @i{ny}, @i{defined}, @i{xmin}, @i{xmax}, @i{ymin}, @i{ymax}, @i{clevel}, @i{nlevel}, @i{fill_width}, @i{cont_color}, @i{cont_width}, @i{fill}, @i{rectangular}, @i{pltr}, @i{pltr_data});}
@end quotation

Shade regions on the basis of value. This is the high-level routine
for making continuous color shaded plots with cmap1 while
@code{plshade} (@pxref{plshade; Shade individual region on the basis of value}) (or @code{plshade1} (@pxref{plshade1; Shade individual region on the basis of value})) are used for individual shaded regions
using either cmap0 or cmap1.
@file{examples/c/x16c.c} shows a number of examples
for using this function.
See the following discussion of the
arguments and @ref{Contour and Shade Plots,,Contour and Shade Plots}. for
more information. 

@table @asis

@item   @code{a}  (@samp{PLFLT **}, input)  
Contains ** pointer to array to be plotted. The array must have been declared
as PLFLT a[nx][ny].

@item   @code{nx}  (@samp{PLINT}, input)  
First dimension of array "a".

@item   @code{ny}  (@samp{PLINT}, input)  
Second dimension of array "a".

@item   @code{defined}  (@samp{PLINT (*) (PLFLT, PLFLT)}, input)  
User function specifying regions excluded from the shading
plot. This function accepts x and y coordinates as input
arguments and must return 0 if the point is in the excluded
region or 1 otherwise. This argument can be NULL if all the
values are valid.

@item   @code{xmin}  (@samp{PLFLT}, input)  
Defines the "grid" coordinates. The data a[0][0] has a
position of (xmin,ymin), a[nx-1][0] has a position at (xmax,ymin)
and so on.
(xmax,ymin)

@item   @code{xmax}  (@samp{PLFLT}, input)  
Defines the "grid" coordinates. The data a[0][0] has a
position of (xmin,ymin), a[nx-1][0] has a position at (xmax,ymin)
and so on.

@item   @code{ymin}  (@samp{PLFLT}, input)  
Defines the "grid" coordinates. The data a[0][0] has a
position of (xmin,ymin), a[nx-1][0] has a position at (xmax,ymin)
and so on.

@item   @code{ymax}  (@samp{PLFLT}, input)  
Defines the "grid" coordinates. The data a[0][0] has a
position of (xmin,ymin), a[nx-1][0] has a position at (xmax,ymin)
and so on.

@item   @code{clevel}  (@samp{PLFLT *}, input)  
Pointer to array containing the data levels corresponding to
the edges of each shaded region that will be plotted by this
function. To work properly the levels should be monotonic.

@item   @code{nlevel}  (@samp{PLINT}, input)  
Number of shades plus 1 (i.e., the number of shade edge values
in @samp{@code{clevel}}).

@item   @code{fill_width}  (@samp{PLINT}, input)  
Defines width used by the fill pattern.

@item   @code{cont_color}  (@samp{PLINT}, input)  
Defines pen color used for contours defining edges of shaded
regions. The pen color is only temporary set for the
contour drawing. Set this value to zero or less if no shade edge contours are wanted.

@item   @code{cont_width}  (@samp{PLINT}, input)  
Defines pen width used for contours defining edges of shaded
regions. This value may not be honored by all drivers.
The pen width is only temporary set for the
contour drawing. Set this value to zero or less if no shade edge contours are wanted.

@item   @code{fill}  (@samp{void (*) (PLINT, PLFLT *, PLFLT *)}, input)  
Routine used to fill the region. Use @code{plfill} (@pxref{plfill; Draw filled polygon}). Future version of
PLplot may have other fill routines.

@item   @code{rectangular}  (@samp{PLINT}, input)  
Set @samp{@code{rectangular}} to 1
if rectangles map to rectangles after coordinate transformation
with @samp{@code{pltrl}}. Otherwise,
set @samp{@code{rectangular}} to 0.
If @samp{@code{rectangular}}
is set to 1, plshade tries to save time by
filling large rectangles. This optimization fails if
the coordinate transformation distorts the shape of rectangles.
For example a plot in polor coordinates has to have rectangular
set to 0.

@item   @code{pltr}  (@samp{void (*) (PLFLT, PLFLT, PLFLT *, PLFLT *, PLPointer)  }, input)  
Pointer to function that defines transformation between indices
in array @samp{@code{z}} and the
world coordinates (C only). Transformation functions are
provided in the PLplot library:
@code{pltr0} (@pxref{pltr0; Identity transformation for grid to world mapping}) for identity mapping, and @code{pltr1} (@pxref{pltr1; Linear interpolation for grid to world mapping using singly dimensioned coord arrays}) and @code{pltr2} (@pxref{pltr2; Linear interpolation for grid to world mapping using doubly dimensioned coord arrays [column dominant; as per normal C 2d arrays]}) for
arbitrary mappings respectively defined by one- and
two-dimensional arrays. In addition, user-supplied routines
for the transformation can be used as well. Examples of
all of these approaches are given in
@ref{Contour Plots from C,,Contour Plots from C}..
The transformation function should
have the form given by any of @code{pltr0} (@pxref{pltr0; Identity transformation for grid to world mapping}), @code{pltr1} (@pxref{pltr1; Linear interpolation for grid to world mapping using singly dimensioned coord arrays}), or @code{pltr2} (@pxref{pltr2; Linear interpolation for grid to world mapping using doubly dimensioned coord arrays [column dominant; as per normal C 2d arrays]}).

@item   @code{pltr_data}  (@samp{PLPointer}, input)  
Extra parameter to help
pass information to @code{pltr0} (@pxref{pltr0; Identity transformation for grid to world mapping}), @code{pltr1} (@pxref{pltr1; Linear interpolation for grid to world mapping using singly dimensioned coord arrays}), @code{pltr2} (@pxref{pltr2; Linear interpolation for grid to world mapping using doubly dimensioned coord arrays [column dominant; as per normal C 2d arrays]}), or whatever routine
that is externally supplied.
@end table

@node plshade; Shade individual region on the basis of value, plshade1; Shade individual region on the basis of value, plshades; Shade regions on the basis of value, The Common API for PLplot
@section   plshade: Shade individual region on the basis of value  


@quotation

@t{
@b{plshade}
(@i{a}, @i{nx}, @i{ny}, @i{defined}, @i{xmin}, @i{xmax}, @i{ymin}, @i{ymax}, @i{shade_min}, @i{shade_max}, @i{sh_cmap}, @i{sh_color}, @i{sh_width}, @i{min_color}, @i{min_width}, @i{max_color}, @i{max_width}, @i{fill}, @i{rectangular}, @i{pltr}, @i{pltr_data});}
@end quotation

Shade individual region on the basis of value. Use @code{plshades} (@pxref{plshades; Shade regions on the basis of value}) if you want to
shade a number of regions using continuous colors.
@code{plshade} (@pxref{plshade; Shade individual region on the basis of value}) is identical to @code{plshade1} (@pxref{plshade1; Shade individual region on the basis of value})
except for the type of the first parameter.
See @code{plshade1} (@pxref{plshade1; Shade individual region on the basis of value}) for further discussion.

@table @asis

@item   @code{a}  (@samp{PLFLT **}, input)  

@item   @code{nx}  (@samp{PLINT}, input)  

@item   @code{ny}  (@samp{PLINT}, input)  

@item   @code{defined}  (@samp{PLINT (*) (PLFLT, PLFLT)}, input)  

@item   @code{xmin}  (@samp{PLFLT}, input)  

@item   @code{xmax}  (@samp{PLFLT}, input)  

@item   @code{ymin}  (@samp{PLFLT}, input)  

@item   @code{ymax}  (@samp{PLFLT}, input)  

@item   @code{shade_min}  (@samp{PLFLT}, input)  

@item   @code{shade_max}  (@samp{PLFLT}, input)  

@item   @code{sh_cmap}  (@samp{PLINT}, input)  

@item   @code{sh_color}  (@samp{PLFLT}, input)  

@item   @code{sh_width}  (@samp{PLINT}, input)  

@item   @code{min_color}  (@samp{PLINT}, input)  

@item   @code{min_width}  (@samp{PLINT}, input)  

@item   @code{max_color}  (@samp{PLINT}, input)  

@item   @code{max_width}  (@samp{PLINT}, input)  

@item   @code{fill}  (@samp{void (*) (PLINT, PLFLT *, PLFLT *)}, input)  

@item   @code{rectangular}  (@samp{PLINT}, input)  

@item   @code{pltr}  (@samp{void (*) (PLFLT, PLFLT, PLFLT *, PLFLT *, PLPointer)  }, input)  

@item   @code{pltr_data}  (@samp{PLPointer}, input)  
@end table

@node plshade1; Shade individual region on the basis of value, plsmaj; Set length of major ticks, plshade; Shade individual region on the basis of value, The Common API for PLplot
@section   plshade1: Shade individual region on the basis of value  


@quotation

@t{
@b{plshade1}
(@i{a}, @i{nx}, @i{ny}, @i{defined}, @i{xmin}, @i{xmax}, @i{ymin}, @i{ymax}, @i{shade_min}, @i{shade_max}, @i{sh_cmap}, @i{sh_color}, @i{sh_width}, @i{min_color}, @i{min_width}, @i{max_color}, @i{max_width}, @i{fill}, @i{rectangular}, @i{pltr}, @i{pltr_data});}
@end quotation

Shade individual region on the basis of value. Use @code{plshades} (@pxref{plshades; Shade regions on the basis of value}) if you want to
shade a number of contiguous regions using continuous colors. In
particular the edge contours are treated properly in @code{plshades} (@pxref{plshades; Shade regions on the basis of value}).
If you attempt to do contiguous regions with @code{plshade1} (@pxref{plshade1; Shade individual region on the basis of value}) (or @code{plshade} (@pxref{plshade; Shade individual region on the basis of value}))
the contours at the edge of the shade are partially obliterated by subsequent
plots of contiguous shaded regions.
@code{plshade1} (@pxref{plshade1; Shade individual region on the basis of value}) differs from @code{plshade} (@pxref{plshade; Shade individual region on the basis of value}) by the type of the first
argument. Look at the argument list below, @code{plcont} (@pxref{plcont; Contour plot}) and
@ref{Contour and Shade Plots,,Contour and Shade Plots}. for
more information about the transformation from grid to world
coordinates. Shading NEEDS DOCUMENTATION, but
as a stopgap look at how @code{plshade} (@pxref{plshade; Shade individual region on the basis of value}) is used in
@file{examples/c/x15c.c}

@table @asis

@item   @code{a}  (@samp{PLFLT *}, input)  
Contains array to be plotted. The array must have been declared
as PLFLT a[nx][ny].

@item   @code{nx}  (@samp{PLINT}, input)  
First dimension of array "a".

@item   @code{ny}  (@samp{PLINT}, input)  
Second dimension of array "a".

@item   @code{defined}  (@samp{PLINT (*) (PLFLT, PLFLT)}, input)  
User function specifying regions excluded from the shading
plot. This function accepts x and y coordinates as input
arguments and must return 0 if the point is in the excluded
region or 1 otherwise. This argument can be NULL if all the
values are valid.

@item   @code{xmin}  (@samp{PLFLT}, input)  
Defines the "grid" coordinates. The data a[0][0] has a
position of (xmin,ymin), a[nx-1][0] has a position at (xmax,ymin)
and so on.

@item   @code{xmax}  (@samp{PLFLT}, input)  
Defines the "grid" coordinates. The data a[0][0] has a
position of (xmin,ymin), a[nx-1][0] has a position at (xmax,ymin)
and so on.

@item   @code{ymin}  (@samp{PLFLT}, input)  
Defines the "grid" coordinates. The data a[0][0] has a
position of (xmin,ymin), a[nx-1][0] has a position at (xmax,ymin)
and so on.

@item   @code{ymax}  (@samp{PLFLT}, input)  
Defines the "grid" coordinates. The data a[0][0] has a
position of (xmin,ymin), a[nx-1][0] has a position at (xmax,ymin)
and so on.

@item   @code{shade_min}  (@samp{PLFLT}, input)  
Defines the lower end of the interval to be shaded. If
shade_max <= shade_min, @code{plshade1} (@pxref{plshade1; Shade individual region on the basis of value}) does nothing.

@item   @code{shade_max}  (@samp{PLFLT}, input)  
Defines the upper end of the interval to be shaded. If
shade_max <= shade_min,
@code{plshade1} (@pxref{plshade1; Shade individual region on the basis of value}) does nothing.

@item   @code{sh_cmap}  (@samp{PLINT}, input)  
Defines color map.

@item   @code{sh_color}  (@samp{PLFLT}, input)  
Defines color map index if cmap0 or color map input value (ranging
from 0. to 1.) if cmap1.

@item   @code{sh_width}  (@samp{PLINT}, input)  
Defines width used by the fill pattern.

@item   @code{min_color}  (@samp{PLINT}, input)  
Defines pen color, width used by the boundary of shaded region.
The min values are used for the shade_min boundary, and the max
values are used on the shade_max boundary. Set color and width
to zero for no plotted boundaries.

@item   @code{min_width}  (@samp{PLINT}, input)  
Defines pen color, width used by the boundary of shaded region.
The min values are used for the shade_min boundary, and the max
values are used on the shade_max boundary. Set color and width
to zero for no plotted boundaries.

@item   @code{max_color}  (@samp{PLINT}, input)  
Defines pen color, width used by the boundary of shaded region.
The min values are used for the shade_min boundary, and the max
values are used on the shade_max boundary. Set color and width
to zero for no plotted boundaries.

@item   @code{max_width}  (@samp{PLINT}, input)  
Defines pen color, width used by the boundary of shaded region.
The min values are used for the shade_min boundary, and the max
values are used on the shade_max boundary. Set color and width
to zero for no plotted boundaries.

@item   @code{fill}  (@samp{void (*) (PLINT, PLFLT *, PLFLT *)}, input)  
Routine used to fill the region. Use @code{plfill} (@pxref{plfill; Draw filled polygon}). Future version of
plplot may have other fill routines.

@item   @code{rectangular}  (@samp{PLINT}, input)  
Set @samp{@code{rectangular}} to 1
if rectangles map to rectangles after coordinate transformation
with @samp{@code{pltrl}}. Otherwise,
set @samp{@code{rectangular}} to 0.
If @samp{@code{rectangular}}
is set to 1, plshade tries to save time by
filling large rectangles. This optimization fails if
the coordinate transformation distorts the shape of rectangles.
For example a plot in polor coordinates has to have rectangular
set to 0.

@item   @code{pltr}  (@samp{void (*) (PLFLT, PLFLT, PLFLT *, PLFLT *, PLPointer)  }, input)  
Pointer to function that defines transformation between indices
in array @samp{@code{z}} and the
world coordinates (C only). Transformation functions are
provided in the PLplot library:
@code{pltr0} (@pxref{pltr0; Identity transformation for grid to world mapping}) for identity mapping, and @code{pltr1} (@pxref{pltr1; Linear interpolation for grid to world mapping using singly dimensioned coord arrays}) and @code{pltr2} (@pxref{pltr2; Linear interpolation for grid to world mapping using doubly dimensioned coord arrays [column dominant; as per normal C 2d arrays]}) for
arbitrary mappings respectively defined by one- and
two-dimensional arrays. In addition, user-supplied routines
for the transformation can be used as well. Examples of
all of these approaches are given in
@ref{Contour Plots from C,,Contour Plots from C}..
The transformation function should
have the form given by any of @code{pltr0} (@pxref{pltr0; Identity transformation for grid to world mapping}), @code{pltr1} (@pxref{pltr1; Linear interpolation for grid to world mapping using singly dimensioned coord arrays}), or @code{pltr2} (@pxref{pltr2; Linear interpolation for grid to world mapping using doubly dimensioned coord arrays [column dominant; as per normal C 2d arrays]}).

@item   @code{pltr_data}  (@samp{PLPointer}, input)  
Extra parameter to help
pass information to @code{pltr0} (@pxref{pltr0; Identity transformation for grid to world mapping}), @code{pltr1} (@pxref{pltr1; Linear interpolation for grid to world mapping using singly dimensioned coord arrays}), @code{pltr2} (@pxref{pltr2; Linear interpolation for grid to world mapping using doubly dimensioned coord arrays [column dominant; as per normal C 2d arrays]}), or whatever routine
that is externally supplied.
@end table

@node plsmaj; Set length of major ticks, plsmem; Set the memory area to be plotted, plshade1; Shade individual region on the basis of value, The Common API for PLplot
@section   plsmaj: Set length of major ticks  


@quotation

@t{
@b{plsmaj}
(@i{def}, @i{scale});}
@end quotation

This sets up the length of the major ticks. The actual length is the
product of the default length and a scaling factor as for character
height.

@table @asis

@item   @code{def}  (@samp{PLFLT}, input)  
The default length of a major tick in millimeters, should be
set to zero if the default length is to remain unchanged.

@item   @code{scale}  (@samp{PLFLT}, input)  
Scale factor to be applied to default to get actual tick
length.
@end table

@node plsmem; Set the memory area to be plotted, plsmin; Set length of minor ticks, plsmaj; Set length of major ticks, The Common API for PLplot
@section   plsmem: Set the memory area to be plotted  


@quotation

@t{
@b{plsmem}
(@i{maxx}, @i{maxy}, @i{plotmem});}
@end quotation

Set the memory area to be plotted (with the mem driver)
as the @samp{dev} member of the stream structure. Also
set the number of pixels in the memory passed in
@code{plotmem}, which is a block of memory
@code{maxy} by @code{maxx} by 3 bytes
long, say: 480 x 640 x 3 (Y, X, RGB)

This memory will have to be freed by the user!

@table @asis

@item   @code{maxx}  (@samp{PLINT}, input)  
Size of memory area in the X coordinate.

@item   @code{maxy}  (@samp{PLINT}, input)  
Size of memory area in the Y coordinate.

@item   @code{plotmem}  (@samp{void *}, input)  
Pointer to the beginning of the user-supplied memory area.
@end table

@node plsmin; Set length of minor ticks, plsori; Set orientation, plsmem; Set the memory area to be plotted, The Common API for PLplot
@section   plsmin: Set length of minor ticks  


@quotation

@t{
@b{plsmin}
(@i{def}, @i{scale});}
@end quotation

This sets up the length of the minor ticks and the length of the
terminals on error bars. The actual length is the product of the
default length and a scaling factor as for character height.

@table @asis

@item   @code{def}  (@samp{PLFLT}, input)  
The default length of a minor tick in millimeters, should be
set to zero if the default length is to remain unchanged.

@item   @code{scale}  (@samp{PLFLT}, input)  
Scale factor to be applied to default to get actual tick
length.
@end table

@node plsori; Set orientation, plspage; Set page parameters, plsmin; Set length of minor ticks, The Common API for PLplot
@section   plsori: Set orientation  


@quotation

@t{
@b{plsori}
(@i{ori});}
@end quotation

Sets the current orientation. If
@samp{@code{ori}} is equal to zero
(default) then landscape is used (x axis is parallel to the longest
edge of the page), otherwise portrait is used. This option is not
supported by all output drivers (in particular, most interactive
screen drivers ignore the orientation). This routine, if used, must
be called before initializing PLplot.

@table @asis

@item   @code{ori}  (@samp{PLINT}, input)  
Orientation value (0 for landscape, 1 for portrait; the value is
multiplied by 90 degrees to get the angle)
@end table

@node plspage; Set page parameters, plspause; Set the pause [on end-of-page] status, plsori; Set orientation, The Common API for PLplot
@section   plspage: Set page parameters  


@quotation

@t{
@b{plspage}
(@i{xp}, @i{yp}, @i{xleng}, @i{yleng}, @i{xoff}, @i{yoff});}
@end quotation

Sets the page configuration (optional). Not all parameters are
recognized by all drivers and the interpretation is device-dependent.
The X-window driver uses the length and offset parameters to determine
the window size and location. This routine, if used, must be called
before initializing PLplot.

@table @asis

@item   @code{xp}  (@samp{PLFLT}, input)  
Number of pixels, x.

@item   @code{yp}  (@samp{PLFLT}, input)  
Number of pixels, y.

@item   @code{xleng}  (@samp{PLINT }, input)  
Page length, x.

@item   @code{yleng}  (@samp{PLINT}, input)  
Page length, y.

@item   @code{xoff}  (@samp{PLINT}, input)  
Page offset, x.

@item   @code{yoff}  (@samp{PLINT}, input)  
Page offset, y.
@end table

@node plspause; Set the pause [on end-of-page] status, plsstrm; Set current output stream, plspage; Set page parameters, The Common API for PLplot
@section   plspause: Set the pause (on end-of-page) status  


@quotation

@t{
@b{plspause}
(@i{pause});}
@end quotation

Set the pause (on end-of-page) status.

@table @asis

@item   @code{pause}  (@samp{PLINT}, input)  
If @samp{@code{pause}} = 1 there
will be a pause on end-of-page for those drivers which support
this. Otherwise there is no pause.
@end table

@node plsstrm; Set current output stream, plssub; Set the number of subpages in x and y, plspause; Set the pause [on end-of-page] status, The Common API for PLplot
@section   plsstrm: Set current output stream  


@quotation

@t{
@b{plsstrm}
(@i{strm});}
@end quotation

Sets the number of the current output stream. The stream number
defaults to 0 unless changed by this routine. The first use of this
routine must be followed by a call initializing PLplot
(e.g. @code{plstar} (@pxref{plstar; Initialization})).

@table @asis

@item   @code{strm}  (@samp{PLINT}, input)  
The current stream number.
@end table

@node plssub; Set the number of subpages in x and y, plssym; Set symbol size, plsstrm; Set current output stream, The Common API for PLplot
@section   plssub: Set the number of subpages in x and y  


@quotation

@t{
@b{plssub}
(@i{nx}, @i{ny});}
@end quotation

Set the number of subpages in x and y.

@table @asis

@item   @code{nx}  (@samp{PLINT}, input)  
Number of windows in x direction (i.e., number of window columns).

@item   @code{ny}  (@samp{PLINT}, input)  
Number of windows in y direction (i.e., number of window rows).
@end table

@node plssym; Set symbol size, plstar; Initialization, plssub; Set the number of subpages in x and y, The Common API for PLplot
@section   plssym: Set symbol size  


@quotation

@t{
@b{plssym}
(@i{def}, @i{scale});}
@end quotation

This sets up the size of all subsequent symbols drawn by @code{plpoin} (@pxref{plpoin; Plots a character at the specified points}) and
@code{plsym} (@pxref{plsym; Plots a symbol at the specified points}). The actual height of a symbol is the product of the default
symbol size and a scaling factor as for the character height.

@table @asis

@item   @code{def}  (@samp{PLFLT}, input)  
The default height of a symbol in millimeters, should be set to
zero if the default height is to remain unchanged.

@item   @code{scale}  (@samp{PLFLT}, input)  
Scale factor to be applied to default to get actual symbol
height.
@end table

@node plstar; Initialization, plstart; Initialization, plssym; Set symbol size, The Common API for PLplot
@section   plstar: Initialization  


@quotation

@t{
@b{plstar}
(@i{nx}, @i{ny});}
@end quotation

Initializing the plotting package. The program prompts for the
device keyword or number of the desired output device. Hitting a
RETURN in response to the prompt is the same as selecting the first
device. If only one device is enabled when PLplot is installed,
@code{plstar} (@pxref{plstar; Initialization}) will issue no prompt. The output device is divided into
@samp{@code{nx}} by
@samp{@code{ny}} subpages, each of which
may be used independently. The subroutine @code{pladv} (@pxref{pladv; Advance the [sub-]page}) is used to advance
from one subpage to the next.

@table @asis

@item   @code{nx}  (@samp{PLINT}, input)  
Number of subpages to divide output page in the horizontal
direction.

@item   @code{ny}  (@samp{PLINT}, input)  
Number of subpages to divide output page in the vertical
direction.
@end table

@node plstart; Initialization, plstripa; Add a point to a stripchart, plstar; Initialization, The Common API for PLplot
@section   plstart: Initialization  


@quotation

@t{
@b{plstart}
(@i{device}, @i{nx}, @i{ny});}
@end quotation

Alternative to @code{plstar} (@pxref{plstar; Initialization}) for initializing the plotting package. The
@samp{@code{device}} name keyword for the
desired output device must be supplied as an argument. The device
keywords are the same as those printed out by @code{plstar} (@pxref{plstar; Initialization}). If the
requested device is not available, or if the input string is empty or
begins with ``?'', the prompted startup of @code{plstar} (@pxref{plstar; Initialization}) is used. This
routine also divides the output device into
@samp{@code{nx}} by
@samp{@code{ny}} subpages, each of which
may be used independently. The subroutine @code{pladv} (@pxref{pladv; Advance the [sub-]page}) is used to advance
from one subpage to the next.

@table @asis

@item   @code{device}  (@samp{const char *}, input)  
Device name (keyword) of the required output device. If NULL
or if the first character is a ``?'', the normal (prompted)
startup is used.

@item   @code{nx}  (@samp{PLINT}, input)  
Number of subpages to divide output page in the horizontal
direction.

@item   @code{ny}  (@samp{PLINT}, input)  
Number of subpages to divide output page in the vertical
direction.
@end table

@node plstripa; Add a point to a stripchart, plstripc; Create a 4-pen stripchart, plstart; Initialization, The Common API for PLplot
@section   plstripa: Add a point to a stripchart  


@quotation

@t{
@b{plstripa}
(@i{id}, @i{p}, @i{x}, @i{y});}
@end quotation

Add a point to a given pen of a given stripchart.
There is no need for all pens to have the same number of
points or to be equally sampled in the x coordinate.
Allocates memory and rescales as
necessary.

@table @asis

@item   @code{id}  (@samp{PLINT}, input)  
Identification number (set up in @code{plstripc} (@pxref{plstripc; Create a 4-pen stripchart})) of the stripchart.

@item   @code{p}  (@samp{PLINT}, input)  
Pen number (ranges from 0 to 3).

@item   @code{x}  (@samp{PLFLT}, input)  
X coordinate of point to plot.

@item   @code{y}  (@samp{PLFLT}, input)  
Y coordinate of point to plot.
@end table

@node plstripc; Create a 4-pen stripchart, plstripd; Deletes and releases memory used by a stripchart, plstripa; Add a point to a stripchart, The Common API for PLplot
@section   plstripc: Create a 4-pen stripchart  


@quotation

@t{
@b{plstripc}
(@i{id}, @i{xspec}, @i{yspec}, @i{xmin}, @i{xmax}, @i{xjump}, @i{ymin}, @i{ymax}, @i{xlpos}, @i{ylpos}, @i{y_ascl}, @i{acc}, @i{colbox}, @i{collab}, @i{colline}, @i{styline}, @i{legline[]}, @i{labx}, @i{laby}, @i{labtop});}
@end quotation

Create a 4-pen stripchart, to be used afterwards by @code{plstripa} (@pxref{plstripa; Add a point to a stripchart})

@table @asis

@item   @code{id}  (@samp{PLINT *}, output)  
Identification number of stripchart to use on @code{plstripa} (@pxref{plstripa; Add a point to a stripchart}) and @code{plstripd} (@pxref{plstripd; Deletes and releases memory used by a stripchart}).

@item   @code{xspec}  (@samp{char *}, input)  
X-axis specification as in @code{plbox} (@pxref{plbox; Draw a box with axes; etc}).

@item   @code{yspec}  (@samp{char *}, input)  
Y-axis specification as in @code{plbox} (@pxref{plbox; Draw a box with axes; etc}).

@item   @code{xmin}  (@samp{PLFLT}, input)  
Initial coordinates of plot box; they will change as data are
added.

@item   @code{xmax}  (@samp{PLFLT}, input)  
Initial coordinates of plot box; they will change as data are
added.

@item   @code{xjump}  (@samp{PLFLT}, input)  
When x attains @samp{@code{xmax}},
the length of the plot is multiplied by the
factor @samp{(1 + @code{xjump})}.

@item   @code{ymin}  (@samp{PLFLT}, input)  
Initial coordinates of plot box; they will change as data are
added.

@item   @code{ymax}  (@samp{PLFLT}, input)  
Initial coordinates of plot box; they will change as data are
added.

@item   @code{xlpos}  (@samp{PLFLT}, input)  
X legend box position (range from 0 to 1).

@item   @code{ylpos}  (@samp{PLFLT}, input)  
Y legend box position (range from 0 to 1).

@item   @code{y_ascl}  (@samp{PLINT}, input)  
Autoscale y between x jumps (1) or not (0).

@item   @code{acc}  (@samp{PLINT}, input)  
Accumulate strip plot (1) or slide (0).

@item   @code{colbox}  (@samp{PLINT}, input)  
Plot box color index (cmap0).

@item   @code{collab}  (@samp{PLINT}, input)  
Legend color index (cmap0).

@item   @code{colline}  (@samp{PLINT *}, input)  
Pointer to array with color indices (cmap0) for the 4 pens.

@item   @code{styline}  (@samp{PLINT *}, input)  
Pointer to array with line styles for the 4 pens.

@item   @code{legline}  (@samp{char **}, input)  
Pointer to character array containing legends for the 4 pens.

@item   @code{labx}  (@samp{char *}, input)  
X-axis label.

@item   @code{laby}  (@samp{char *}, input)  
Y-axis label.

@item   @code{labtop}  (@samp{char *}, input)  
Plot title.
@end table

@node plstripd; Deletes and releases memory used by a stripchart, plstyl; Set line style, plstripc; Create a 4-pen stripchart, The Common API for PLplot
@section   plstripd: Deletes and releases memory used by a stripchart  


@quotation

@t{
@b{plstripd}
(@i{id});}
@end quotation

Deletes and releases memory used by a stripchart.

@table @asis

@item   @code{id}  (@samp{PLINT}, input)  
Identitification number of stripchart to delete.
@end table

@node plstyl; Set line style, plsurf3d; Plot shaded 3-d surface plot, plstripd; Deletes and releases memory used by a stripchart, The Common API for PLplot
@section   plstyl: Set line style  


@quotation

@t{
@b{plstyl}
(@i{nels}, @i{mark}, @i{space});}
@end quotation

This sets up the line style for all lines subsequently drawn. A line
consists of segments in which the pen is alternately down and up.
The lengths of these segments are passed in the arrays
@samp{@code{mark}} and
@samp{@code{space}} respectively. The
number of mark-space pairs is specified by
@samp{@code{nels}}. In order to return
the line style to the default continuous line, @code{plstyl} (@pxref{plstyl; Set line style}) should be
called with @samp{@code{nels}=0}.(see
also @code{pllsty} (@pxref{pllsty; Select line style}))

@table @asis

@item   @code{nels}  (@samp{PLINT}, input)  
The number of @samp{@code{mark}}
and @samp{@code{space}} elements in
a line. Thus a simple broken line can be obtained by setting
@samp{@code{nels}=1}. A continuous
line is specified by setting
@samp{@code{nels}=0}.

@item   @code{mark}  (@samp{PLINT *}, input)  
Pointer to array with the lengths of the segments during which
the pen is down, measured in micrometers.

@item   @code{space}  (@samp{PLINT *}, input)  
Pointer to array with the lengths of the segments during which
the pen is up, measured in micrometers.
@end table

@node plsurf3d; Plot shaded 3-d surface plot, plsvect; Set arrow style for vector plots, plstyl; Set line style, The Common API for PLplot
@section   plsurf3d: Plot shaded 3-d surface plot  


@quotation

@t{
@b{plsurf3d}
(@i{x}, @i{y}, @i{z}, @i{nx}, @i{ny}, @i{opt}, @i{clevel}, @i{nlevel});}
@end quotation

Plots a three dimensional shaded surface plot within the environment set up
by @code{plw3d} (@pxref{plw3d; Set up window for 3-d plotting}). The surface is defined by the two-dimensional array
@samp{@code{z}[@code{nx}][@code{ny}]},
the point @samp{@code{z}[i][j]} being the
value of the function at @samp{(@code{x}[i],
@code{y}[j])}. Note that the points in
arrays @samp{@code{x}} and
@samp{@code{y}} do not need to be equally
spaced, but must be stored in ascending order.
For further details see @ref{Three Dimensional Surface Plots,,Three Dimensional Surface Plots}..

@table @asis

@item   @code{x}  (@samp{PLFLT *}, input)  
Pointer to set of x coordinate values at which the function is
evaluated.

@item   @code{y}  (@samp{PLFLT *}, input)  
Pointer to set of y coordinate values at which the function is
evaluated.

@item   @code{z}  (@samp{PLFLT **}, input)  
Pointer to a vectored two-dimensional array with set of
function values.

@item   @code{nx}  (@samp{PLINT}, input)  
Number of @samp{@code{x}} values at
which function is evaluated.

@item   @code{ny}  (@samp{PLINT}, input)  
Number of @samp{@code{y}} values at
which function is evaluated.

@item   @code{opt}  (@samp{PLINT}, input)  
Determines the way in which the surface is represented. To specify
more than one option just add the options, e.g. FACETED + SURF_CONT

@itemize @bullet{}

@item
@samp{@code{opt}=FACETED}: Network
of lines is drawn connecting points at which function is
defined.

@item
@samp{@code{opt}=BASE_CONT}: A contour
plot is drawn at the base XY plane using parameters
@code{nlevel} and @code{clevel}.

@item
@samp{@code{opt}=SURF_CONT}: A contour
plot is drawn at the surface plane using parameters
@code{nlevel} and @code{clevel}.

@item
@samp{@code{opt}=DRAW_SIDES}: draws a curtain
between the base XY plane and the borders of the plotted function.

@item
@samp{@code{opt}=MAG_COLOR}:
the surface is colored according to the value of Z; if
@samp{MAG_COLOR} is not used, then the default
the surface is colored according to the intensity of the
reflected light in the surface from a light source whose
position is set using @code{pllightsource} (@pxref{pllightsource; Sets the 3D position of the light source}).
@end itemize

@item   @code{clevel}  (@samp{PLFLT *}, input)  
Pointer to the array that defines the contour level spacing.

@item   @code{nlevel}  (@samp{PLINT}, input)  
Number of elements in the @samp{clevel} array.
@end table

@node plsvect; Set arrow style for vector plots, plsvpa; Specify viewport in absolute coordinates, plsurf3d; Plot shaded 3-d surface plot, The Common API for PLplot
@section   plsvect: Set arrow style for vector plots  


@quotation

@t{
@b{plsvect}
(@i{arrowx}, @i{arrowy}, @i{npts}, @i{fill});}
@end quotation

Set the style for the arrow used by @code{plvect} (@pxref{plvect; Vector plot}) to plot vectors.

@table @asis

@item   @code{arrowx, arrowy}  (@samp{PLFLT *},input)  
Pointers to a pair of arrays containing the x and y points
which make up the arrow. The arrow is plotted by joining these
points to form a polygon. The scaling assumes that the x and y
points in the arrow lie in the range
@samp{-0.5 <= x,y <= 0.5}.

@item   @code{npts}  (@samp{PLINT},input)  
Number of points in the arrays
@samp{@code{arrowx}} and
@samp{@code{arrowy}}.

@item   @code{fill}  (@samp{PLINT},input)  
If @samp{@code{fill} = 0} then the
arrow is open, if @samp{@code{fill} = 1}
then the arrow is filled.
@end table

@node plsvpa; Specify viewport in absolute coordinates, plsxax; Set x axis parameters, plsvect; Set arrow style for vector plots, The Common API for PLplot
@section   plsvpa: Specify viewport in absolute coordinates  


@quotation

@t{
@b{plsvpa}
(@i{xmin}, @i{xmax}, @i{ymin}, @i{ymax});}
@end quotation

Alternate routine to @code{plvpor} (@pxref{plvpor; Specify viewport using coordinates}) for setting up the viewport. This
routine should be used only if the viewport is required to have a
definite size in millimeters. The routine @code{plgspa} (@pxref{plgspa; Get current subpage parameters}) is useful for
finding out the size of the current subpage.

@table @asis

@item   @code{xmin}  (@samp{PLFLT}, input)  
The distance of the left-hand edge of the viewport from the
left-hand edge of the subpage in millimeters.

@item   @code{xmax}  (@samp{PLFLT}, input)  
The distance of the right-hand edge of the viewport from the
left-hand edge of the subpage in millimeters.

@item   @code{ymin}  (@samp{PLFLT}, input)  
The distance of the bottom edge of the viewport from the bottom
edge of the subpage in millimeters.

@item   @code{ymax}  (@samp{PLFLT}, input)  
The distance of the top edge of the viewport from the bottom edge
of the subpage in millimeters.
@end table

@node plsxax; Set x axis parameters, plsyax; Set y axis parameters, plsvpa; Specify viewport in absolute coordinates, The Common API for PLplot
@section   plsxax: Set x axis parameters  


@quotation

@t{
@b{plsxax}
(@i{digmax}, @i{digits});}
@end quotation

Sets values of the
@samp{@code{digmax}} and
@samp{@code{digits}} flags for the x
axis. See @ref{Annotating the Viewport,,Annotating the Viewport}. for more information.

@table @asis

@item   @code{digmax}  (@samp{PLINT}, input)  
Variable to set the maximum number of digits for the x axis. If nonzero, the
printed label will be switched to a floating point
representation when the number of digits exceeds
@samp{@code{digmax}}.

@item   @code{digits}  (@samp{PLINT}, input)  
Field digits value. Currently, changing its value here has no
effect since it is set only by @code{plbox} (@pxref{plbox; Draw a box with axes; etc}) or @code{ plbox3} (@pxref{plbox3; Draw a box with axes; etc; in 3-d}). However,
the user may obtain its value after a call to either of these functions by
calling @code{plgxax} (@pxref{plgxax; Get x axis parameters}).
@end table

@node plsyax; Set y axis parameters, plsym; Plots a symbol at the specified points, plsxax; Set x axis parameters, The Common API for PLplot
@section   plsyax: Set y axis parameters  


@quotation

@t{
@b{plsyax}
(@i{digmax}, @i{digits});}
@end quotation

Identical to @code{plsxax} (@pxref{plsxax; Set x axis parameters}), except that arguments are flags for y axis.
See the description of @code{plsxax} (@pxref{plsxax; Set x axis parameters}) for more detail.

@table @asis

@item   @code{digmax}  (@samp{PLINT}, input)  
Variable to set the maximum number of digits for the y axis. If nonzero, the
printed label will be switched to a floating point
representation when the number of digits exceeds
@samp{@code{digmax}}.

@item   @code{digits}  (@samp{PLINT}, input)  
Field digits value. Currently, changing its value here has no
effect since it is set only by @code{plbox} (@pxref{plbox; Draw a box with axes; etc}) or @code{ plbox3} (@pxref{plbox3; Draw a box with axes; etc; in 3-d}). However,
the user may obtain its value after a call to either of these functions by
calling @code{plgyax} (@pxref{plgyax; Get y axis parameters}).
@end table

@node plsym; Plots a symbol at the specified points, plszax; Set z axis parameters, plsyax; Set y axis parameters, The Common API for PLplot
@section   plsym: Plots a symbol at the specified points  


@quotation

@t{
@b{plsym}
(@i{n}, @i{x}, @i{y}, @i{code});}
@end quotation

Marks out a set of @samp{@code{n}} points
at positions @samp{(@code{x}[i],
@code{y}[i])}, using the symbol defined by
@samp{@code{code}}. The code is
interpreted as an index in the Hershey font tables.

@table @asis

@item   @code{n}  (@samp{PLINT}, input)  
Number of points to be marked.

@item   @code{x}  (@samp{PLFLT *}, input)  
Pointer to array with set of x coordinate values for the
points.

@item   @code{y}  (@samp{PLFLT *}, input)  
Pointer to array with set of y coordinate values for the
points.

@item   @code{code}  (@samp{PLINT}, input)  
Code number for the symbol to be plotted.
@end table

@node plszax; Set z axis parameters, pltext; Switch to text screen, plsym; Plots a symbol at the specified points, The Common API for PLplot
@section   plszax: Set z axis parameters  


@quotation

@t{
@b{plszax}
(@i{digmax}, @i{digits});}
@end quotation

Identical to @code{plsxax} (@pxref{plsxax; Set x axis parameters}), except that arguments are flags for z axis.
See the description of @code{plsxax} (@pxref{plsxax; Set x axis parameters}) for more detail.

@table @asis

@item   @code{digmax}  (@samp{PLINT}, input)  
Variable to set the maximum number of digits for the z axis. If nonzero, the
printed label will be switched to a floating point
representation when the number of digits exceeds
@samp{@code{digmax}}.

@item   @code{digits}  (@samp{PLINT}, input)  
Field digits value. Currently, changing its value here has no
effect since it is set only by @code{plbox} (@pxref{plbox; Draw a box with axes; etc}) or @code{ plbox3} (@pxref{plbox3; Draw a box with axes; etc; in 3-d}). However,
the user may obtain its value after a call to either of these functions by
calling @code{plgzax} (@pxref{plgzax; Get z axis parameters}).
@end table

@node pltext; Switch to text screen, plvasp; Specify viewport using aspect ratio only, plszax; Set z axis parameters, The Common API for PLplot
@section   pltext: Switch to text screen  


@quotation

@t{
@b{pltext}
();}
@end quotation

Sets an interactive device to text mode, used in conjunction with
@code{plgra} (@pxref{plgra; Switch to graphics screen}) to allow graphics and text to be interspersed. On a device
which supports separate text and graphics windows, this command
causes control to be switched to the text window. This can be useful
for printing diagnostic messages or getting user input, which would
otherwise interfere with the plots. The program
@i{must} switch back to the graphics window before
issuing plot commands, as the text (or console) device will probably
become quite confused otherwise. If already in text mode, this
command is ignored. It is also ignored on devices which only support
a single window or use a different method for shifting focus (see
also @code{plgra} (@pxref{plgra; Switch to graphics screen})).

@node plvasp; Specify viewport using aspect ratio only, plvect; Vector plot, pltext; Switch to text screen, The Common API for PLplot
@section   plvasp: Specify viewport using aspect ratio only  


@quotation

@t{
@b{plvasp}
(@i{aspect});}
@end quotation

Sets the viewport so that the ratio of the length of the y axis to
that of the x axis is equal to
@samp{@code{aspect}}.

@table @asis

@item   @code{aspect}  (@samp{PLFLT}, input)  
Ratio of length of y axis to length of x axis.
@end table

@node plvect; Vector plot, plvpas; Specify viewport using coordinates and aspect ratio, plvasp; Specify viewport using aspect ratio only, The Common API for PLplot
@section   plvect: Vector plot  


@quotation

@t{
@b{plvect}
(@i{u}, @i{v}, @i{nx}, @i{ny}, @i{scale}, @i{pltr}, @i{pltr_data});}
@end quotation

Draws a vector plot of the vector
@samp{(@code{u}[@code{nx}][@code{ny}],@code{v}[@code{nx}][@code{ny}])}.
The scaling factor for the vectors is given by
@samp{@code{scale}}. A
transformation routine pointed to by @samp{@code{pltr}}
with a pointer @samp{@code{pltr_data}}
for additional data required by the transformation routine
is used to map indices within the array
to the world coordinates. The style of the vector arrow may be set using
@code{plsvect} (@pxref{plsvect; Set arrow style for vector plots}).

@table @asis

@item   @code{u, v}  (@samp{PLFLT **}, input)  
Pointers to a pair of vectored two-dimensional arrays
containing the x and y components of the vector data to be
plotted.

@item   @code{nx, ny}  (@samp{PLINT}, input)  
Physical dimensions of the arrays
@samp{@code{u}} and
@samp{@code{v}}.

@item   @code{scale}  (@samp{PLFLT}, input)  
Parameter to control the scaling factor of the vectors for plotting.
If @samp{@code{scale} = 0} then
the scaling factor is automatically calculated for the data.
If @samp{@code{scale} < 0} then
the scaling factor is automatically calculated for the data and
then multiplied by @samp{-@code{scale}}.
If @samp{@code{scale} > 0} then
the scaling factor is set to @samp{@code{scale}}.

@item   @code{pltr}  (@samp{void (*) (PLFLT, PLFLT, PLFLT *, PLFLT *, PLPointer)  }, input)  
Pointer to function that defines transformation between indices
in array @samp{@code{z}} and the
world coordinates (C only). Transformation functions are
provided in the PLplot library:
@code{pltr0} (@pxref{pltr0; Identity transformation for grid to world mapping}) for identity mapping, and @code{pltr1} (@pxref{pltr1; Linear interpolation for grid to world mapping using singly dimensioned coord arrays}) and @code{pltr2} (@pxref{pltr2; Linear interpolation for grid to world mapping using doubly dimensioned coord arrays [column dominant; as per normal C 2d arrays]}) for
arbitrary mappings respectively defined by one- and
two-dimensional arrays. In addition, user-supplied routines
for the transformation can be used as well. Examples of
all of these approaches are given in
@ref{Contour Plots from C,,Contour Plots from C}..
The transformation function should
have the form given by any of @code{pltr0} (@pxref{pltr0; Identity transformation for grid to world mapping}), @code{pltr1} (@pxref{pltr1; Linear interpolation for grid to world mapping using singly dimensioned coord arrays}), or @code{pltr2} (@pxref{pltr2; Linear interpolation for grid to world mapping using doubly dimensioned coord arrays [column dominant; as per normal C 2d arrays]}).

@item   @code{pltr_data}  (@samp{PLPointer}, input)  
Extra parameter to help
pass information to @code{pltr0} (@pxref{pltr0; Identity transformation for grid to world mapping}), @code{pltr1} (@pxref{pltr1; Linear interpolation for grid to world mapping using singly dimensioned coord arrays}), @code{pltr2} (@pxref{pltr2; Linear interpolation for grid to world mapping using doubly dimensioned coord arrays [column dominant; as per normal C 2d arrays]}), or whatever routine
that is externally supplied.
@end table

@node plvpas; Specify viewport using coordinates and aspect ratio, plvpor; Specify viewport using coordinates, plvect; Vector plot, The Common API for PLplot
@section   plvpas: Specify viewport using coordinates and aspect ratio  


@quotation

@t{
@b{plvpas}
(@i{xmin}, @i{xmax}, @i{ymin}, @i{ymax}, @i{aspect});}
@end quotation

Device-independent routine for setting up the viewport. The viewport
is chosen to be the largest with the given aspect ratio that fits
within the specified region (in terms of normalized subpage
coordinates). This routine is functionally equivalent to @code{plvpor} (@pxref{plvpor; Specify viewport using coordinates})
when a ``natural'' aspect ratio (0.0) is chosen. Unlike @code{plvasp} (@pxref{plvasp; Specify viewport using aspect ratio only}),
this routine reserves no extra space at the edges for labels.

@table @asis

@item   @code{xmin}  (@samp{PLFLT}, input)  
The normalized subpage coordinate of the left-hand edge of the
viewport.

@item   @code{xmax}  (@samp{PLFLT}, input)  
The normalized subpage coordinate of the right-hand edge of the
viewport.

@item   @code{ymin}  (@samp{PLFLT}, input)  
The normalized subpage coordinate of the bottom edge of the
viewport.

@item   @code{ymax}  (@samp{PLFLT}, input)  
The normalized subpage coordinate of the top edge of the
viewport.

@item   @code{aspect}  (@samp{PLFLT}, input)  
Ratio of length of y axis to length of x axis.
@end table

@node plvpor; Specify viewport using coordinates, plvsta; Select standard viewport, plvpas; Specify viewport using coordinates and aspect ratio, The Common API for PLplot
@section   plvpor: Specify viewport using coordinates  


@quotation

@t{
@b{plvpor}
(@i{xmin}, @i{xmax}, @i{ymin}, @i{ymax});}
@end quotation

Device-independent routine for setting up the viewport. This defines
the viewport in terms of normalized subpage coordinates which run
from 0.0 to 1.0 (left to right and bottom to top) along each edge of
the current subpage. Use the alternate routine @code{plsvpa} (@pxref{plsvpa; Specify viewport in absolute coordinates}) in order to
create a viewport of a definite size.

@table @asis

@item   @code{xmin}  (@samp{PLFLT}, input)  
The normalized subpage coordinate of the left-hand edge of the
viewport.

@item   @code{xmax}  (@samp{PLFLT}, input)  
The normalized subpage coordinate of the right-hand edge of the
viewport.

@item   @code{ymin}  (@samp{PLFLT}, input)  
The normalized subpage coordinate of the bottom edge of the
viewport.

@item   @code{ymax}  (@samp{PLFLT}, input)  
The normalized subpage coordinate of the top edge of the
viewport.
@end table

@node plvsta; Select standard viewport, plw3d; Set up window for 3-d plotting, plvpor; Specify viewport using coordinates, The Common API for PLplot
@section   plvsta: Select standard viewport  


@quotation

@t{
@b{plvsta}
();}
@end quotation

Sets up a standard viewport, leaving a left-hand margin of seven
character heights, and four character heights around the other three
sides.

@node plw3d; Set up window for 3-d plotting, plwid; Set pen width, plvsta; Select standard viewport, The Common API for PLplot
@section   plw3d: Set up window for 3-d plotting  


@quotation

@t{
@b{plw3d}
(@i{basex}, @i{basey}, @i{height}, @i{xmin}, @i{xmax}, @i{ymin}, @i{ymax}, @i{zmin}, @i{zmax}, @i{alt}, @i{az});}
@end quotation

Sets up a window for a three-dimensional surface plot within the
currently defined two-dimensional window. The enclosing box for the
surface plot defined by
@samp{@code{xmin}},
@samp{@code{xmax}},
@samp{@code{ymin}},
@samp{@code{ymax}},
@samp{@code{zmin}} and
@samp{@code{zmax}} in user-coordinate
space is mapped into a box of world coordinate size
@samp{@code{basex}} by
@samp{@code{basey}} by
@samp{@code{height}} so that
@samp{@code{xmin}} maps to
@samp{-@code{basex}/2},
@samp{@code{xmax}} maps to
@samp{@code{basex}/2},
@samp{@code{ymin}} maps to
@samp{-@code{basey}/2},
@samp{@code{ymax}} maps to
@samp{@code{basey}/2},
@samp{@code{zmin}} maps to
@samp{0} and
@samp{@code{zmax}} maps to
@samp{@code{height}}. The resulting
world-coordinate box is then viewed by an observer at altitude
@samp{@code{alt}} and azimuth
@samp{@code{az}}. This routine must be
called before @code{ plbox3} (@pxref{plbox3; Draw a box with axes; etc; in 3-d}) or @code{plot3d} (@pxref{plot3d; Plot 3-d surface plot}). For a more complete description
of three-dimensional plotting see @ref{Three Dimensional Surface Plots,,Three Dimensional Surface Plots}..

@table @asis

@item   @code{basex}  (@samp{PLFLT}, input)  
The x coordinate size of the world-coordinate box.

@item   @code{basey}  (@samp{PLFLT}, input)  
The y coordinate size of the world-coordinate box.

@item   @code{height}  (@samp{PLFLT}, input)  
The z coordinate size of the world-coordinate box.

@item   @code{xmin}  (@samp{PLFLT}, input)  
The minimum user x coordinate value.

@item   @code{xmax}  (@samp{PLFLT}, input)  
The maximum user x coordinate value.

@item   @code{ymin}  (@samp{PLFLT}, input)  
The minimum user y coordinate value.

@item   @code{ymax}  (@samp{PLFLT}, input)  
The maximum user y coordinate value.

@item   @code{zmin}  (@samp{PLFLT}, input)  
The minimum user z coordinate value.

@item   @code{zmax}  (@samp{PLFLT}, input)  
The maximum user z coordinate value.

@item   @code{alt}  (@samp{PLFLT}, input)  
The viewing altitude in degrees above the xy plane.

@item   @code{az}  (@samp{PLFLT}, input)  
The viewing azimuth in degrees. When
@samp{@code{az}=0}, the observer is
looking face onto the zx plane, and as
@samp{@code{az}} is increased, the
observer moves clockwise around the box when viewed from above
the xy plane.
@end table

@node plwid; Set pen width, plwind; Specify world coordinates of viewport boundaries, plw3d; Set up window for 3-d plotting, The Common API for PLplot
@section   plwid: Set pen width  


@quotation

@t{
@b{plwid}
(@i{width});}
@end quotation

Sets the pen width.

@table @asis

@item   @code{width}  (@samp{PLINT}, input)  
The desired pen width. If @samp{@code{width}}
is negative or the same as the previous value no action is taken.
@samp{@code{width} = 0} should be interpreted as
as the minimum valid pen width for the device. The interpretation of positive
@samp{@code{width}} values is also device
dependent.
@end table

@node plwind; Specify world coordinates of viewport boundaries, plxormod; Enter or leave xor mode, plwid; Set pen width, The Common API for PLplot
@section   plwind: Specify world coordinates of viewport boundaries  


@quotation

@t{
@b{plwind}
(@i{xmin}, @i{xmax}, @i{ymin}, @i{ymax});}
@end quotation

Sets up the world coordinates of the edges of the viewport.

@table @asis

@item   @code{xmin}  (@samp{PLFLT}, input)  
The world x coordinate of the left-hand edge of the viewport.

@item   @code{xmax}  (@samp{PLFLT}, input)  
The world x coordinate of the right-hand edge of the viewport.

@item   @code{ymin}  (@samp{PLFLT}, input)  
The world y coordinate of the bottom edge of the viewport.

@item   @code{ymax}  (@samp{PLFLT}, input)  
The world y coordinate of the top edge of the viewport.
@end table

@node plxormod; Enter or leave xor mode, , plwind; Specify world coordinates of viewport boundaries, The Common API for PLplot
@section   plxormod: Enter or leave xor mode  


@quotation

@t{
@b{plxormod}
(@i{mode}, @i{status});}
@end quotation

Enter (mode !=0) or leave (mode == 0) xor mode for those drivers
(e.g., the xwin driver) that support it. Enables erasing plots by
drawing twice the same line, symbol, etc. If driver is not capable
of xor operation returns status of 0.

@table @asis

@item   @code{mode}  (@samp{PLINT}, input)  
mode != 0 means enter xor mode and mode == 0 means leave xor
mode.

@item   @code{status}  (@samp{PLINT *}, output)  
Pointer to status. Returned status == 1 (0) means driver is capable
(incapable) of xor mode.
@end table

@node The Specialized C API for PLplot, The Specialized Fortran API for PLplot, The Common API for PLplot, Top
@chapter The Specialized C API for PLplot

The purpose of this chapter is to document the API for every C function
in PLplot (other than language bindings) that
is @i{not} part of the common API that has already been
documented in @ref{The Common API for PLplot,,The Common API for PLplot}..

This chapter is a work that is just starting. There are many C functions
in the code base that are not part of the common API, and we haven't even
gotten to the point of listing them all. What gets documented here now
is whatever C-explicit code we are trying to understand at the time.

@menu
* plP_checkdriverinit; Checks to see if any of the specified drivers have been initialized::
* plP_getinitdriverlist; Get the initialized-driver list::
* plabort; Error abort::
* plexit; Error exit::
* plgfile; Get output file handle::
* plsabort; Set abort handler::
* plsexit; Set exit handler::
* plsfile; Set output file handle::
* pltr0; Identity transformation for grid to world mapping::
* pltr1; Linear interpolation for grid to world mapping using singly dimensioned coord arrays::
* pltr2; Linear interpolation for grid to world mapping using doubly dimensioned coord arrays [column dominant; as per normal C 2d arrays]::
@end menu

@node plP_checkdriverinit; Checks to see if any of the specified drivers have been initialized, plP_getinitdriverlist; Get the initialized-driver list, , The Specialized C API for PLplot
@section   plP_checkdriverinit: Checks to see if any  of the specified drivers have been initialized  


@quotation

@t{
@b{plP_checkdriverinit}
(@i{list});}
@end quotation

Checks to see if any of the specified drivers have been
initialized. Function tests a space-delimited list of driver names to
see how many of the given drivers have been initialized, and how often.
The return code of the function is: @samp{0} if no matching
drivers were found to have been initialized; @samp{-1} if
an error occurred allocating the internal buffer; or, a positive number
indicating the number of streams encountered that belong to drivers on
the provided list. This function invokes @code{plP_getinitdriverlist} (@pxref{plP_getinitdriverlist; Get the initialized-driver list})
internally to get a @i{complete} list of drivers that have been initialized
in order to compare with the driver names specified in the argument list
to @code{plP_checkdriverinit} (@pxref{plP_checkdriverinit; Checks to see if any of the specified drivers have been initialized}).

@table @asis

@item   @code{list}  (@samp{char *}, input)  
Pointer to character string specifying a space-delimited
list of driver names, e.g., @samp{"bmp jpeg tiff"}.
@end table

@node plP_getinitdriverlist; Get the initialized-driver list, plabort; Error abort, plP_checkdriverinit; Checks to see if any of the specified drivers have been initialized, The Specialized C API for PLplot
@section   plP_getinitdriverlist: Get the initialized-driver  list  


@quotation

@t{
@b{plP_getinitdriverlist}
(@i{text_buffer});}
@end quotation

Get the initialized-driver list. Function returns a
space-delimited list of the currently initialized drivers or streams. If more
than one stream is using the same driver, then its name will be returned
more than once. The function can be analogously thought of as also
returning the names of the active streams. Invoked internally by
@code{plP_checkdriverinit} (@pxref{plP_checkdriverinit; Checks to see if any of the specified drivers have been initialized}). 

@table @asis

@item   @code{text_buffer}  (@samp{char *}, output)  
Pointer to a user-allocated buffer to hold the result. The user
must ensure the buffer is big enough to hold the result.
@end table

@node plabort; Error abort, plexit; Error exit, plP_getinitdriverlist; Get the initialized-driver list, The Specialized C API for PLplot
@section   plabort: Error abort  


@quotation

@t{
@b{plabort}
(@i{message});}
@end quotation

This routine is to be used when something goes wrong that doesn't
require calling @code{plexit} (@pxref{plexit; Error exit}) but for which there is no useful recovery.
It calls the abort handler defined via @code{plsabort} (@pxref{plsabort; Set abort handler}), does some cleanup
and returns. The user can supply his/her own abort handler and pass it
in via @code{plsabort} (@pxref{plsabort; Set abort handler}).

@table @asis

@item   @code{message}  (@samp{char *}, input)  
Abort message.
@end table

@node plexit; Error exit, plgfile; Get output file handle, plabort; Error abort, The Specialized C API for PLplot
@section   plexit: Error exit  


@quotation

@t{
@b{plexit}
(@i{message});}
@end quotation

This routine is called in case an error is encountered during
execution of a PLplot routine. It prints the error message, tries to
release allocated resources, calls the handler prvided by @code{plsexit} (@pxref{plsexit; Set exit handler})
and then exits. If cleanup needs to be done in the driver program
then the user may want to supply his/her own exit handler and pass it
in via @code{plsexit} (@pxref{plsexit; Set exit handler}). This function should either call @code{plend} (@pxref{plend; End plotting session}) before
exiting, or simply return.

@table @asis

@item   @code{message}  (@samp{char *}, input)  
Error message.
@end table

@node plgfile; Get output file handle, plsabort; Set abort handler, plexit; Error exit, The Specialized C API for PLplot
@section   plgfile: Get output file handle  


@quotation

@t{
@b{plgfile}
(@i{file});}
@end quotation

Gets the current output file handle, if applicable.

@table @asis

@item   @code{file}  (@samp{FILE **}, output)  
File pointer to current output file.
@end table

@node plsabort; Set abort handler, plsexit; Set exit handler, plgfile; Get output file handle, The Specialized C API for PLplot
@section   plsabort: Set abort handler  


@quotation

@t{
@b{plsabort}
(@i{handler});}
@end quotation

Sets an optional user abort handler. See @code{plabort} (@pxref{plabort; Error abort}) for details.

@table @asis

@item   @code{handler}  (@samp{void (*) (char *)}, input)  
Error abort handler.
@end table

@node plsexit; Set exit handler, plsfile; Set output file handle, plsabort; Set abort handler, The Specialized C API for PLplot
@section   plsexit: Set exit handler  


@quotation

@t{
@b{plsexit}
(@i{handler});}
@end quotation

Sets an optional user exit handler. See @code{plexit} (@pxref{plexit; Error exit}) for details.

@table @asis

@item   @code{handler}  (@samp{int (*) (char *)}, input)  
Error exit handler.
@end table

@node plsfile; Set output file handle, pltr0; Identity transformation for grid to world mapping, plsexit; Set exit handler, The Specialized C API for PLplot
@section   plsfile: Set output file handle  


@quotation

@t{
@b{plsfile}
(@i{file});}
@end quotation

Sets the current output file handle, if applicable. If the file has
has not been previously opened and is required by the driver, the
user will be prompted for the file name. This routine, if used, must
be called before initializing PLplot.

@table @asis

@item   @code{file}  (@samp{FILE *}, input)  
File pointer.
@end table

@node pltr0; Identity transformation for grid to world mapping, pltr1; Linear interpolation for grid to world mapping using singly dimensioned coord arrays, plsfile; Set output file handle, The Specialized C API for PLplot
@section   pltr0: Identity transformation for grid to world mapping  


@quotation

@t{
@b{pltr0}
(@i{x}, @i{y}, @i{tx}, @i{ty}, @i{pltr_data});}
@end quotation

Identity transformation for grid to world mapping.
This routine can be used both for @code{plcont} (@pxref{plcont; Contour plot}) and @code{plshade} (@pxref{plshade; Shade individual region on the basis of value}).
See also @ref{Contour Plots from C,,Contour Plots from C}. and
@ref{Shade Plots from C,,Shade Plots from C}..

@table @asis

@item   @code{x}  (@samp{PLFLT}, input)  
X-position in grid coordinates.

@item   @code{y}  (@samp{PLFLT}, input)  
Y-position in grid coordinates.

@item   @code{tx}  (@samp{PLFLT *}, output)  
X-position in world coordinates.

@item   @code{ty}  (@samp{PLFLT *}, output)  
Y-position in world coordinates.

@item   @code{pltr_data}  (@samp{PLPointer}, input)  
Pointer to additional input data that is passed as an argument
to @code{plcont} (@pxref{plcont; Contour plot}) or @code{plshade} (@pxref{plshade; Shade individual region on the basis of value}) and then on to the grid to world
transformation routine.
@end table

@node pltr1; Linear interpolation for grid to world mapping using singly dimensioned coord arrays, pltr2; Linear interpolation for grid to world mapping using doubly dimensioned coord arrays [column dominant; as per normal C 2d arrays], pltr0; Identity transformation for grid to world mapping, The Specialized C API for PLplot
@section   pltr1: Linear interpolation for grid to world mapping using singly dimensioned coord arrays  


@quotation

@t{
@b{pltr1}
(@i{x}, @i{y}, @i{tx}, @i{ty}, @i{pltr_data});}
@end quotation

Linear interpolation for grid to world mapping using singly
dimensioned coord arrays.
This routine can be used both for @code{plcont} (@pxref{plcont; Contour plot}) and @code{plshade} (@pxref{plshade; Shade individual region on the basis of value}).
See also @ref{Contour Plots from C,,Contour Plots from C}. and
@ref{Shade Plots from C,,Shade Plots from C}..

@table @asis

@item   @code{x}  (@samp{PLFLT}, input)  
X-position in grid coordinates.

@item   @code{y}  (@samp{PLFLT}, input)  
Y-position in grid coordinates.

@item   @code{tx}  (@samp{PLFLT *}, output)  
X-position in world coordinates.

@item   @code{ty}  (@samp{PLFLT *}, output)  
Y-position in world coordinates.

@item   @code{pltr_data}  (@samp{PLPointer}, input)  
Pointer to additional input data that is passed as an argument
to @code{plcont} (@pxref{plcont; Contour plot}) or @code{plshade} (@pxref{plshade; Shade individual region on the basis of value}) and then on to the grid to world
transformation routine.
@end table

@node pltr2; Linear interpolation for grid to world mapping using doubly dimensioned coord arrays [column dominant; as per normal C 2d arrays], , pltr1; Linear interpolation for grid to world mapping using singly dimensioned coord arrays, The Specialized C API for PLplot
@section   pltr2: Linear interpolation for grid to world  mapping using doubly dimensioned coord arrays (column  dominant, as per normal C 2d arrays)  


@quotation

@t{
@b{pltr2}
(@i{x}, @i{y}, @i{tx}, @i{ty}, @i{pltr_data});}
@end quotation

Linear interpolation for grid to world mapping using doubly
dimensioned coord arrays (column dominant, as per normal C 2d arrays).
This routine can be used both for @code{plcont} (@pxref{plcont; Contour plot}) and @code{plshade} (@pxref{plshade; Shade individual region on the basis of value}).
See also @ref{Contour Plots from C,,Contour Plots from C}. and
@ref{Shade Plots from C,,Shade Plots from C}..

@table @asis

@item   @code{x}  (@samp{PLFLT}, input)  
X-position in grid coordinates.

@item   @code{y}  (@samp{PLFLT}, input)  
Y-position in grid coordinates.

@item   @code{tx}  (@samp{PLFLT *}, output)  
X-position in world coordinates.

@item   @code{ty}  (@samp{PLFLT *}, output)  
Y-position in world coordinates.

@item   @code{pltr_data}  (@samp{PLPointer}, input)  
Pointer to additional input data that is passed as an argument
to @code{plcont} (@pxref{plcont; Contour plot}) or @code{plshade} (@pxref{plshade; Shade individual region on the basis of value}) and then on to the grid to world
transformation routine.
@end table

@node The Specialized Fortran API for PLplot, API compatibility definition, The Specialized C API for PLplot, Top
@chapter The Specialized Fortran API for PLplot

The purpose of this Chapter is to document the API for each Fortran function
in PLplot that differs substantially (usually in argument lists)
from the common API that has already been
documented in @ref{The Common API for PLplot,,The Common API for PLplot}..

Normally, the common API is wrapped in such a way for Fortran that there is
and one-to-one correspondence between each fortran and C argument
(see @ref{Fortran Language,,Fortran Language}.
for discussion). However, for certain routines documented in this
chapter the fortran argument lists
necessarily differ substantially from the C versions.

This chapter is incomplete and NEEDS DOCUMENTATION of, e.g., the fortran
equivalent of the plshade C routines.

@menu
* plcon0; Contour plot; identity mapping for fortran::
* plcon1; Contour plot; general 1-d mapping for fortran::
* plcon2; Contour plot; general 2-d mapping for fortran::
* plcont; Contour plot; fixed linear mapping for fortran::
* plvec0; Vector plot; identity mapping for fortran::
* plvec1; Vector plot; general 1-d mapping for fortran::
* plvec2; Vector plot; general 2-d mapping for fortran::
* plvect; Vector plot; fixed linear mapping for fortran::
* plmesh; Plot surface mesh for fortran::
* plot3d; Plot 3-d surface plot for fortran::
* plparseopts; parse arguments for fortran::
* plsesc; Set the escape character for text strings for fortran::
@end menu

@node plcon0; Contour plot; identity mapping for fortran, plcon1; Contour plot; general 1-d mapping for fortran, , The Specialized Fortran API for PLplot
@section   plcon0: Contour plot, identity mapping for fortran  


@quotation

@t{
@b{plcon0}
(@i{z}, @i{nx}, @i{ny}, @i{kx}, @i{lx}, @i{ky}, @i{ly}, @i{clevel}, @i{nlevel});}
@end quotation

Draws a contour plot of the data in
@samp{@code{z}[@code{nx}][@code{ny}]},
using the @samp{@code{nlevel}} contour
levels specified by @samp{@code{clevel}}.
Only the region of the array from
@samp{@code{kx}} to
@samp{@code{lx}} and from
@samp{@code{ky}} to
@samp{@code{ly}} is plotted out. See
@ref{Contour and Shade Plots,,Contour and Shade Plots}. for more information.

@table @asis

@item   @code{z}  (@samp{PLFLT **}, input)  
Pointer to a vectored two-dimensional array containing data to
be contoured.

@item   @code{nx, ny}  (@samp{PLINT}, input)  
Physical dimensions of array
@samp{@code{z}}.

@item   @code{kx, lx}  (@samp{PLINT}, input)  
Range of @samp{x} indices to consider.

@item   @code{ky, ly}  (@samp{PLINT}, input)  
Range of @samp{y} indices to consider.

@item   @code{clevel}  (@samp{PLFLT *}, input)  
Pointer to array specifying levels at which to draw contours.

@item   @code{nlevel}  (@samp{PLINT}, input)  
Number of contour levels to draw.
@end table

NOTE: this function is intended for use from a Fortran caller only.
The C user should instead call @code{plcont} (@pxref{plcont; Contour plot}) using the built-in
transformation function @code{pltr0} for the same
capability.

@node plcon1; Contour plot; general 1-d mapping for fortran, plcon2; Contour plot; general 2-d mapping for fortran, plcon0; Contour plot; identity mapping for fortran, The Specialized Fortran API for PLplot
@section   plcon1: Contour plot, general 1-d mapping for fortran  


@quotation

@t{
@b{plcon1}
(@i{z}, @i{nx}, @i{ny}, @i{kx}, @i{lx}, @i{ky}, @i{ly}, @i{clevel}, @i{nlevel}, @i{xg}, @i{yg});}
@end quotation

Draws a contour plot of the data in
@samp{@code{z}[@code{nx}][@code{ny}]},
using the @samp{@code{nlevel}} contour
levels specified by @samp{@code{clevel}}.
Only the region of the array from
@samp{@code{kx}} to
@samp{@code{lx}} and from
@samp{@code{ky}} to
@samp{@code{ly}} is plotted out. The
arrays @samp{@code{xg}} and
@samp{@code{yg}} are used to specify the
transformation between array indices and world coordinates. See
@ref{Contour and Shade Plots,,Contour and Shade Plots}. for more information.

@table @asis

@item   @code{z}  (@samp{PLFLT **}, input)  
Pointer to a vectored two-dimensional array containing data to
be contoured.

@item   @code{nx, ny}  (@samp{PLINT}, input)  
Physical dimensions of array
@samp{@code{z}}.

@item   @code{kx, lx}  (@samp{PLINT}, input)  
Range of @samp{x} indices to consider.

@item   @code{ky, ly}  (@samp{PLINT}, input)  
Range of @samp{y} indices to consider.

@item   @code{clevel}  (@samp{PLFLT *}, input)  
Pointer to array specifying levels at which to draw contours.

@item   @code{nlevel}  (@samp{PLINT}, input)  
Number of contour levels to draw.

@item   @code{xg, yg}  (@samp{PLFLT *}, input)  
Pointers to arrays which specify the transformation from array
indices to world coordinates. These must be one-dimensional
arrays, used for a transformation of the form:
@samp{tx} = @samp{f(x)},
@samp{ty} = @samp{f(y)}. Function
values at locations between grid points are obtained via linear
interpolation.
@end table

NOTE: this function is intended for use from a Fortran caller only.
The C user should instead call @code{plcont} (@pxref{plcont; Contour plot}) using the built-in
transformation function @code{pltr1} for the same
capability.

@node plcon2; Contour plot; general 2-d mapping for fortran, plcont; Contour plot; fixed linear mapping for fortran, plcon1; Contour plot; general 1-d mapping for fortran, The Specialized Fortran API for PLplot
@section   plcon2: Contour plot, general 2-d mapping for fortran  


@quotation

@t{
@b{plcon2}
(@i{z}, @i{nx}, @i{ny}, @i{kx}, @i{lx}, @i{ky}, @i{ly}, @i{clevel}, @i{nlevel}, @i{xg}, @i{yg});}
@end quotation

Draws a contour plot of the data in
@samp{@code{z}[@code{nx}][@code{ny}]},
using the @samp{@code{nlevel}} contour
levels specified by @samp{@code{clevel}}.
Only the region of the array from
@samp{@code{kx}} to
@samp{@code{lx}} and from
@samp{@code{ky}} to
@samp{@code{ly}} is plotted out. The
arrays @samp{@code{xg}} and
@samp{@code{yg}} are used to specify the
transformation between array indices and world coordinates. See
@ref{Contour and Shade Plots,,Contour and Shade Plots}. for more information.

@table @asis

@item   @code{z}  (@samp{PLFLT **}, input)  
Pointer to a vectored two-dimensional array containing data to
be contoured.

@item   @code{nx, ny}  (@samp{PLINT}, input)  
Physical dimensions of array
@samp{@code{z}}.

@item   @code{kx, lx} (@samp{PLINT}, input)  
Range of @samp{x} indices to consider.

@item   @code{ky, ly}  (@samp{PLINT}, input)  
Range of @samp{y} indices to consider.

@item   @code{clevel}  (@samp{PLFLT *}, input)  
Pointer to array specifying levels at which to draw contours.

@item   @code{nlevel} (@samp{PLINT}, input)  
Number of contour levels to draw.

@item   @code{xg, yg}  (@samp{PLFLT *}, input)  
Pointers to arrays which specify the transformation from array
indices to world coordinates. These must be two-dimensional
arrays, used for a transformation of the form:
@samp{tx} = @samp{f(x, y)},
@samp{ty} = @samp{f(x, y)}. Function
values at locations between grid points are obtained via linear
interpolation.
@end table

NOTE: this function is intended for use from a Fortran caller only.
The C user should instead call @code{plcont} (@pxref{plcont; Contour plot}) using the built-in
transformation function @code{pltr2} for the same
capability.

@node plcont; Contour plot; fixed linear mapping for fortran, plvec0; Vector plot; identity mapping for fortran, plcon2; Contour plot; general 2-d mapping for fortran, The Specialized Fortran API for PLplot
@section   plcont: Contour plot, fixed linear mapping for fortran  


@quotation

@t{
@b{plcont}
(@i{z}, @i{nx}, @i{ny}, @i{kx}, @i{lx}, @i{ky}, @i{ly}, @i{clevel}, @i{nlevel});}
@end quotation

When called from Fortran, this routine has the same effect as when
invoked from C. The interpretation of all parameters (see @code{plcont} (@pxref{plcont; Contour plot}))
is also the same except there is no transformation function supplied
as the last parameter. Instead, a 6-element array specifying
coefficients to use in the transformation is supplied via the named
common block @samp{plplot} (see code). Since this
approach is somewhat inflexible, the user is recommended to call
either of @code{plcon0} (@pxref{plcon0; Contour plot; identity mapping for fortran}), @code{plcon1} (@pxref{plcon1; Contour plot; general 1-d mapping for fortran}), or @code{plcon2} (@pxref{plcon2; Contour plot; general 2-d mapping for fortran}) instead.

@node plvec0; Vector plot; identity mapping for fortran, plvec1; Vector plot; general 1-d mapping for fortran, plcont; Contour plot; fixed linear mapping for fortran, The Specialized Fortran API for PLplot
@section   plvec0: Vector plot, identity mapping for fortran  


@quotation

@t{
@b{plvec0}
(@i{u}, @i{v}, @i{nx}, @i{ny}, @i{scale});}
@end quotation

Draws a vector plot of the data in
@samp{(@code{u}[@code{nx}][@code{ny}], @code{v}[@code{nx}][@code{ny}])}.

@table @asis

@item   @code{u, v}  (@samp{PLFLT **}, input)  
Pointer to a pair of vectored two-dimensional arrays containing
the x and y components of the vector to be plotted.

@item   @code{nx, ny}  (@samp{PLINT}, input)  
Physical dimensions of the arrays
@samp{@code{u}} and
@samp{@code{v}}.

@item   @code{scale}  (@samp{PLFLT}, input)  
Parameter to control the scaling factor of the vectors for plotting.
If @samp{@code{scale} = 0} then
the scaling factor is automatically calculated for the data.
If @samp{@code{scale} < 0} then
the scaling factor is automatically calculated for the data and
then multiplied by @samp{-@code{scale}}.
If @samp{@code{scale} > 0} then
the scaling factor is set to @samp{@code{scale}}.
@end table

NOTE: this function is intended for use from a Fortran caller only.
The C user should instead call @code{plvect} (@pxref{plvect; Vector plot}) using the built-in
transformation function @code{pltr0} for the same
capability.

@node plvec1; Vector plot; general 1-d mapping for fortran, plvec2; Vector plot; general 2-d mapping for fortran, plvec0; Vector plot; identity mapping for fortran, The Specialized Fortran API for PLplot
@section   plvec1: Vector plot, general 1-d mapping for fortran  


@quotation

@t{
@b{plvec1}
(@i{u}, @i{v}, @i{nx}, @i{ny}, @i{scale}, @i{xg}, @i{yg});}
@end quotation

Draws a vector plot of the data in
@samp{(@code{u}[@code{nx}][@code{ny}], @code{v}[@code{nx}][@code{ny}])}.

@table @asis

@item   @code{u, v}  (@samp{PLFLT **}, input)  
Pointer to a pair of vectored two-dimensional arrays containing
the x and y components of the vector to be plotted.

@item   @code{nx, ny}  (@samp{PLINT}, input)  
Physical dimensions of the arrays
@samp{@code{u}} and
@samp{@code{v}}.

@item   @code{scale}  (@samp{PLFLT}, input)  
Parameter to control the scaling factor of the vectors for plotting.
If @samp{@code{scale} = 0} then
the scaling factor is automatically calculated for the data.
If @samp{@code{scale} < 0} then
the scaling factor is automatically calculated for the data and
then multiplied by @samp{-@code{scale}}.
If @samp{@code{scale} > 0} then
the scaling factor is set to @samp{@code{scale}}.

@item   @code{xg, yg}  (@samp{PLFLT *}, input)  
Pointers to arrays which specify the transformation from array
indices to world coordinates. These must be one-dimensional
arrays, used for a transformation of the form:
@samp{tx} = @samp{f(x)},
@samp{ty} = @samp{f(y)}. Function
values at locations between grid points are obtained via linear
interpolation.
@end table

NOTE: this function is intended for use from a Fortran caller only.
The C user should instead call @code{plvect} (@pxref{plvect; Vector plot}) using the built-in
transformation function @code{pltr1} for the same
capability.

@node plvec2; Vector plot; general 2-d mapping for fortran, plvect; Vector plot; fixed linear mapping for fortran, plvec1; Vector plot; general 1-d mapping for fortran, The Specialized Fortran API for PLplot
@section   plvec2: Vector plot, general 2-d mapping for fortran  


@quotation

@t{
@b{plvec2}
(@i{u}, @i{v}, @i{nx}, @i{ny}, @i{scale}, @i{xg}, @i{yg});}
@end quotation

Draws a vector plot of the data in
@samp{(@code{u}[@code{nx}][@code{ny}], @code{v}[@code{nx}][@code{ny}])}.

@table @asis

@item   @code{u, v}  (@samp{PLFLT **}, input)  
Pointer to a pair of vectored two-dimensional arrays containing
the x and y components of the vector to be plotted.

@item   @code{nx, ny}  (@samp{PLINT}, input)  
Physical dimensions of the arrays
@samp{@code{u}} and
@samp{@code{v}}.

@item   @code{scale}  (@samp{PLFLT}, input)  
Parameter to control the scaling factor of the vectors for plotting.
If @samp{@code{scale} = 0} then
the scaling factor is automatically calculated for the data.
If @samp{@code{scale} < 0} then
the scaling factor is automatically calculated for the data and
then multiplied by @samp{-@code{scale}}.
If @samp{@code{scale} > 0} then
the scaling factor is set to @samp{@code{scale}}.

@item   @code{xg, yg}  (@samp{PLFLT *}, input)  
Pointers to arrays which specify the transformation from array
indices to world coordinates. These must be two-dimensional
arrays, used for a transformation of the form:
@samp{tx} = @samp{f(x, y)},
@samp{ty} = @samp{f(x, y)}. Function
values at locations between grid points are obtained via linear
interpolation.
@end table

NOTE: this function is intended for use from a Fortran caller only.
The C user should instead call @code{plvect} (@pxref{plvect; Vector plot}) using the built-in
transformation function @code{pltr2} for the same
capability.

@node plvect; Vector plot; fixed linear mapping for fortran, plmesh; Plot surface mesh for fortran, plvec2; Vector plot; general 2-d mapping for fortran, The Specialized Fortran API for PLplot
@section   plvect: Vector plot, fixed linear mapping for fortran  


@quotation

@t{
@b{plvect}
(@i{u}, @i{v}, @i{nx}, @i{ny}, @i{scale});}
@end quotation

When called from Fortran, this routine has the same effect as when
invoked from C. The interpretation of all parameters (see @code{plvect} (@pxref{plvect; Vector plot}))
is also the same except there is no transformation function supplied
as the last parameter. Instead, a 6-element array specifying
coefficients to use in the transformation is supplied via the named
common block @samp{plplot} (see code). Since this
approach is somewhat inflexible, the user is recommended to call
either of @code{plvec0} (@pxref{plvec0; Vector plot; identity mapping for fortran}), @code{plvec1} (@pxref{plvec1; Vector plot; general 1-d mapping for fortran}), or @code{plvec2} (@pxref{plvec2; Vector plot; general 2-d mapping for fortran}) instead.

@node plmesh; Plot surface mesh for fortran, plot3d; Plot 3-d surface plot for fortran, plvect; Vector plot; fixed linear mapping for fortran, The Specialized Fortran API for PLplot
@section   plmesh: Plot surface mesh for fortran  


@quotation

@t{
@b{plmesh}
(@i{x}, @i{y}, @i{z}, @i{nx}, @i{ny}, @i{opt}, @i{mx});}
@end quotation

When called from Fortran, this routine has the same effect as when
invoked from C. The interpretation of all parameters (see @code{plmesh} (@pxref{plmesh; Plot surface mesh}))
is also the same except there is an additional parameter given by:

@table @asis

@item   @code{mx}  (@samp{PLINT}, input)  
Length of array in x direction, for plotting subarrays.
@end table

@node plot3d; Plot 3-d surface plot for fortran, plparseopts; parse arguments for fortran, plmesh; Plot surface mesh for fortran, The Specialized Fortran API for PLplot
@section   plot3d: Plot 3-d surface plot for fortran  


@quotation

@t{
@b{plot3d}
(@i{x}, @i{y}, @i{z}, @i{nx}, @i{ny}, @i{opt}, @i{side}, @i{mx});}
@end quotation

When called from Fortran, this routine has the same effect as when
invoked from C. The interpretation of all parameters (see @code{plot3d} (@pxref{plot3d; Plot 3-d surface plot}))
is also the same except there is an additional parameter given by:

@table @asis

@item   @code{mx}  (@samp{PLINT}, input)  
Length of array in x direction, for plotting subarrays.
@end table

@node plparseopts; parse arguments for fortran, plsesc; Set the escape character for text strings for fortran, plot3d; Plot 3-d surface plot for fortran, The Specialized Fortran API for PLplot
@section   plparseopts: parse arguments for fortran  


@quotation

@t{
@b{plparseopts}
(@i{mode});}
@end quotation

When called from Fortran, this routine has the same effect as
when invoked from C (see @code{plparseopts} (@pxref{plparseopts; Parse command-line arguments})) except that the argument list
just contains the parsing mode and the fortran system routines
@code{iargc} and @code{getarg} 
are used internally to obtain the number of arguments and
argument values. (Note, during configuration, the user's
fortran compiler
is checked to see whether it supports 
@code{iargc} and @code{getarg}. If it
does not, the fortran plparseopts simply writes a warning message
and returns.

@table @asis

@item   @code{mode}  (@samp{PLINT}, input)  
Parsing mode; see @code{plparseopts} (@pxref{plparseopts; Parse command-line arguments}) for details.
@end table

@node plsesc; Set the escape character for text strings for fortran, , plparseopts; parse arguments for fortran, The Specialized Fortran API for PLplot
@section   plsesc: Set the escape character for text strings for fortran  


@quotation

@t{
@b{plsesc}
(@i{esc});}
@end quotation

Set the escape character for text strings. From
Fortran it needs to be the decimal ASCII value. Only
selected characters are allowed to prevent the user from shooting
himself in the foot (For example, a \ isn't allowed since it conflicts with C's use
of backslash as a character escape). Here are the allowed escape
characters and their corresponding decimal ASCII values:

@itemize @bullet{}

@item
!, ASCII 33

@item
#, ASCII 35

@item
$, ASCII 36

@item
%, ASCII 37

@item
&, ASCII 38

@item
*, ASCII 42

@item
@@, ASCII 64

@item
^, ASCII 94

@item
~, ASCII 126
@end itemize

@table @asis

@item   @code{esc}  (@samp{char}, input)  
NEEDS DOCUMENTATION
@end table

@node API compatibility definition, Obsolete/Deprecated API for PLplot, The Specialized Fortran API for PLplot, Top
@chapter API compatibility definition

This chapter presents the formal definition of what is considered to be
in the PLplot library API. It is assumed that major new releases of
PLplot will have substantial backwards incompatible changes in the API,
but the PLplot developers commit to introducing as few as possible of
such incompatibilities between minor releases such that stability
across those minor releases is practically guaranteed. In all cases
where backwards incompatible changes have been introduced, then the
library soname will be changed (for operating systems such as Linux
that support versioned shared libraries).

The information in this chapter regards version 5.5.3 of
PLplot, released on 2005-05-13.

@menu
* What is in the API?::
* Regression test for backwards compatibility::
@end menu

@node What is in the API?, Regression test for backwards compatibility, , API compatibility definition
@section   What is in the API?  

The formal definition of the PLplot C API is everything that is defined
in the include file @file{plplot.h}. This includes all
the function prototypes, the defined structures and the semantics of
the constants. The list of symbols currently exported by the shared
library @file{libplplot.h} that are declared in
@file{plplot.h} is the following:


@example
plAlloc2dGrid          plgdidev               plscmap1n
plClearOpts            plgdiori               plscol0
plFindCommand          plgdiplt               plscolbg
plFindName             plgesc                 plscolor
plFree2dGrid           plgfam                 plscompression
plGetCursor            plgfci                 plsdev
plGetFlt               plgfile                plsdidev
plGetInt               plgfnam                plsdimap
plGetName              plglevel               plsdiori
plHLS_RGB              plgpage                plsdiplt
plMergeOpts            plgra                  plsdiplz
plMinMax2dGrid         plgriddata             plseopH
plOptUsage             plgspa                 plsesc
plParseOpts            plgstrm                plsetopt
plRGB_HLS              plgver                 plsexit
plResetOpts            plgvpd                 plsfam
plSetOpt               plgvpw                 plsfci
plSetUsage             plgxax                 plsfile
plTranslateCursor      plgyax                 plsfnam
pl_cmd                 plgzax                 plshade
pl_setcontlabelformat  plhist                 plshade1
pl_setcontlabelparam   plhls                  plshades
pladv                  plhlsrgb               plsmaj
plarrows               plimage                plsmem
plaxes                 plinit                 plsmin
plbin                  pljoin                 plsori
plbop                  pllab                  plspage
plbox                  pllightsource          plspause
plbox3                 plline                 plsstrm
plcalc_world           plline3                plssub
plclear                pllsty                 plssym
plcol0                 plmap                  plstar
plcol1                 plmeridians            plstart
plcont                 plmesh                 plstr
plcpstrm               plmeshc                plstripa
pldid2pc               plmkstrm               plstripc
pldip2dc               plmtex                 plstripd
plend                  plot3d                 plstyl
plend1                 plot3dc                plsurf3d
plenv                  plot3dcl               plsurf3dl
plenv0                 plparseopts            plsvect
pleop                  plpat                  plsvpa
plerrx                 plpoin                 plsxax
plerry                 plpoin3                plsxwin
plf2eval               plpoly3                plsyax
plf2eval2              plprec                 plsym
plf2evalr              plpsty                 plszax
plfamadv               plptex                 pltext
plfcont                plreplot               pltr0
plfill                 plrgb                  pltr1
plfill3                plrgb1                 pltr2
plflush                plrgbhls               pltr2p
plfont                 plsButtonEH            plvasp
plfontld               plsError               plvect
plfshade               plsKeyEH               plvpas
plgDevs                plsabort               plvpor
plgFileDevs            plsbopH                plvsta
plgchr                 plschr                 plw3d
plgcol0                plscmap0               plwid
plgcolbg               plscmap0n              plwind
plgcompression         plscmap1               plxormod
plgdev                 plscmap1l              
@end example

Another important aspect of compatibility regard the Application
Binary Interface (ABI). Backwards compatibility can be broken by
changes in the C structures made public through
@file{plplot.h}. Currently, they are:


@example
typedef struct @{
    char *opt;
    int  (*handler)	(char *, char *, void *);
    void *client_data;
    void *var;
    long mode;
    char *syntax;
    char *desc;
@} PLOptionTable;

typedef struct @{
    int type;			/* of event (CURRENTLY UNUSED) */
    unsigned int state;		/* key or button mask */
    unsigned int keysym;	/* key selected */
    unsigned int button;	/* mouse button selected */
    PLINT subwindow;            /* subwindow (alias subpage, alias subplot) number */
    char string[PL_MAXKEY];	/* translated string */
    int pX, pY;			/* absolute device coordinates of pointer */
    PLFLT dX, dY;		/* relative device coordinates of pointer */
    PLFLT wX, wY;		/* world coordinates of pointer */
@} PLGraphicsIn;

typedef struct @{
    PLFLT dxmi, dxma, dymi, dyma;	/* min, max window rel dev coords */
    PLFLT wxmi, wxma, wymi, wyma;	/* min, max window world coords */
@} PLWindow;

typedef struct @{
    unsigned int x, y;			/* upper left hand corner */
    unsigned int width, height;		/* window dimensions */
@} PLDisplay;

typedef struct @{
    PLFLT *f;
    PLINT nx, ny, nz;
@} PLfGrid;

typedef struct @{
    PLFLT **f;
    PLINT nx, ny;
@} PLfGrid2;

typedef struct @{
    PLFLT *xg, *yg, *zg;
    PLINT nx, ny, nz;
@} PLcGrid;

typedef struct @{
    PLFLT **xg, **yg, **zg;
    PLINT nx, ny;
@} PLcGrid2;

typedef struct @{
    unsigned char r;		/* red */
    unsigned char g;		/* green */
    unsigned char b;		/* blue */
    char *name;
@} PLColor;

typedef struct @{
    PLFLT h;			/* hue */
    PLFLT l;			/* lightness */
    PLFLT s;			/* saturation */
    PLFLT p;			/* position */
    int rev;			/* if set, interpolate through h=0 */
@} PLControlPt;

typedef struct @{
    PLINT cmd;
    PLINT result;
@} PLBufferingCB;

@end example

@node Regression test for backwards compatibility, , What is in the API?, API compatibility definition
@section   Regression test for backwards compatibility  

Since PLplot is developed by so many people, the task of checking for
backwards compatiblity of the library is very hard. As for the 5.3.1
release, we do not have any rigorous regression test for check
whether the library is really backwards compatible.

However, here are some rules to be followed by the Release Manager
prior to releasing a new version of PLplot:

@itemize @bullet{}

@item
Check if there are any changes in
@file{plplot.h}. If no prototype is changed,
then the chances are high that no backwards compatibilities
have been introduced. If new functions has been added, then
the library soname will be kept, although the libtool soversion
string in @file{configure.ac} must be changed
from @samp{x:y:z} to
@samp{(x+1):0:(z+1)}. See the
libtool manual for details.

@item
A necessary, but not sufficient test consists of the following:
first, install the previous released version of PLplot in the
system and compile all the examples
@file{examples/c/x??c.}. After that, install the
to-be-released version of PLplot and try to run the previously
compiled examples. If they either link or run incorrectly,
then backwards incompatibilities have been introduced and the
soversion string must be upgraded from @samp{x:y:z}
to @samp{(x+1):0:0}.
@end itemize

@node Obsolete/Deprecated API for PLplot, Notes for each Operating System that We Support, API compatibility definition, Top
@chapter Obsolete/Deprecated API for PLplot

The purpose of this chapter is to provide minimal documentation for
obsolete/deprecated API that appears in our C library to provide backwards
compatibility until our next major release, PLplot-6, where these functions
will disappear. Do not use these functions, and if you already use them
in legacy PLplot applications, replace them by the suggested
equivalents so you won't be caught out by the next major PLplot release.

@menu
* plclr; Eject current page::
* plcol; Set color::
* plhls; Set current color by HLS::
* plHLS_RGB; Convert HLS color to RGB::
* plpage; Begin a new page::
* plrgb; Set line color by red; green::
* plrgb1; Set line color by 8-bit RGB values::
@end menu

@node plclr; Eject current page, plcol; Set color, , Obsolete/Deprecated API for PLplot
@section   plclr: Eject current page  


@quotation

@t{
@b{plclr}
();}
@end quotation

Deprecated. Use the new name, @code{pleop} (@pxref{pleop; Eject current page}), for this function instead.

@node plcol; Set color, plhls; Set current color by HLS, plclr; Eject current page, Obsolete/Deprecated API for PLplot
@section   plcol: Set color  


@quotation

@t{
@b{plcol}
(@i{color});}
@end quotation

Deprecated. Use the new name, @code{plcol0} (@pxref{plcol0; Set color; map0}), for this function instead.

@table @asis

@item   @code{color}  (@samp{PLINT}, input)  
See @code{plcol0} (@pxref{plcol0; Set color; map0}).
@end table

@node plhls; Set current color by HLS, plHLS_RGB; Convert HLS color to RGB, plcol; Set color, Obsolete/Deprecated API for PLplot
@section   plhls: Set current color by HLS  


@quotation

@t{
@b{plhls}
(@i{h}, @i{l}, @i{s});}
@end quotation

Set current color by hue, lightness, and saturation.
Convert hls color coordinates to rgb, then call plrgb.
Do @i{not} use this. Only retained for backward compatibility.
Use @code{plhlsrgb} (@pxref{plhlsrgb; Convert HLS color to RGB}) and @code{plscol0} (@pxref{plscol0; Set a given color from color map0 by 8 bit RGB value}) instead.

@table @asis

@item   @code{h}  (@samp{PLFLT}, input)  
NEEDS DOCUMENTATION

@item   @code{l}  (@samp{PLFLT}, input)  
NEEDS DOCUMENTATION

@item   @code{s}  (@samp{PLFLT}, input)  
NEEDS DOCUMENTATION
@end table

@node plHLS_RGB; Convert HLS color to RGB, plpage; Begin a new page, plhls; Set current color by HLS, Obsolete/Deprecated API for PLplot
@section   plHLS_RGB: Convert HLS color to RGB  


@quotation

@t{
@b{plHLS_RGB}
(@i{h}, @i{l}, @i{s}, @i{p_r}, @i{p_g}, @i{p_b});}
@end quotation

Use @code{plhlsrgb} (@pxref{plhlsrgb; Convert HLS color to RGB}) from the common API instead of this deprecated C-only
function.

@table @asis

@item   @code{h}  (@samp{PLFLT}, input)  
Hue, in degrees on the colour cone (0.0-360.0)

@item   @code{l}  (@samp{PLFLT}, input)  
Lightness, expressed as a fraction of the axis of the colour
cone (0.0-1.0)

@item   @code{s}  (@samp{PLFLT}, input)  
Saturation, expressed as a fraction of the radius of the
colour cone (0.0-1.0)

@item   @code{p_r}  (@samp{PLFLT *}, output)  
Pointer to red intensity (0.0-1.0) of the colour

@item   @code{p_g}  (@samp{PLFLT *}, output)  
Pointer to green intensity (0.0-1.0) of the colour

@item   @code{p_b}  (@samp{PLFLT *}, output)  
Pointer to blue intensity (0.0-1.0) of the colour
@end table

@node plpage; Begin a new page, plrgb; Set line color by red; green, plHLS_RGB; Convert HLS color to RGB, Obsolete/Deprecated API for PLplot
@section   plpage: Begin a new page  


@quotation

@t{
@b{plpage}
();}
@end quotation

Deprecated. Use the new name, @code{plbop} (@pxref{plbop; Begin a new page}), for this function instead.

@node plrgb; Set line color by red; green, plrgb1; Set line color by 8-bit RGB values, plpage; Begin a new page, Obsolete/Deprecated API for PLplot
@section   plrgb: Set line color by red, green  


@quotation

@t{
@b{plrgb}
(@i{r}, @i{g}, @i{b});}
@end quotation

Set line color by red, green, blue from 0. to 1. Do
@i{not} use this.
Only retained for backward compatibility. Use the function @code{plscol0} (@pxref{plscol0; Set a given color from color map0 by 8 bit RGB value})
instead.

@table @asis

@item   @code{r}  (@samp{PLFLT}, input)  
NEEDS DOCUMENTATION

@item   @code{g}  (@samp{PLFLT}, input)  
NEEDS DOCUMENTATION

@item   @code{b}  (@samp{PLFLT}, input)  
NEEDS DOCUMENTATION
@end table

@node plrgb1; Set line color by 8-bit RGB values, , plrgb; Set line color by red; green, Obsolete/Deprecated API for PLplot
@section   plrgb1: Set line color by 8-bit RGB values  


@quotation

@t{
@b{plrgb1}
(@i{r}, @i{g}, @i{b});}
@end quotation

Set line color by 8-bit RGB values. Do @i{not} use this.
Only retained for backward compatibility. Use the function @code{plscol0} (@pxref{plscol0; Set a given color from color map0 by 8 bit RGB value})
instead.

@table @asis

@item   @code{r}  (@samp{PLINT}, input)  
NEEDS DOCUMENTATION

@item   @code{g}  (@samp{PLINT}, input)  
NEEDS DOCUMENTATION

@item   @code{b}  (@samp{PLINT}, input)  
NEEDS DOCUMENTATION
@end table

@node Notes for each Operating System that We Support, , Obsolete/Deprecated API for PLplot, Top
@chapter Notes for each Operating System that We Support

The purpose of this Chapter is to present notes for
each operating system that we support. Although we have some
support for a number of operating systems,
we only have notes for Linux/Unix systems at this point.
NEEDS DOCUMENTATION

@menu
* Linux/Unix Notes::
@end menu

@node Linux/Unix Notes, , , Notes for each Operating System that We Support
@section Linux/Unix Notes

@menu
* Linux/Unix Configure; Build; and Installation::
* Linux/Unix Building of C Programmes that Use the Installed PLplot Libraries::
@end menu

@node Linux/Unix Configure; Build; and Installation, Linux/Unix Building of C Programmes that Use the Installed PLplot Libraries, , Linux/Unix Notes
@subsection Linux/Unix Configure, Build, and Installation

Here is the short story:

@example

./configure
make
make install
@end example

The longer story is there are a lot of possible configure options.
Two of the more important configure options are 
@samp{--prefix} and @samp{--with-double}.
Here is the complete list of configuration options:

@example

./configure --help
No defaults file found, performing full configure.
Usage: configure [options] [host]
Options: [defaults in brackets after descriptions]
Configuration:
  --cache-file=FILE       cache test results in FILE
  --help                  print this message
  --no-create             do not create output files
  --quiet, --silent       do not print `checking...' messages
  --version               print the version of autoconf that created configure
Directory and file names:
  --prefix=PREFIX         install architecture-independent files in PREFIX
                          [/usr/local/plplot]
  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
                          [same as prefix]
  --bindir=DIR            user executables in DIR [EPREFIX/bin]
  --sbindir=DIR           system admin executables in DIR [EPREFIX/sbin]
  --libexecdir=DIR        program executables in DIR [EPREFIX/libexec]
  --datadir=DIR           read-only architecture-independent data in DIR
                          [PREFIX/share]
  --sysconfdir=DIR        read-only single-machine data in DIR [PREFIX/etc]
  --sharedstatedir=DIR    modifiable architecture-independent data in DIR
                          [PREFIX/com]
  --localstatedir=DIR     modifiable single-machine data in DIR [PREFIX/var]
  --libdir=DIR            object code libraries in DIR [EPREFIX/lib]
  --includedir=DIR        C header files in DIR [PREFIX/include]
  --oldincludedir=DIR     C header files for non-gcc in DIR [/usr/include]
  --infodir=DIR           info documentation in DIR [PREFIX/info]
  --mandir=DIR            man documentation in DIR [PREFIX/man]
  --srcdir=DIR            find the sources in DIR [configure dir or ..]
  --program-prefix=PREFIX prepend PREFIX to installed program names
  --program-suffix=SUFFIX append SUFFIX to installed program names
  --program-transform-name=PROGRAM
                          run sed PROGRAM on installed program names
Host type:
  --build=BUILD           configure for building on BUILD [BUILD=HOST]
  --host=HOST             configure for HOST [guessed]
  --target=TARGET         configure for TARGET [TARGET=HOST]
Features and packages:
  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
  --x-includes=DIR        X include files are in DIR
  --x-libraries=DIR       X library files are in DIR
--enable and --with options recognized:
  --with-defaults         source defaults file at startup (yes)
  --with-debug            compile with debugging (no)
  --with-opt              compile with optimization (yes)
  --with-double           use double precision floats (no)
  --with-profile          turn on profiling option (no)
  --with-shlib            build shared libraries (yes)
  --with-gcc              use gcc to compile C and C++ code (yes)
  --with-warn             enable all compilation warnings (no)
  --with-dbmalloc         link with libdbmalloc (no)
  --with-pkgdir=DIR       locate libraries and includes under DIR
  --with-fseek            use fseek/ftell rather than fsetpos/fgetpos (no)
  --with-rpath            link libraries with -rpath option (yes)
  --enable-f77            compile Fortran-77 interface code (yes)
  --enable-cxx            compile C++ interface code (yes)
  --enable-python         compile python interface code (yes)
  --enable-tcl            compile Tcl interface code (yes)
  --enable-itcl           enable incr Tcl interface code (yes)
  --with-x                use the X Window System
  --with-gtk-prefix=PFX   Prefix where GTK is installed (optional)
  --with-gtk-exec-prefix=PFX Exec prefix where GTK is installed (optional)
  --disable-gtktest       Do not try to compile and run a test GTK program
  --with-gnome-includes   Specify location of GNOME headers
  --with-gnome-libs       Specify location of GNOME libs
  --with-gnome            Specify prefix for GNOME files
  --enable-plmeta         enable plmeta device driver ()
  --enable-null           enable null device driver ()
  --enable-xterm          enable xterm device driver ()
  --enable-tek4010        enable tek4010 device driver ()
  --enable-tek4107        enable tek4107 device driver ()
  --enable-mskermit       enable mskermit device driver ()
  --enable-conex          enable conex device driver ()
  --enable-linuxvga       enable linuxvga device driver ()
  --enable-vlt            enable vlt device driver ()
  --enable-versaterm      enable versaterm device driver ()
  --enable-dg300          enable dg300 device driver ()
  --enable-ps             enable ps device driver ()
  --enable-xfig           enable xfig device driver ()
  --enable-ljii           enable ljii device driver ()
  --enable-hp7470         enable hp7470 device driver ()
  --enable-hp7580         enable hp7580 device driver ()
  --enable-lj_hpgl        enable lj_hpgl device driver ()
  --enable-imp            enable imp device driver ()
  --enable-xwin           enable xwin device driver (yes)
  --enable-tk             enable tk device driver (yes)
  --enable-pbm            enable pbm device driver ()
  --enable-gnome          enable gnome device driver (no)
@end example

The configure script looks for default
configuration options first in @file{./cf_plplot.in}.
If that file is not found, the script then looks in
@file{$HOME/config/cf_plplot.in}.
Finally, if neither file is found or if the found file
does not have a particular default option, then the script
uses the above defaults. Here is one example of a default
configuration file. Adapt this for your needs or else use
the command-line parameters for the configuration file.

@example

# --*-sh-*---------------------------------------------------------------
#
# PLplot configure script default variables.
#
#
# Note: the internal representation of the --with-<option> and
# --enable-<option> command line switches actually uses an underscore,
# e.g. with_<option> and enable_<option>.  Don't forget!
#
# -----------------------------------------------------------------------

# Method to turn off Fortran and C++ bindings.
 
enable_cxx="no" 
enable_f77="no" 
  
# Devices are selected by --enable or --disable on the command line, but 
# only shell variables of the form enable_<option> are recognized here. 
   
enable_tek4010="no" 
enable_mskermit="no" 
enable_conex="no" 
enable_vlt="no" 
enable_versaterm="no" 
enable_xfig="no" 
    
enable_dg300="no" 
enable_imp="no" 
enable_tek4107="no" 
enable_hp7470="no" 
enable_hp7580="no"
@end example

@node Linux/Unix Building of C Programmes that Use the Installed PLplot Libraries, , Linux/Unix Configure; Build; and Installation, Linux/Unix Notes
@subsection Linux/Unix Building of C Programmes that Use the   Installed PLplot Libraries

This is incomplete. NEEDS DOCUMENTATION. 
@file{$prefix/bin/plplot-config} is a
useful tool for helping with building of C programmes that use 
the PLplot libraries.

@example

./plplot-config --help
Usage: plplot-config [OPTIONS]
Options:
        [--prefix[=DIR]]
	[--version]
	[--libs]
	[--cflags]
	[--with-c++]
	[--help]
@end example

@noindent
For example, the @samp{--cflags} parameter displays the
flags for compiling, and the @samp{--libs} parameter
displays the flags for linking your application. The displayed flags
are exactly consistent with the configuration specified when PLplot
was last built and installed.

@bye
